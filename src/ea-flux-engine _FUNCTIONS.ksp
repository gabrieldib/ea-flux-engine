// import "ARP/__ARP 03 functions.ksp"

{{ MAIN }}
function draw_seq
    { SHOW / HIDE dual and joined seq panels }
    panel_MAIN.2SEQ    -> hide := switch_MAIN.SEQ.combine * HIDE_WHOLE_CONTROL
    panel_MAIN.SEQjoin -> hide := abs(1-switch_MAIN.SEQ.combine) * HIDE_WHOLE_CONTROL

    if switch_MAIN.SEQ.combine = 0 { dual seq }
        label_SEQjoin.background    -> parent_panel := get_ui_id(panel_MAIN.2SEQ)
        label_SEQjoin.background    -> UI_HIDE
    else
        label_SEQjoin.background    -> parent_panel := get_ui_id(panel_MAIN.SEQjoin)
        label_SEQjoin.background    -> UI_SHOW
    end if
    
    for ds.counter := 0 to SEQ.COMMON_ELEMENTS_COUNT-1
        { change ui_control parent }
        SEQ.common_elements_data [ ds.counter, ELEMENT_UIID ] -> parent_panel := ...
            SEQ.common_elements_data [ ds.counter, switch_MAIN.SEQ.combine ]

        { update the coordinates }
        if switch_MAIN.SEQ.combine = 0 { dual seq }
            // message("drawing dual seq ")
            SEQ.common_elements_data [ ds.counter, ELEMENT_UIID ] -> pos_x := ...
                SEQ.common_elements_data [ ds.counter, PANEL_DUAL_SEQ_X_COORD ]

            SEQ.common_elements_data [ ds.counter, ELEMENT_UIID ] -> pos_y := ...
                SEQ.common_elements_data [ ds.counter, PANEL_DUAL_SEQ_Y_COORD ]

            if in_range(ds.counter, 29, 32)
                UIID_FLUX_RAND_RIGHT [ ds.counter - 29 ] -> picture := "button_fluxx_block_" & ds.counter - 28
            end if

        else                           { join seq }
            // message("drawing join seq ")
            SEQ.common_elements_data [ ds.counter, ELEMENT_UIID ] -> pos_x := ...
                SEQ.common_elements_data [ ds.counter, PANEL_JOIN_SEQ_X_COORD ]

            SEQ.common_elements_data [ ds.counter, ELEMENT_UIID ] -> pos_y := ...
                SEQ.common_elements_data [ ds.counter, PANEL_JOIN_SEQ_Y_COORD ]

            if in_range(ds.counter, 29, 32)
                UIID_FLUX_RAND_RIGHT [ ds.counter - 29 ] -> picture := "button_fluxx_block_" & ds.counter - 24
            end if
        end if
    end for
    

    
    // message("DUAL hide state: " & SEQ.common_elements_data [ 0, PANEL_DUAL_SEQ_PARENT_UIID ] -> hide)
    // message("JOIN hide state: " & SEQ.common_elements_data [ 0, PANEL_JOIN_SEQ_PARENT_UIID ] -> hide)
    // message("switch_MAIN.SEQ.combine: " & switch_MAIN.SEQ.combine)"
end function

{{ LFO }}
function update_lfo_ms_rates
    beat_rates [ 00 ] := (DURATION_SIXTEENTH/8)/1000
    beat_rates [ 01 ] := (DURATION_SIXTEENTH_TRIPLET/2)/1000
    beat_rates [ 02 ] := (DURATION_SIXTEENTH/4)/1000
    beat_rates [ 03 ] := (DURATION_SIXTEENTH_TRIPLET/2)/1000
    beat_rates [ 04 ] := (DURATION_SIXTEENTH/2)/1000
    beat_rates [ 05 ] := (DURATION_SIXTEENTH_TRIPLET)/1000
    beat_rates [ 06 ] := (DURATION_SIXTEENTH)/1000
    beat_rates [ 07 ] := (DURATION_EIGHTH_TRIPLET)/1000
    beat_rates [ 08 ] := (3*DURATION_SIXTEENTH/2)/1000
    beat_rates [ 09 ] := (DURATION_EIGHTH)/1000
    beat_rates [ 10 ] := (DURATION_QUARTER_TRIPLET)/1000
    beat_rates [ 11 ] := (DURATION_SIXTEENTH* 3)/1000
    beat_rates [ 12 ] := (DURATION_QUARTER)/1000
    beat_rates [ 13 ] := (DURATION_QUARTER_TRIPLET * 2)/1000
    beat_rates [ 14 ] := (DURATION_EIGHTH * 3)/1000
    beat_rates [ 15 ] := (DURATION_QUARTER * 2)/1000
    beat_rates [ 16 ] := (DURATION_QUARTER * 3)/1000
    beat_rates [ 17 ] := (DURATION_QUARTER_TRIPLET * 4)/1000
    beat_rates [ 18 ] := (DURATION_QUARTER * 4)/1000
    LFO_rate := beat_rates [ slider_MAIN.LFO.rate / __BEAT_RATE_DIVISOR ]
    SEQ.rate [ __LEFT  ] := beat_rates [ (UIID_MAIN.SEQ.rate_sliders [ 0 ] -> value) / __BEAT_RATE_DIVISOR ]
    SEQ.rate [ __RIGHT ] := beat_rates [ (UIID_MAIN.SEQ.rate_sliders [ 1 ] -> value) / __BEAT_RATE_DIVISOR ]
    LFO_sine_step := (2.0 * NI_MATH_PI) / float(LFO_rate)
end function

function LCB_data_update
    if __BPM # round((60000000.0 / float(DURATION_QUARTER)) * 100.0)/100.0
        __BPM := round((60000000.0 / float(DURATION_QUARTER)) * 100.0)/100.0
        message("BPM changed to " & __BPM)
        call update_lfo_ms_rates
        lcb_ms_counter := 0

    end if 
end function

{{ SEQ COMMON }}
function fn006_recall_seq_values
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        fn006.l.mode_side := fn006.a.side
    else
        fn006.l.mode_side := __LEFT
    end if
    // message("fn006 showing target: " & SEQ.showing_target [ fn006.l.mode_side ])
    // message("     fn006.a.side: " & fn006.a.side)

    for i.i := 0 to 31
        UIID_MAIN.seq.step [ fn006.a.side, i.i ] -> picture_state := ...
            int(                                              ...
                float(SEQ_XY_H-1) *                           ...
                SEQ.data.f [                                  ...
                    fn006.a.side,                             ...
                    SEQ.showing_target [ fn006.l.mode_side ], ...
                    i.i                                       ...
                ]                                             ...
            )
    end for
end function

{{ SEQ DUAL }}
function fn001_get_seq_step_index
    fn001.l.xy_x := get_control_par_real_arr(   ...
        UIID_MAIN.SEQ.xypads [ fn001.a.side ], ...
        CONTROL_PAR_VALUE,                     ...
        0                                      ...
    ) 
    
    fn001.l.xy_x.normalized := fn001.l.xy_x - 0.25 * float(fn001.a.block_index)

    fn001.r.step_index := int(( fn001.l.xy_x.normalized )/ SEQ.DUAL.step_width [ fn001.a.side, fn001.a.block_index ]) + ...
        8 * fn001.a.block_index

    if fn001.r.step_index = 32
        fn001.r.step_index := 31
    end if
end function

function fn018_set_seq_step_picture_state
    // message("    ps = " & int(float(SEQ_XY_H-1) * fn018.a.value) & " | value " & fn018.a.value)
    UIID_MAIN.seq.step [ fn018.a.side, fn018.a.step_index ] -> picture_state := ...
        int(float(SEQ_XY_H-1) * fn018.a.value)
end function

function fn019_set_seq_step_value
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        fn019.l.mode_side := fn019.a.side
    else
        fn019.l.mode_side := __LEFT
    end if

    SEQ.data.i [                                  ...
        fn019.a.side,                             ...
        SEQ.showing_target [ fn019.l.mode_side ], ...
        fn019.a.step_index                        ...
    ] := int( 1000000.0 * fn019.a.value )

    SEQ.data.f [                                  ...
        fn019.a.side,                             ...
        SEQ.showing_target [ fn019.l.mode_side ], ...
        fn019.a.step_index                        ...
    ] := fn019.a.value
end function

function fn002_set_seq_step_value_and_ps
    fn018.a.side       := fn002.a.side
    fn018.a.step_index := fn002.a.step_index
    fn018.a.value      := fn002.a.value
    call fn018_set_seq_step_picture_state

    fn019.a.side       := fn002.a.side
    fn019.a.step_index := fn002.a.step_index
    fn019.a.value      := fn002.a.value
    call fn019_set_seq_step_value
    // message("FN02 setting the value for step index: " & fn002.a.step_index)
end function

function fn013_update_seq_step_pictures
    // message("FN13 updating step pictures UNI/BIP")
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        fn013.l.mode_side := fn013.a.side
    else
        fn013.l.mode_side := __LEFT
    end if
    // message("    updating side: " & fn013.l.mode_side )
    for fn013.l.step := 0 to 7
        UIID_MAIN.seq.step [ fn013.a.side, fn013.l.step + (fn013.a.block_index mod 4 ) * 8 ] -> picture := ...
            SEQ_step_pictures [                                             ...
                SEQ.DUAL.step_count [ fn013.a.side, fn013.a.block_index mod 4 ] + ...
                SEQ.target_type [ SEQ.showing_target [ fn013.l.mode_side ] ] * 8 ...
            ]
        // message("    step picture set to " & SEQ_step_pictures [                                             ...
        //         SEQ.DUAL.step_count [ fn013.a.side, fn013.a.block_index mod 4 ] + ...
        //         SEQ.target_type [ SEQ.showing_target [ fn013.l.mode_side ] ] * 8 ...
        //     ])
    end for
end function

function fn003_set_block_step_count
    { PENDING OPTIMIZE CODE }

    { needed for the seq xy }
    // message("FN003 block_index: " & fn003.a.block_index & " side: " & fn003.a.side)
    fn013.a.side        := fn003.a.side
    fn013.a.block_index := fn003.a.block_index
    call fn013_update_seq_step_pictures

    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        // message("    DUAL step count: "  & SEQ.DUAL.step_count [ fn003.a.side, fn003.a.block_index mod 4  ])
        fn003.l.block_index_mod := fn003.a.block_index mod 4

        SEQ.DUAL.step_width [ fn003.a.side, fn003.l.block_index_mod ] := ...
            SEQ_XY_DUAL_BLOCK_W / float(SEQ.DUAL.step_count [ fn003.a.side, fn003.l.block_index_mod ] + 1)
        // message(" SEQ.DUAL.step_width = " & SEQ.DUAL.step_width [ fn003.a.side, fn003.a.block_index ])

        UIID_MAIN.seq.leds [ fn003.a.side, fn003.l.block_index_mod ] -> picture := ...
            SEQ_step_led_pictures [ SEQ.DUAL.step_count [ fn003.a.side, fn003.l.block_index_mod ] ]

        { update the number of step sliders and their pictures }
        for fn003.l.counter := 0 to 7
            if fn003.l.counter <= SEQ.DUAL.step_count [ fn003.a.side, fn003.l.block_index_mod ]
                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + fn003.l.block_index_mod * 8 ] -> UI_SHOW
                
                // UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + fn003.a.block_index * 8 ] -> picture := ...
                //     SEQ_step_pictures [ SEQ.DUAL.step_count [ fn003.a.side, fn003.a.block_index ] + ...
                //         SEQ.target_type [ SEQ.showing_target [ fn003.a.side ] ] * 8 ]

                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + fn003.l.block_index_mod * 8 ] -> pos_x := ...
                    SEQ_STEP_COORD [                                               ...
                        fn003.a.mode,                                              ...
                        fn003.a.side,                                              ...
                        SEQ.DUAL.step_count [ fn003.a.side, fn003.l.block_index_mod ], ...
                        fn003.l.counter                                                        ...
                    ] + SEQ_XY_BLOCK_START_OFFSET [ fn003.l.block_index_mod ]

            else
                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + fn003.l.block_index_mod * 8 ] -> UI_HIDE
            end if
        end for
    else

        SEQ.JOIN.step_width [ fn003.a.block_index ] := ...
            SEQ_XY_JOIN_BLOCK_W / float(SEQ.JOIN.step_count [ fn003.a.block_index ] + 1)
        // message(" SEQ.JOIN.step_width = " & SEQ.JOIN.step_width [ fn003.a.block_index ])
        UIID_MAIN.seq.leds [ fn003.a.side, fn003.a.block_index mod 4 ] -> picture := ...
            SEQ_step_led_pictures [ SEQ.JOIN.step_count [ fn003.a.block_index ] ]

        // message("    JOIN step count: " & SEQ.JOIN.step_count [ fn003.a.block_index ])

        for fn003.l.counter := 0 to 7
            if fn003.l.counter <= SEQ.JOIN.step_count [ fn003.a.block_index ]
                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + (fn003.a.block_index mod 4 ) * 8 ] -> UI_SHOW
                
                // UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + (fn003.a.block_index mod 4 ) * 8 ] -> picture := ...
                //     SEQ_step_pictures [ SEQ.JOIN.step_count [ fn003.a.block_index ] + ...
                //         SEQ.target_type [ SEQ.showing_target [ fn003.a.side ] ] * 8 ]

                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + (fn003.a.block_index mod 4 ) * 8 ] -> pos_x := ...
                    SEQ_STEP_COORD [                                               ...
                        fn003.a.mode,                                              ...
                        fn003.a.side,                                              ...
                        SEQ.JOIN.step_count [ fn003.a.block_index ], ...
                        fn003.l.counter                                                        ...
                    ] + SEQ_XY_BLOCK_START_OFFSET [ fn003.a.block_index mod 4 ]

            else
                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + (fn003.a.block_index mod 4 ) * 8 ] -> UI_HIDE
            end if
        end for

    end if 
end function

function fn004_get_current_seq_block
    for fn004.l.block_counter := 0 to 3
        if  fn004.a.x_coord >= SEQ_DUAL_XY_BLOCK_START_END [ fn004.l.block_counter, __START ] and ...
            fn004.a.x_coord <= SEQ_DUAL_XY_BLOCK_START_END [ fn004.l.block_counter, __END ]
            fn004.r.block_index := fn004.l.block_counter
        end if
    end for
end function

function get_seq_dual_step_index
    fn004.a.x_coord := get_control_par_real_arr(  ...
        UIID_MAIN.SEQ.xypads [ uics_uiid_index ], ...
        CONTROL_PAR_VALUE,                        ...
        0                                         ...
    ) 
    call fn004_get_current_seq_block
    fn001.a.block_index := fn004.r.block_index
    fn001.a.side        := uics_uiid_index
    call fn001_get_seq_step_index
end function

{{ SEQ JOIN }}
function get_seq_join_step_index
    fn008.a.x_coord := xypad_MAIN.SEQ.join [ 0 ]
    call fn008_get_current_seq_join_block

    fn009.a.block_index := fn008.r.block_index
    // message("GET_SEQ_JOIN_STEP_INDEX, block: " & fn009.a.block_index)

    call fn009_get_seq_join_step_index
end function

function fn008_get_current_seq_join_block
    for fn008.l.block_counter := 0 to 7
        if  fn008.a.x_coord >= SEQ_JOIN_XY_BLOCK_START_END [ fn008.l.block_counter, __START ] and ...
            fn008.a.x_coord <= SEQ_JOIN_XY_BLOCK_START_END [ fn008.l.block_counter, __END ]
            fn008.r.block_index := fn008.l.block_counter
            // message("FN008_GET_CURRENT_SEQ_JOIN_BLOCK " & fn008.r.block_index)
        end if
    end for
end function

function fn009_get_seq_join_step_index
    // message("FN009_GET_SEQ_JOIN_STEP_INDEX ---------- ")
    fn009.l.xy_x := xypad_MAIN.SEQ.join [ 0 ]
    
    fn009.l.xy_x.normalized := fn009.l.xy_x - 0.125 * float(fn009.a.block_index)    

    fn009.r.step_index := int(( fn009.l.xy_x.normalized )/ SEQ.JOIN.step_width [ fn009.a.block_index ]) + ...
        8 * fn009.a.block_index
    // message("        block ______: " & fn009.a.block_index)
    // message("        x __________: " & fn009.l.xy_x)
    // message("        x normalized: " & fn009.l.xy_x.normalized)
    // message("        Step W _____: " & SEQ.JOIN.step_width [ fn009.a.block_index ])
    // message("        step index  : " & fn009.r.step_index)

    if fn009.r.step_index = 32 and xypad_MAIN.SEQ.join [ 0 ] < 0.5
        fn009.r.step_index := 31
    end if
    if fn009.r.step_index = 64 and xypad_MAIN.SEQ.join [ 0 ] > 0.99
        fn009.r.step_index := 63
    end if
end function

function fn010_set_seq_step_value
    // message("FN010_SET_SEQ_STEP_VALUE ---------- ")
    // message("    fn10 side: " & fn010.l.side)
    // message("    fn10 step index: " & fn010.a.step_index)

    UIID_MAIN.seq.step [ fn010.l.side, fn010.a.step_index mod 32 ] -> picture_state := ...
        int(float(SEQ_XY_H-1) * fn010.a.value)

    { depends on the target showing }
    // message("FN10 setting the value for step index: " & fn010.a.step_index)
    SEQ.data.i [                             ...
        fn010.l.side,                        ...
        SEQ.showing_target [ fn010.l.side ], ...
        fn010.a.step_index mod 32            ...
    ] := int( 1000000.0 * fn010.a.value )

    SEQ.data.f [                             ...
        fn010.l.side,                        ...
        SEQ.showing_target [ fn010.l.side ], ...
        fn010.a.step_index mod 32            ...
    ] := fn010.a.value
end function

function fn012_seq_recall_step_count
    for b.i := 0 to 3
        fn003.a.mode        := switch_MAIN.SEQ.combine
        fn003.a.side        := fn012.a.side // __LEFT then __RIGHT
        if switch_MAIN.SEQ.combine = __SEQ_DUAL
            fn003.a.block_index := b.i
        else
            fn003.a.block_index := b.i + 4 * fn012.a.side
        end if

        call fn003_set_block_step_count

    end for
end function

{{ general  }}
function fn005_set_seq_target_selector
    for i.i := 0 to 4
        UIID_MAIN.seq.target_selectors [ i.i ] -> value := __OFF
    end for
    if in_range(fn005.a.selector_index, 0, 4)
        UIID_MAIN.seq.target_selectors [ fn005.a.selector_index ] -> value := __ON
    end if
end function

function fn011_clear_target_activators
    for i.i := 0 to 4
        UIID_MAIN.seq.target_activators [ fn011.a.side, i.i] -> value := __OFF
    end for
    if in_range(fn011.a.index, 0, 4)
        UIID_MAIN.seq.target_activators [ fn011.a.side, fn011.a.index ] -> value := __ON
    end if
end function

function fn014_seq_recall_target_steps_values_and_pictures
    // message("FN14 called")
    // message("    fn014.a.side: " & fn014.a.side)
    // message("    fn014.a.target_index: " & fn014.a.target_index)
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        fn006.a.side := fn014.a.side
        call fn006_recall_seq_values
        for fn014.l.counter := 0 to 3
            fn013.a.side        := fn014.a.side
            fn013.a.block_index := fn014.l.counter
            call fn013_update_seq_step_pictures
        end for
    else
        { mirror the right side }
        fn011.a.side  := __RIGHT
        fn011.a.index := fn014.a.target_index
        call fn011_clear_target_activators

        SEQ.showing_target [ __RIGHT ] := fn014.a.target_index 

        for fn014.l.counter := 0 to 1
            fn006.a.side := fn014.l.counter
            call fn006_recall_seq_values

            for fn014.l.counter2 := 0 to 3
                fn013.a.side        := fn014.l.counter
                fn013.a.block_index := fn014.l.counter2 + fn014.l.counter * 4
                call fn013_update_seq_step_pictures
            end for
        end for
    end if
end function

function fn015_set_seq_play_direction_btns
    for i.i := 0 to 2
        UIID_MAIN.seq.direction_btns [ fn015.a.side,  i.i] -> value := __OFF
    end for
    UIID_MAIN.seq.direction_btns [ fn015.a.side, fn015.a.btn_index] -> value := __ON
end function

function set_seq_target_selectors_text_alignment
    for i.i := 0 to 4
        UIID_MAIN.seq.target_selectors [ i.i ] -> text_alignment := abs(1 - switch_MAIN.SEQ.combine)
    end for
end function

function fn016_set_data_display_from_seq_xy
    select(SEQ.showing_target [ fn016.a.target_index ])
        case SEQ_TARGET_VELO  
            @fn016.r.title      := "velocity"
            if fn016.a.value * 127.0 = 0.0
                @fn016.r.text_data := "1"
            else
                @fn016.r.text_data := int(fn016.a.value * 127.0)
            end if

        case SEQ_TARGET_PITCH 
            @fn016.r.title      := "pitch"
            if UIID_MAIN.SEQ.xypads [ uics_uiid_index ] -> key_shift = __ON
                @fn016.r.text_data := round((fn016.a.value * 24.0 - 12.0)*100.0)/100.0
            else
                @fn016.r.text_data := int(fn016.a.value * 24.0 - 12.0)
            end if

        case SEQ_TARGET_OCTAVE
            @fn016.r.title      := "octave"
            if UIID_MAIN.SEQ.xypads [ uics_uiid_index ] -> key_shift = __ON
                @fn016.r.text_data := round((fn016.a.value * 4.0 - 2.0)*100.0)/100.0
            else
                @fn016.r.text_data := int(fn016.a.value * 4.0 - 2.0)
            end if

        case SEQ_TARGET_PAN
            @fn016.r.title      := "pan"
            if fn016.a.value < 0.49
                @fn016.r.text_data := int(100.0 - abs(fn016.a.value * 200.0)) & " L"
            else
                if fn016.a.value > 0.51
                    @fn016.r.text_data := int(abs((fn016.a.value-0.5) * 200.0)) & " R"
                else
                    @fn016.r.text_data := "Center"
                end if
            end if

        case SEQ_TARGET_FILTER
            if fn016.a.value < 0.49 { low  pass }
                set_engine_par(ENGINE_PAR_CUTOFF, int(fn016.a.value * 2000000.0), __NO_GROUP, __LP_FILTER_CA_SLOT, NI_BUS_OFFSET+15)
                @fn016.r.title     := "Low Pass"
                @fn016.r.text_data := get_engine_par_disp(ENGINE_PAR_CUTOFF, __NO_GROUP, __LP_FILTER_CA_SLOT, NI_BUS_OFFSET+15) & "hz"
            else                   { high pass }
                if fn016.a.value > 0.51
                    set_engine_par(ENGINE_PAR_CUTOFF, int((fn016.a.value-0.5) * 2000000.0), __NO_GROUP, __HP_FILTER_CA_SLOT, NI_BUS_OFFSET+15)
                    @fn016.r.title     := "High Pass"
                    @fn016.r.text_data := get_engine_par_disp(ENGINE_PAR_CUTOFF, __NO_GROUP, __HP_FILTER_CA_SLOT, NI_BUS_OFFSET+15) & "hz"
                else
                    @fn016.r.title     := "Filter Off"
                    @fn016.r.text_data := "Off"
                end if
            end if

    end select
end function

function fn017_get_seq_target_data
    if UIID_MAIN.seq.target_power [ fn017.a.side, SEQ_TARGET_VELO ] -> value = __ON
        fn017.r.velocity := (126 *                                  ...
            SEQ.data.i [                                            ...
                fn017.a.side,                                       ...
                SEQ_TARGET_VELO,                                    ...
                fn017.a.step_counter + fn017.a.block_step_index * 8 ...
            ] ) / 1000000 + 1
    else
        fn017.r.velocity := layers.note_velo [ fn017.a.side, fn017.a.key_note ]
    end if

    if UIID_MAIN.seq.target_power [ fn017.a.side, SEQ_TARGET_PITCH ] -> value = __ON
        fn017.r.pitch := (24 *                                      ...
            SEQ.data.i [                                            ...
                fn017.a.side,                                       ...
                SEQ_TARGET_PITCH,                                   ...
                fn017.a.step_counter + fn017.a.block_step_index * 8 ...
            ] ) / 1000000 - 12
    else
        fn017.r.pitch := 0
    end if

    if UIID_MAIN.seq.target_power [ fn017.a.side, SEQ_TARGET_OCTAVE ] -> value = __ON
        fn017.r.octave := (4 *                                      ...
            SEQ.data.i [                                            ...
                fn017.a.side,                                       ...
                SEQ_TARGET_OCTAVE,                                  ...
                fn017.a.step_counter + fn017.a.block_step_index * 8 ...
            ] ) / 1000000 - 2
    else
        fn017.r.octave := 0
    end if

    if UIID_MAIN.seq.target_power [ fn017.a.side, SEQ_TARGET_PAN ] -> value = __ON
        fn017.l.pan_data :=                                     ...
        SEQ.data.i [                                            ...
            fn017.a.side,                                       ...
            SEQ_TARGET_PAN,                                     ...
            fn017.a.step_counter + fn017.a.block_step_index * 8 ...
        ]
        if fn017.l.pan_data < 500000
            fn017.r.pan := (-1) * (1000 - fn017.l.pan_data / 500)
        else
            fn017.r.pan := (fn017.l.pan_data-500000) / 500
        end if
    else
        fn017.r.pan := 0
    end if

    if UIID_MAIN.seq.target_power [ fn017.a.side, SEQ_TARGET_FILTER ] -> value = __ON
        fn017.r.filter_status := __ON
        fn017.l.filter_data   :=                                ...
        SEQ.data.i [                                            ...
            fn017.a.side,                                       ...
            SEQ_TARGET_FILTER,                                  ...
            fn017.a.step_counter + fn017.a.block_step_index * 8 ...
        ]
        fn017.r.filter_value := fn017.l.filter_data
        if fn017.l.filter_data < 490000  { low pass }
            fn017.r.lp_filter_value := fn017.l.filter_data * 2
            fn017.r.hp_filter_value := 0
        else                             { high pass }
            if fn017.l.filter_data > 510000
                fn017.r.lp_filter_value := 1000000
                fn017.r.hp_filter_value := (fn017.l.filter_data - 500000) * 2
            else { center point, both filters off }
                fn017.r.lp_filter_value := 1000000
                fn017.r.hp_filter_value := 0
            end if 
        end if
    else
        fn017.r.filter_status := __OFF
        fn017.r.filter_value  := 500000
    end if
end function

function fn020_update_seq_target_off_label
    if fn020.a.seq_power_state = __ON
        if  fn020.a.target_power_uiid -> value = __OFF
            UIID_MAIN.seq.off_label [ fn020.a.side ] -> picture := "label_FX.off"
            UIID_MAIN.seq.off_label [ fn020.a.side ] -> UI_SHOW
            UIID_MAIN.seq.off_label [ fn020.a.side ] -> text := "TARGET " & SEQ.target_names [ fn020.a.target_index ] & " IS OFF"
        else
            UIID_MAIN.seq.off_label [ fn020.a.side ] -> UI_HIDE
        end if
    else
        UIID_MAIN.seq.off_label [ fn020.a.side ] -> UI_SHOW
        UIID_MAIN.seq.off_label [ fn020.a.side ] -> picture := "label_seq_steps_bg"
        UIID_MAIN.seq.off_label [ fn020.a.side ] -> text := "SEQUENCER IS OFF"
    end if

end function

function fn21_get_seq_target_active_activator
    for fn021.l.counter := 0 to 4 { 5 activator buttons per side }
        if  UIID_MAIN.seq.target_activators [ fn021.a.side, fn021.l.counter ] -> value = __ON
            fn021.r.active_index := fn021.l.counter
            exit
        end if
    end for

end function


{{ play engine }}
function fn007_update_block_and_steps_ts
    if switch_MAIN.SEQ.combine = __SEQ_DUAL

        if  seq.direction_status [ fn007.a.side ] = SEQ_DIRECTION_FORWARD
            inc(SEQ.DUAL.current_block [ fn007.a.side ])
            if SEQ.DUAL.current_block [ fn007.a.side ] > 3
                { check the actual selected direction button }
                if layers.seq_play_direction [ fn007.a.side ] = SEQ_DIRECTION_FWBW
                    SEQ.DUAL.current_block [ fn007.a.side ] := 3
                    seq.direction_status [ fn007.a.side ] := SEQ_DIRECTION_BACKWARD
                else { regular forward motion }
                    SEQ.DUAL.current_block [ fn007.a.side ] := 0
                end if
            end if

            SEQ.DUAL.step_duration [ fn007.a.side ] := ...
                SEQ.rate [ fn007.a.side ] / ( SEQ.DUAL.step_count [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ] ] + 1 )

            // message(fn007.a.side & "| Block: " & SEQ.DUAL.current_block [ fn007.a.side ] & " | ET: " & ENGINE_UPTIME)
            for s.i := 0 to SEQ.DUAL.step_count [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ] ]
                SEQ.DUAL.steps_timestamps [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ], s.i ] := ...
                    ENGINE_UPTIME + s.i * SEQ.DUAL.step_duration [ fn007.a.side ]
                // message("    Step " & s.i & " ts: " &  SEQ.DUAL.steps_timestamps [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ], s.i ])
            end for

        else
            if  seq.direction_status [ fn007.a.side ] = SEQ_DIRECTION_BACKWARD 
                dec(SEQ.DUAL.current_block [ fn007.a.side ])
                if SEQ.DUAL.current_block [ fn007.a.side ] < 0
                    if layers.seq_play_direction [ fn007.a.side ] = SEQ_DIRECTION_FWBW
                        SEQ.DUAL.current_block [ fn007.a.side ] := 0
                        seq.direction_status [ fn007.a.side ] := SEQ_DIRECTION_FORWARD
                    else { regular backward motion }
                        SEQ.DUAL.current_block [ fn007.a.side ] := 3 
                    end if
                end if

                SEQ.DUAL.step_duration [ fn007.a.side ] := ...
                    SEQ.rate [ fn007.a.side ] / ( SEQ.DUAL.step_count [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ] ] + 1 )

                // message(fn007.a.side & "| Block: " & SEQ.DUAL.current_block [ fn007.a.side ] & " | ET: " & ENGINE_UPTIME)
                for s.i := 0 to SEQ.DUAL.step_count [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ] ]
                    SEQ.DUAL.steps_timestamps [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ], s.i ] := ...
                        ENGINE_UPTIME + s.i * SEQ.DUAL.step_duration [ fn007.a.side ]
                    // message("    Step " & s.i & " ts: " &  SEQ.DUAL.steps_timestamps [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ], s.i ])
                end for
            end if

        end if

    else { JOIN sequencer }

        inc(SEQ.JOIN.current_block )
        if SEQ.JOIN.current_block  > 7
            SEQ.JOIN.current_block  := 0
        end if

        SEQ.JOIN.step_duration := ...
            SEQ.rate [ __LEFT ] / ( SEQ.JOIN.step_count [ SEQ.JOIN.current_block ] + 1 )

        for s.i := 0 to SEQ.JOIN.step_count [ SEQ.JOIN.current_block ]
            SEQ.JOIN.steps_timestamps [ SEQ.JOIN.current_block, s.i ] := ...
                ENGINE_UPTIME + s.i * SEQ.JOIN.step_duration
        end for

    end if 
end function

function PLAY_NOTE_NCB
    layers.note_events [ pn_ncb.a.side,  pn_ncb.a.note ] := play_note(pn_ncb.a.note, pn_ncb.a.velo, -1, -1)
    set_event_par_arr(layers.note_events [ pn_ncb.a.side, pn_ncb.a.note ], EVENT_PAR_ALLOW_GROUP, __OFF, ALL_GROUPS)
    { PENDING: group as side here is just for testing}
    set_event_par_arr(layers.note_events [ pn_ncb.a.side, pn_ncb.a.note ], EVENT_PAR_ALLOW_GROUP, __ON,  pn_ncb.a.side)
end function

function PLAY_LCB
    select(seq.direction_status [ p_lcb.a.side ])
        case SEQ_DIRECTION_FORWARD  
            p_lcb.l.ts_counter := SEQ.ts_counter

        case SEQ_DIRECTION_BACKWARD 
            if  switch_MAIN.SEQ.combine = __SEQ_DUAL
                { inverts the steps }
                p_lcb.l.ts_counter := ...
                    SEQ.DUAL.step_count [ p_lcb.a.side, SEQ.DUAL.current_block [ p_lcb.a.side ] ] - SEQ.ts_counter
            end if
    end select

    if  switch_MAIN.SEQ.combine = __SEQ_DUAL and ...
        SEQ.DUAL.steps_timestamps [ p_lcb.a.side, SEQ.DUAL.current_block [ p_lcb.a.side ], p_lcb.l.ts_counter ] = ENGINE_UPTIME
        message(lcb_play_side & " | play LCB -----> step : " & SEQ.ts_counter & ...
                                    " | block: " & SEQ.DUAL.current_block [ lcb_play_side ] & " play dir: " & layers.seq_play_direction [ lcb_play_side ])
        message("    PLAY LCB: dir BACKW | step inv " & p_lcb.l.ts_counter)
        message("    SEQ.DUAL.step_count: " & SEQ.DUAL.step_count [ p_lcb.a.side, SEQ.DUAL.current_block [ p_lcb.a.side ] ])
        message("    step counter: " & SEQ.ts_counter)
        { update step leds - has to be here, at the timestamp of each step }
        for lcb_block_counter := 0 to 3
            if lcb_block_counter = SEQ.DUAL.current_block [ lcb_play_side ]
                UIID_MAIN.seq.step_leds [                    ...
                    lcb_play_side,                           ...
                    SEQ.DUAL.current_block [ lcb_play_side ] ...
                ] -> picture_state := SEQ.ts_counter + 1
            else
                UIID_MAIN.seq.step_leds [                    ...
                    lcb_play_side,                           ...
                    lcb_block_counter                        ...
                ] -> picture_state := 0
            end if
        end for

        { play }
        if switch_MAIN.FLUXX.LEFT.arp.power = __OFF
            for SEQ.key_count := 0 to 127
                if KEY_DOWN[ SEQ.key_count ] = 1
                    // message(SEQ.key_count & " <-- key pressed")
                    { first kill the note we are about to play (in case it is still there from NCB or something else )}
                    if layers.note_events [ p_lcb.a.side, SEQ.key_count ] > 0
                        fade_out( layers.note_events [ p_lcb.a.side, SEQ.key_count ], 2000, 1)
                    end if

                    fn017.a.side             := p_lcb.a.side
                    fn017.a.key_note         := SEQ.key_count
                    fn017.a.step_counter     := SEQ.ts_counter
                    fn017.a.block_step_index := SEQ.DUAL.current_block [ fn017.a.side ]
                    call fn017_get_seq_target_data
                    { return values from fn017_get_seq_target_data() }
                    SEQ.step_velocity  := fn017.r.velocity
                    SEQ.step_pitch     := fn017.r.pitch * 100000
                    SEQ.step_octave    := fn017.r.octave
                    SEQ.step_pan       := fn017.r.pan
                    SEQ.step_filter    := fn017.r.filter_value
                    SEQ.step_lp_filter := fn017.r.lp_filter_value
                    SEQ.step_hp_filter := fn017.r.hp_filter_value

                    { 
                        PENDING
                        Adjust the behavior to:
                        Read from the sequencer data, but don't change it
                        only read, apply the flux randomizer and use these modifyed values
                        to play the step, but always come back to the original values set in the sequencer
                        data structure.
                        beak fn022 apart into different independent functions
                    }

                    if  UIID_MAIN.seq.flux_rand_btns  [ p_lcb.a.side, SEQ.DUAL.current_block [ p_lcb.a.side ] ] -> value = __ON and ...
                        UIID_MAIN.seq.flux_rand_power [ p_lcb.a.side ] -> value = __ON

                        {{ FLUX RAND VELOCITY }}
                        // if  fn017.a.step_counter = 0 { in case you want to do the randomization per block, not per step }
                        { would still need the logic to populate all steps }

                        if UIID_MAIN.seq.target_power [ p_lcb.a.side, SEQ_TARGET_VELO ] -> value = __ON
                            { first get the seed based on the flux randomizer intensity amount }
                            SEQ.flux_velo_seed := int(127.0 * ...
                                (float(SEQ.flux_rand_intensity [ p_lcb.a.side, SEQ_TARGET_VELO ] )/100.0) )
                            { generate the actual flux offset value }
                            SEQ.flux_velo      := random( -1 * SEQ.flux_velo_seed, SEQ.flux_velo_seed)
                            { add to the base value }
                            SEQ.step_velocity := SEQ.step_velocity + SEQ.flux_velo
                            { clam if needed }
                            if SEQ.step_velocity > 127
                                SEQ.step_velocity := 127
                            end if
                            if SEQ.step_velocity < 1
                                SEQ.step_velocity := 1
                            end if
                        end if

                        {{ FLUX RAND PITCH }}
                        if UIID_MAIN.seq.target_power [ p_lcb.a.side, SEQ_TARGET_PITCH ] -> value = __ON
                            { flux rand intensity is 0:100, }
                            SEQ.flux_pitch_seed := int(12.0 * ...
                                (float(SEQ.flux_rand_intensity [ p_lcb.a.side, SEQ_TARGET_PITCH ] )))
                            SEQ.flux_pitch      := random( -1000 * SEQ.flux_pitch_seed, SEQ.flux_pitch_seed * 1000)
                            SEQ.step_pitch := SEQ.step_pitch + SEQ.flux_pitch
                            if SEQ.step_pitch > 1200000
                                SEQ.step_pitch := 1200000
                            end if
                            if SEQ.step_pitch < -1200000
                                SEQ.step_pitch := -1200000
                            end if
                        end if

                        {{ FLUX RAND OCTAVE }}
                        if UIID_MAIN.seq.target_power [ p_lcb.a.side, SEQ_TARGET_OCTAVE ] -> value = __ON
                            SEQ.flux_octave_seed := int(2.0 * ...
                                (float(SEQ.flux_rand_intensity [ p_lcb.a.side, SEQ_TARGET_OCTAVE ] )/100.0) )
                            SEQ.flux_octave      := random( -1 * SEQ.flux_octave_seed, SEQ.flux_octave_seed)
                            SEQ.step_octave := SEQ.step_octave + SEQ.flux_octave
                            if SEQ.step_octave > 2
                                SEQ.step_octave := 2
                            end if
                            if SEQ.step_octave < -2
                                SEQ.step_octave := -2
                            end if
                        end if
                        
                        {{ FLUX RAND PAN }}
                        if UIID_MAIN.seq.target_power [ p_lcb.a.side, SEQ_TARGET_PAN ] -> value = __ON
                            SEQ.flux_pan_seed := int(1000.0 * ...
                                (float(SEQ.flux_rand_intensity [ p_lcb.a.side, SEQ_TARGET_PAN ] )/100.0) )
                            SEQ.flux_pan      := random( -1 * SEQ.flux_pan_seed, SEQ.flux_pan_seed)
                            SEQ.step_pan := SEQ.step_pan + SEQ.flux_pan
                            if SEQ.step_pan > 1000
                                SEQ.step_pan := 1000
                            end if
                            if SEQ.step_pan < -1000
                                SEQ.step_pan := -1000
                            end if
                        end if

                        {{ FLUX RAND PAN }}
                        if UIID_MAIN.seq.target_power [ p_lcb.a.side, SEQ_TARGET_FILTER ] -> value = __ON
                            { not scaling by /100 because the extreme values of the filter just completely close the sound
                            so scaling by 150 instead of 100 }
                            // message("REPORT ________________")
                            // message("SEQ.step_filter: " & SEQ.step_filter)
                            SEQ.flux_filter_seed := int(1000000.0 * ...
                                (float(SEQ.flux_rand_intensity [ p_lcb.a.side, SEQ_TARGET_FILTER ] )/150.0) )
                            SEQ.flux_filter      := random( -1 * SEQ.flux_filter_seed, SEQ.flux_filter_seed)
                            SEQ.step_filter := SEQ.step_filter + SEQ.flux_filter
                            // message("SEQ.flux_filter: " & SEQ.flux_filter)
                            if SEQ.step_filter > 850000
                                SEQ.step_filter := 850000
                            end if
                            if SEQ.step_filter < 150000
                                SEQ.step_filter := 150000
                            end if
                            // message("SEQ.step_filter: " & SEQ.step_filter)
                            if SEQ.step_filter > 500000 { high pass }
                                SEQ.step_lp_filter := 1000000
                                SEQ.step_hp_filter := ( SEQ.step_filter - 500000 ) * 2
                            else                        { low pass }
                                SEQ.step_lp_filter := SEQ.step_filter * 2
                                SEQ.step_hp_filter := 0
                            end if
                            // message("SEQ.step_lp_filter: " & SEQ.step_lp_filter)
                            // message("SEQ.step_hp_filter: " & SEQ.step_hp_filter)
                        end if

                        if UIID_MAIN.seq.target_power [ p_lcb.a.side, SEQ.showing_target [ p_lcb.a.side ] ] -> value = __ON
                            { update the step picture only }
                            select(SEQ.showing_target [ p_lcb.a.side ])
                                case SEQ_TARGET_VELO
                                    fn018.a.value      := float(SEQ.step_velocity)/127.0
                                case SEQ_TARGET_PITCH
                                    fn018.a.value      := float(SEQ.step_pitch + 1200000)/2400000.0
                                case SEQ_TARGET_OCTAVE
                                    fn018.a.value      := float(SEQ.step_octave + 2)/4.0
                                case SEQ_TARGET_PAN
                                    fn018.a.value      := float(SEQ.step_pan + 1000)/2000.0
                                case SEQ_TARGET_FILTER
                                    fn018.a.value      := float(SEQ.step_filter)/850000.0
                            end select
                            
                            fn018.a.side       := p_lcb.a.side
                            fn018.a.step_index := fn017.a.step_counter + SEQ.DUAL.current_block [ p_lcb.a.side ] * 8
                            call fn018_set_seq_step_picture_state
                        end if

                    end if


                    if SEQ.step_velocity > 1
                        layers.note_events [ p_lcb.a.side, SEQ.key_count ] := ...
                            play_note(                      ...
                                SEQ.key_count,              ...
                                SEQ.step_velocity,          ...
                                -1,                         ...
                                SEQ.DUAL.step_duration [ p_lcb.a.side ] * 500     ...
                            )                               ...

                        set_event_par_arr(layers.note_events [ p_lcb.a.side, SEQ.key_count ], EVENT_PAR_ALLOW_GROUP, __OFF, ALL_GROUPS)
                        { PENDING: group here is just for testing example -> side }
                        set_event_par_arr(layers.note_events [ p_lcb.a.side, SEQ.key_count ], EVENT_PAR_ALLOW_GROUP, __ON,  p_lcb.a.side)

                        { adjust event according to seq modulations }
                        change_tune( ...
                            layers.note_events [ p_lcb.a.side, SEQ.key_count ], ...
                            SEQ.step_pitch + SEQ.step_octave * 1200000, 0)

                        change_pan( ...
                            layers.note_events [ p_lcb.a.side, SEQ.key_count ], ...
                            SEQ.step_pan, 0 )

                        { filter seq setting }
                        if fn017.r.filter_status = __ON
                            set_engine_par(ENGINE_PAR_CUTOFF, SEQ.step_lp_filter, __NO_GROUP, __LP_FILTER_SLOT, NI_BUS_OFFSET+p_lcb.a.side)
                            set_engine_par(ENGINE_PAR_CUTOFF, SEQ.step_hp_filter, __NO_GROUP, __HP_FILTER_SLOT, NI_BUS_OFFSET+p_lcb.a.side)
                        else
                            set_engine_par(ENGINE_PAR_CUTOFF, 1000000, __NO_GROUP, __LP_FILTER_SLOT, NI_BUS_OFFSET+p_lcb.a.side)
                            set_engine_par(ENGINE_PAR_CUTOFF,       0, __NO_GROUP, __HP_FILTER_SLOT, NI_BUS_OFFSET+p_lcb.a.side)
                        end if

                    end if
                end if
            end for

        else { Arpeggiated notes here }

        end if
    end if

    if  switch_MAIN.SEQ.combine = __SEQ_JOIN and ...
        SEQ.JOIN.steps_timestamps [ SEQ.JOIN.current_block, SEQ.ts_counter ] = ENGINE_UPTIME

        if switch_MAIN.FLUXX.LEFT.arp.power = __OFF
            for SEQ.key_count := 0 to 127
                if KEY_DOWN[ SEQ.key_count ] = 1
                    { first kill the note we are about to play (in case it is still there from NCB or something else )}
                    if layers.note_events [ p_lcb.a.side, SEQ.key_count ] > 0
                        fade_out( layers.note_events [ p_lcb.a.side, SEQ.key_count ], 2000, 1)
                    end if
                    if layers.note_events [ __RIGHT, SEQ.key_count ] > 0
                        fade_out( layers.note_events [ p_lcb.a.side, SEQ.key_count ], 2000, 1)
                    end if

                    { get the step velocity from either the left or right side, even if it is combined }
                    { here we are only reading the steps, so the distinction of Left and right still applies }
                    if SEQ.JOIN.current_block < 4 { left side }
                        SEQ.step_velocity := (126 *                         ...
                            SEQ.data.i [                                    ...
                                __LEFT,                                     ...
                                SEQ_TARGET_VELO,                            ...
                                SEQ.ts_counter + (SEQ.JOIN.current_block mod 4) * 8 ...
                            ] ) / 1000000 + 1
                    else                          { rightt side }
                        SEQ.step_velocity := (126 *                         ...
                            SEQ.data.i [                                    ...
                                __RIGHT,                                     ...
                                SEQ_TARGET_VELO,                            ...
                                SEQ.ts_counter + (SEQ.JOIN.current_block mod 4) * 8 ...
                            ] ) / 1000000 + 1
                    end if

                    if SEQ.step_velocity > 1
                        { left layer }
                        layers.note_events [ p_lcb.a.side, SEQ.key_count ] := ...
                            play_note(                       ...
                                SEQ.key_count,               ...
                                SEQ.step_velocity,           ...
                                -1,                          ...
                                SEQ.JOIN.step_duration * 500 ...
                            )                                ...

                        set_event_par_arr(layers.note_events [ p_lcb.a.side, SEQ.key_count ], EVENT_PAR_ALLOW_GROUP, __OFF, ALL_GROUPS)
                        { PENDING: group here is just for testing example -> side }
                        set_event_par_arr(layers.note_events [ p_lcb.a.side, SEQ.key_count ], EVENT_PAR_ALLOW_GROUP, __ON,  p_lcb.a.side)
                    end if

                end if
            end for
        else { Arpeggiated notes here }

        end if
    end if
end function











