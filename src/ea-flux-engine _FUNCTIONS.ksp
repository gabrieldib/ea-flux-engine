import "ARP/__ARP 03 functions.ksp"

function fn056_single_shot_wf_preview
    pn_ncb.a.side      := fn056.a.side
    pn_ncb.a.note      := 60
    pn_ncb.a.velo      := 1
    pn_ncb.a.mute_note := __YES
    call PLAY_NOTE_NCB
    fn053.a.side := fn056.a.side
    fn053.a.note := 60
    call fn053_update_single_shot_controls
end function

{{ PCCB Init Instrument }}
function pccb_init_instrument
    { dual or joined sequencer }
    call draw_seq

    SEQ.showing_target [ __LEFT  ] := SEQ_TARGET_VELO
    SEQ.showing_target [ __RIGHT ] := SEQ_TARGET_VELO

    panel_MAIN.2JOIN.arpModes -> UI_HIDE

    { recall block steps numbers and steps pictures }
    fn003.a.mode := switch_MAIN.SEQ.combine
    for pccb_counter := 0 to 3
        fn003.a.block_index := pccb_counter
        fn003.a.side := __LEFT
        call fn003_set_block_step_count
        fn003.a.side := __RIGHT
        call fn003_set_block_step_count
    end for

    { recall picture states for steps labels }
    fn006.a.side := __LEFT
    call fn006_recall_seq_values
    fn006.a.side := __RIGHT
    call fn006_recall_seq_values

    { target selectors and activators }
    fn005.a.selector_index := SEQ_TARGET_VELO
    call fn005_set_seq_target_selector

    fn011.a.side  := __LEFT
    fn011.a.index := SEQ_TARGET_VELO
    call fn011_clear_target_activators
    fn011.a.side  := __RIGHT
    fn011.a.index := SEQ_TARGET_VELO
    call fn011_clear_target_activators

    { dyn sliders }
    fn031.a.reset := __OFF
    fn031.a.side := __LEFT
    call fn031_set_dyn_sliders_picture
    fn031.a.side := __RIGHT
    call fn031_set_dyn_sliders_picture

    for i.i := __LEFT to __RIGHT
        fn035.a.value := ...
            get_control_par_real_arr(       ...
                UIID_random.xypads [ i.i ], ...
                CONTROL_PAR_VALUE,          ...
                __Y_AXIS                    ...
            )
        fn035.a.side := i.i
        call fn035_update_random_labels

        fn042.a.side  := i.i
        fn042.a.panel := __LAYER
        call fn042_update_fx_panel_selector_btns

        fn043.a.side  := i.i
        fn043.a.panel := __LAYER
        call fn043_show_hide_fx_panels

        UIID_lfp_delay_labels [ i.i, __FX_DELAY_LABEL_PINGPONG ] -> font_type := ...
            FX_switches_fonts [ UIID_lfp_delay_controls [ i.i, __FX_DELAY_LABEL_PINGPONG ] -> value ] { ping pong }
        UIID_lfp_delay_labels [ i.i, __FX_DELAY_LABEL_SYNC     ] -> font_type := ...
            FX_switches_fonts [ UIID_lfp_delay_controls [ i.i, __FX_DELAY_LABEL_SYNC ] -> value ] { sync }

        { set filters bypass state }
        fn060.a.seq_power_state := UIID_MAIN.seq.power [ i.i ] -> value
        fn060.a.side            := i.i
        call fn060_set_filters_bypas_state

        for l.i := __MAIN.FX.SATURATION to __MAIN.FX.DISTORTION.DRIVE
            LFO_targets_GROUP [ i.i, l.i ] := selected_source [ i.i ]
        end for

        UIID_MAIN.show_rates [ i.i ] -> picture_state := (UIID_MAIN.SEQ.rate_sliders [ i.i ] -> value) / __BEAT_RATE_DIVISOR
    end for

    { change text alignment on target selectors according to SEQ DUAL/JOIN state }
    call set_seq_target_selectors_text_alignment

    label_MAIN.LFO.sync -> text := rate_mode_sync_hz.text [ switch_MAIN.LFO.sync ]
    label_MAIN.LFO.depth -> text := slider_MAIN.LFO.depth / 10000 & "%"
    
    call update_lfo_aux_data
    call update_lfo_viz
    call update_lfo_viz_picture

    if switch_MAIN.LFO.lock = __OFF
        call fn047_update_all_lfo_controls_data_and_ui
    else
        fn046.a.caller       := __LFO_GLOBAL_DEPTH
        fn046.a.target_value := slider_MAIN.LFO.depth
        call fn046_set_lfo_depth_globally
    end if

    for pccb_counter := __LEFT to __RIGHT
        fn051.a.side := pccb_counter
        call fn051_set_layer_panels_state

        if pccb_counter = __LEFT or pccb_counter = __RIGHT and switch_MAIN.SEQ.combine = __SEQ_DUAL
            fn020.a.seq_power_state    := UIID_MAIN.seq.power [ pccb_counter ] -> value
            fn020.a.target_power_uiid  := UIID_MAIN.seq.target_power [ pccb_counter, SEQ_TARGET_VELO ]
            fn020.a.side               := pccb_counter
            fn020.a.target_index       := SEQ_TARGET_VELO
            call fn020_update_seq_target_state
        end if

        if switch_MAIN.SEQ.combine = __SEQ_DUAL
            fn052.a.side       := pccb_counter
            fn052.a.value      := float(UIID_MAIN.single_shot_controls [ pccb_counter, __SINGLE_SHOT_SAMPLE_START ] -> value)*0.000001
            if fn052.a.value > 0.995
                fn052.a.value := 0.995
            end if
            call fn052_set_wf_cursor_and_overlay

            if UIID_MAIN.seq.power [ pccb_counter ] -> value = __OFF
                fn056.a.side := pccb_counter
                call fn056_single_shot_wf_preview

                UIID_MAIN.seq.target_activators [ pccb_counter, SEQ_TARGET_VELO ] -> value := __OFF
                UIID_MAIN.seq.target_power      [ pccb_counter, SEQ_TARGET_VELO ] -> value := __OFF
                UIID_MAIN.seq.target_selectors  [ pccb_counter ] -> value := __OFF
            end if
        end if

    end for

    UIID_MAIN.seq.arp_menu [ __LEFT  ] -> text := arp_menu_items_text [ arp_mode [ __LEFT ] ]
    UIID_MAIN.seq.arp_menu [ __RIGHT ] -> text := arp_menu_items_text [ arp_mode [ __RIGHT ] ]
    switch_MAIN.ARP.LEFT.modeMenu      -> text := arp_menu_items_text [ arp_mode [ __LEFT ] ]
    label_SEQjoin.arp.rate             -> text := beat_rates_display [ slider_MAIN.ARPjoin.amount / __BEAT_RATE_DIVISOR ]
    
    if switch_MAIN.LFO.power = __OFF
        label_MAIN.matrix.center.mod.LR -> UI_HIDE
        label_MAIN.matrix.center.mod.RL -> UI_HIDE
    else
        label_MAIN.matrix.center.mod.LR -> UI_SHOW
        label_MAIN.matrix.center.mod.RL -> UI_SHOW
    end if

    label_MAIN.matrix.centerLR   -> picture_state := 255 - int(255.0 * float(slider_MAIN.FX.LEFT.layer.volume)*0.000001)
    label_MAIN.matrix.centerRL   -> picture_state := int(255.0 * float(slider_MAIN.FX.RIGHT.layer.volume)*0.000001)
    label_MAIN.matrix.left       -> picture_state := slider_MAIN.FX.LEFT.layer.volume / 3921
    label_MAIN.matrix.right      -> picture_state := slider_MAIN.FX.RIGHT.layer.volume / 3921

    source_page [ __LEFT ] := selected_source [ __LEFT ] / __MAX_SOURCES_PER_PAGE
    source_page [ __RIGHT ] := selected_source [ __RIGHT ] / __MAX_SOURCES_PER_PAGE
    // call fn055_recall_source_buttons_page
end function

{{ general }}
function convolution_predelay_label() 
    ~conv_label_val := real(get_control_par(conv_predelay_uiid, $CONTROL_PAR_VALUE)) * 0.000001 { normalize to 0.0 ... 1.0 } 
    ~conv_label_val := (~conv_label_val * ~CONV_LABEL_RANGE) + ~CONV_LABEL_MIN_COEF { linear interpolation between CONV_LABEL_MIN_COEF and CONV_LABEL_MAX_COEF } 
    ~conv_label_val := pow(~NI_MATH_E, ~CONV_LABEL_VAL) - ~CONV_LABEL_OFFSET       { e^x - CONV_LABEL_OFFSET } 
    $conv_label_res := int(round(~conv_label_val * 100.0))                        { convert to integer with two "decimals" } 
   {  take care of value display (optional, can always just print with one less decimal of precision, then it"s simpler) } 
    if ($conv_label_res < 10) 
        @conv_label := $conv_label_res / 100 & ".0" & $conv_label_res mod 100 & " ms"
    else 
        if ($conv_label_res < 100) 
            @conv_label := $conv_label_res / 100 & "." & $conv_label_res mod 100 & " ms"
        else 
            @conv_label := $conv_label_res / 100 & "." & ($conv_label_res / 10) mod 10 & " ms"
        end if 
    end if 
end function

function convolution_filters_label()
    conv_label_val := int_to_real(get_control_par(conv_freq_uiid, $CONTROL_PAR_VALUE)) * 0.000001        { normalize to 0.0 ... 1.0 }
    conv_label_val := (conv_label_val * ~CONV_LABEL_EQ_RANGE) + ~CONV_LABEL_MIN_EQ_COEF    { linear interpolation between ~MIN_EQ_COEF and ~MAX_EQ_COEF }
    conv_label_val := pow(~NI_MATH_E, conv_label_val)                { e^x }
    $conv_label_res := real_to_int(round(conv_label_val * 10.0))      { convert to integer with one "decimal" }
    { take care of value display }
    if ($conv_label_res < 10000)
        @conv_label := $conv_label_res / 10 & "." & $conv_label_res mod 10
    else
        { add 500 to $conv_label_res for rounding purposes - matches close to how the value is displayed in Kontakt }
        @conv_label := $conv_label_res / 10000 & "." & (($conv_label_res + 500) / 1000) mod 10 & "k"
    end if
end function


{{ MAIN }}
function update_lfo_viz
    label_MAIN.LFO.visualRate  -> picture_state := ...
        (slider_MAIN.LFO.depth/31250) * 64 + int(float(slider_MAIN.LFO.rate)/2.539682)

    // label_MAIN.LFO.visualDepth  -> picture_state := ...
    //     (slider_MAIN.LFO.depth/31250) * 64 + (slider_MAIN.LFO.rate/15873)
end function

function update_lfo_viz_picture
    select(LFO_data[LFO_WAVESHAPE])
        case LFO_WAVESHAPE_TRI
            label_MAIN.LFO.visualRate  -> picture := "label_LFO.tri_2112"
            // label_MAIN.LFO.visualDepth -> picture := "label_LFO.tri_2112"

        case LFO_WAVESHAPE_SIN
            label_MAIN.LFO.visualRate  -> picture := "label_LFO.sine_2112"
            // label_MAIN.LFO.visualDepth -> picture := "label_LFO.sine_2112"

        case LFO_WAVESHAPE_SAW
            label_MAIN.LFO.visualRate  -> picture := "label_LFO.saw_2112"
            // label_MAIN.LFO.visualDepth -> picture := "label_LFO.saw_2112"

        case LFO_WAVESHAPE_SQR
            label_MAIN.LFO.visualRate  -> picture := "label_LFO.square_2112"
            // label_MAIN.LFO.visualDepth -> picture := "label_LFO.square_2112"

        case LFO_WAVESHAPE_RND
            label_MAIN.LFO.visualRate  -> picture := "label_LFO.rand_2112"
            // label_MAIN.LFO.visualDepth -> picture := "label_LFO.rand_2112"

    end select
end function

macro step_debug(#wait#, #ms#, #var#)
    message("BEFORE " & #ms# & " " & #var#)
    wait(#wait#)
    message("AFTER " & #ms# & " " & #var#)
    message(f'______________________')
end macro

function show_hide_according_to_combine_state
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        switch_MAIN.SEQ.RIGHT.link                 -> UI_SHOW
        valueedit_MAIN.RIGHT.low.range             -> UI_SHOW
        valueedit_MAIN.RIGHT.high.range            -> UI_SHOW
        slider_MAIN.RIGHT.move.range               -> UI_SHOW
        switch_MAIN.SEQ.RIGHT.randomize            -> UI_SHOW
        switch_MAIN.SEQ.RIGHT.power                -> UI_SHOW
        button_MAIN.RIGHT.controls.draw            -> UI_SHOW
        switch_MAIN.SEQ.LEFT.link                  -> UI_SHOW
        switch_MAIN.SEQ.RIGHT.mode.forwards        -> UI_SHOW
        switch_MAIN.SEQ.RIGHT.mode.backwards       -> UI_SHOW
        switch_MAIN.SEQ.RIGHT.fwbw                 -> UI_SHOW
        label_MAIN.LEFT.layer.controls.separators  -> UI_SHOW
        label_MAIN.RIGHT.layer.controls.separators -> UI_SHOW
        xypad_MAIN.RIGHT.dynamics                  -> UI_SHOW
        label_MAIN.RIGHT.dynamics                  -> UI_SHOW
        label_MAIN.2SEQ.RIGHT.dyn                  -> UI_SHOW
        switch_MAIN.SEQ.RIGHT.select.velocity      -> UI_SHOW
        switch_MAIN.SEQ.RIGHT.select.pitch         -> UI_SHOW
        switch_MAIN.SEQ.RIGHT.select.octave        -> UI_SHOW
        switch_MAIN.SEQ.RIGHT.select.pan           -> UI_SHOW
        switch_MAIN.SEQ.RIGHT.select.lphp          -> UI_SHOW
        switch_MAIN.SEQ.RIGHT.power.velocity       -> UI_SHOW
        switch_MAIN.SEQ.RIGHT.power.pitch          -> UI_SHOW
        switch_MAIN.SEQ.RIGHT.power.octave         -> UI_SHOW
        switch_MAIN.SEQ.RIGHT.power.pan            -> UI_SHOW
        switch_MAIN.SEQ.RIGHT.power.lphp           -> UI_SHOW
        switch_MAIN.2SEQ.RIGHT.step.lock           -> UI_SHOW
        xypad_MAIN.SEQ.LEFT                        -> UI_SHOW
        xypad_MAIN.SEQ.RIGHT                       -> UI_SHOW
        switch_MAIN.SEQ.LEFT.power                 -> UI_SHOW


        label_MAIN.2SEQ.LEFT.fluxx.labels          -> UI_SHOW
        switch_MAIN.FLUXX.LEFT.block.1             -> UI_SHOW
        switch_MAIN.FLUXX.LEFT.block.2             -> UI_SHOW
        switch_MAIN.FLUXX.LEFT.block.3             -> UI_SHOW
        switch_MAIN.FLUXX.LEFT.block.4             -> UI_SHOW
        switch_MAIN.FLUXX.LEFT.randomPower         -> UI_SHOW
        switch_MAIN.FLUXX.LEFT.arp.power           -> UI_SHOW
        slider_MAIN.FLRND.LEFT.amount              -> UI_SHOW
        slider_MAIN.ARP.LEFT.rate                  -> UI_SHOW
        switch_MAIN.ARP.LEFT.modeMenu              -> UI_SHOW

        label_MAIN.2SEQ.RIGHT.fluxx.labels         -> UI_SHOW
        switch_MAIN.FLUXX.RIGHT.block.1            -> UI_SHOW
        switch_MAIN.FLUXX.RIGHT.block.2            -> UI_SHOW
        switch_MAIN.FLUXX.RIGHT.block.3            -> UI_SHOW
        switch_MAIN.FLUXX.RIGHT.block.4            -> UI_SHOW
        switch_MAIN.FLUXX.RIGHT.randomPower        -> UI_SHOW
        switch_MAIN.FLUXX.RIGHT.arp.power          -> UI_SHOW
        slider_MAIN.FLRND.RIGHT.amount             -> UI_SHOW
        slider_MAIN.ARP.RIGHT.rate                 -> UI_SHOW
        switch_MAIN.ARP.RIGHT.modeMenu             -> UI_SHOW

        label_MAIN.LEFT.hmz                        -> UI_SHOW
        slider_MAIN.LEFT.hmz                       -> UI_SHOW 
        slider_MAIN.RIGHT.hmz                      -> UI_SHOW  
        label_MAIN.RIGHT.hmz                       -> UI_SHOW 
        switch_MAIN.LEFT.HMZ.link                  -> UI_SHOW      
        switch_MAIN.RIGHT.HMZ.link                 -> UI_SHOW       


        panel_MAIN.2SEQ.LEFT.arpModes              -> UI_HIDE
        panel_MAIN.2SEQ.RIGHT.arpModes             -> UI_HIDE


        { join seq controls }
        label_MAIN.join.layer.controls.separators  -> UI_HIDE
        label_SEQjoin.fluxxRand.amount             -> UI_HIDE
        label_SEQjoin.arp.rate                     -> UI_HIDE
        slider_MAIN.FLRNDjoin.amount               -> UI_HIDE
        slider_MAIN.ARPjoin.amount                 -> UI_HIDE
        label_MAIN.join.layer.controls.separators  -> UI_HIDE
        xypad_MAIN.SEQ.join                        -> UI_HIDE
        label_MAIN.SEQjoin.off                     -> UI_HIDE
        panel_MAIN.2JOIN.arpModes                  -> UI_HIDE
        label_SEQjoin.arp.background               -> UI_HIDE
    else
        switch_MAIN.SEQ.RIGHT.link                 -> UI_HIDE
        valueedit_MAIN.RIGHT.low.range             -> UI_HIDE
        valueedit_MAIN.RIGHT.high.range            -> UI_HIDE
        slider_MAIN.RIGHT.move.range               -> UI_HIDE
        switch_MAIN.SEQ.RIGHT.randomize            -> UI_HIDE
        switch_MAIN.SEQ.RIGHT.power                -> UI_HIDE
        button_MAIN.RIGHT.controls.draw            -> UI_HIDE
        switch_MAIN.SEQ.LEFT.link                  -> UI_HIDE
        switch_MAIN.SEQ.RIGHT.mode.forwards        -> UI_HIDE
        switch_MAIN.SEQ.RIGHT.mode.backwards       -> UI_HIDE
        switch_MAIN.SEQ.RIGHT.fwbw                 -> UI_HIDE
        label_MAIN.LEFT.layer.controls.separators  -> UI_HIDE
        label_MAIN.RIGHT.layer.controls.separators -> UI_HIDE
        xypad_MAIN.RIGHT.dynamics                  -> UI_HIDE
        label_MAIN.RIGHT.dynamics                  -> UI_HIDE
        label_MAIN.2SEQ.RIGHT.dyn                  -> UI_HIDE
        switch_MAIN.SEQ.RIGHT.select.velocity      -> UI_HIDE
        switch_MAIN.SEQ.RIGHT.select.pitch         -> UI_HIDE
        switch_MAIN.SEQ.RIGHT.select.octave        -> UI_HIDE
        switch_MAIN.SEQ.RIGHT.select.pan           -> UI_HIDE
        switch_MAIN.SEQ.RIGHT.select.lphp          -> UI_HIDE
        switch_MAIN.SEQ.RIGHT.power.velocity       -> UI_HIDE
        switch_MAIN.SEQ.RIGHT.power.pitch          -> UI_HIDE
        switch_MAIN.SEQ.RIGHT.power.octave         -> UI_HIDE
        switch_MAIN.SEQ.RIGHT.power.pan            -> UI_HIDE
        switch_MAIN.SEQ.RIGHT.power.lphp           -> UI_HIDE
        switch_MAIN.2SEQ.RIGHT.step.lock           -> UI_HIDE
        xypad_MAIN.SEQ.LEFT                        -> UI_HIDE
        xypad_MAIN.SEQ.RIGHT                       -> UI_HIDE
        switch_MAIN.SEQ.LEFT.power                 -> UI_HIDE

        switch_MAIN.FLUXX.LEFT.block.1             -> UI_SHOW
        switch_MAIN.FLUXX.LEFT.block.2             -> UI_SHOW
        switch_MAIN.FLUXX.LEFT.block.3             -> UI_SHOW
        switch_MAIN.FLUXX.LEFT.block.4             -> UI_SHOW
        switch_MAIN.FLUXX.LEFT.randomPower         -> UI_SHOW
        switch_MAIN.FLUXX.LEFT.arp.power           -> UI_SHOW
        switch_MAIN.ARP.LEFT.modeMenu              -> UI_SHOW
        switch_MAIN.FLUXX.RIGHT.block.1            -> UI_SHOW
        switch_MAIN.FLUXX.RIGHT.block.2            -> UI_SHOW
        switch_MAIN.FLUXX.RIGHT.block.3            -> UI_SHOW
        switch_MAIN.FLUXX.RIGHT.block.4            -> UI_SHOW

        label_MAIN.2SEQ.LEFT.fluxx.labels          -> UI_HIDE
        slider_MAIN.FLRND.LEFT.amount              -> UI_HIDE
        slider_MAIN.ARP.LEFT.rate                  -> UI_HIDE
        label_MAIN.2SEQ.RIGHT.fluxx.labels         -> UI_HIDE
        switch_MAIN.FLUXX.RIGHT.randomPower        -> UI_HIDE
        switch_MAIN.FLUXX.RIGHT.arp.power          -> UI_HIDE
        slider_MAIN.FLRND.RIGHT.amount             -> UI_HIDE
        slider_MAIN.ARP.RIGHT.rate                 -> UI_HIDE
        switch_MAIN.ARP.RIGHT.modeMenu             -> UI_HIDE

        label_MAIN.LEFT.hmz                        -> UI_SHOW
        slider_MAIN.LEFT.hmz                       -> UI_SHOW 
        switch_MAIN.LEFT.HMZ.link                  -> UI_HIDE
        slider_MAIN.RIGHT.hmz                      -> UI_HIDE
        label_MAIN.RIGHT.hmz                       -> UI_HIDE
        switch_MAIN.RIGHT.HMZ.link                 -> UI_HIDE


        { join seq controls }
        label_MAIN.join.layer.controls.separators  -> UI_SHOW
        label_SEQjoin.fluxxRand.amount             -> UI_SHOW
        label_SEQjoin.arp.rate                     -> UI_SHOW
        slider_MAIN.FLRNDjoin.amount               -> UI_SHOW
        slider_MAIN.ARPjoin.amount                 -> UI_SHOW
        label_MAIN.join.layer.controls.separators  -> UI_SHOW
        xypad_MAIN.SEQ.join                        -> UI_SHOW
        label_MAIN.SEQjoin.off                     -> UI_SHOW

        label_SEQjoin.arp.background               -> UI_SHOW
    end if
    panel_MAIN.2SEQ.LEFT.fluxxArp  -> UI_SHOW
    panel_MAIN.2SEQ.RIGHT.fluxxArp -> UI_SHOW
end function

function draw_seq
    { SHOW / HIDE dual and joined seq panels }
    // panel_MAIN.2SEQ    -> hide := switch_MAIN.SEQ.combine * HIDE_WHOLE_CONTROL
    // panel_MAIN.SEQjoin -> hide := abs(1-switch_MAIN.SEQ.combine) * HIDE_WHOLE_CONTROL
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        message(f'DRAW: Showing Sequencer DUAL ')
    else
        message(f'DRAW: Showing Sequencer JOIN ')
    end if

    for ds.counter := 0 to SEQ.COMMON_ELEMENTS_COUNT-1
        { change ui_control parent }
        // SEQ.common_elements_data [ ds.counter, ELEMENT_UIID ] -> parent_panel := ...
        //     SEQ.common_elements_data [ ds.counter, switch_MAIN.SEQ.combine ]

        { update the coordinates }
        if switch_MAIN.SEQ.combine = __SEQ_DUAL
            SEQ.common_elements_data [ ds.counter, ELEMENT_UIID ] -> pos_x := ...
                SEQ.common_elements_data [ ds.counter, PANEL_DUAL_SEQ_X_COORD ]

            SEQ.common_elements_data [ ds.counter, ELEMENT_UIID ] -> pos_y := ...
                SEQ.common_elements_data [ ds.counter, PANEL_DUAL_SEQ_Y_COORD ]

            if in_range(ds.counter, __FLUX_BLOCK_RIGHT_START, __FLUX_BLOCK_RIGHT_START + 3)

                message(f'DUAL: updating picture to button_fluxx_block_<ds.counter - __FLUX_BLOCK_RIGHT_START + 1>')

                UIID_FLUX_RAND_RIGHT [ ds.counter - __FLUX_BLOCK_RIGHT_START ] -> picture := "button_fluxx_block_" & ds.counter - __FLUX_BLOCK_RIGHT_START + 1
            end if

        else                           { join seq }
            // message(f'DRAW SEQ: updating coordinates for element <ds.counter > | show status: <SEQ.common_elements_data [ ds.counter, ELEMENT_UIID ]-> hide>')
            // step_debug(100000, "counter", ds.counter)
            SEQ.common_elements_data [ ds.counter, ELEMENT_UIID ] -> pos_x := ...
                SEQ.common_elements_data [ ds.counter, PANEL_JOIN_SEQ_X_COORD ]

            SEQ.common_elements_data [ ds.counter, ELEMENT_UIID ] -> pos_y := ...
                SEQ.common_elements_data [ ds.counter, PANEL_JOIN_SEQ_Y_COORD ]

            if in_range(ds.counter, __FLUX_BLOCK_RIGHT_START, __FLUX_BLOCK_RIGHT_START + 3)
                message(f'JOIN: updating picture to button_fluxx_block_<ds.counter - __FLUX_BLOCK_RIGHT_START + 1>')
                UIID_FLUX_RAND_RIGHT [ ds.counter - __FLUX_BLOCK_RIGHT_START ] -> picture := "button_fluxx_block_" & ds.counter - __FLUX_BLOCK_RIGHT_START + 5
            end if
        end if
    end for

    // message("DUAL hide state: " & SEQ.common_elements_data [ 0, PANEL_DUAL_SEQ_PARENT_UIID ] -> hide)
    // message("JOIN hide state: " & SEQ.common_elements_data [ 0, PANEL_JOIN_SEQ_PARENT_UIID ] -> hide)
    message("switch_MAIN.SEQ.combine: " & switch_MAIN.SEQ.combine)"

    label_MAIN.2SEQ.background -> UI_HIDE
    label_SEQjoin.background   -> UI_HIDE
    message(f' label_MAIN.2SEQ.background z_layer: <label_MAIN.2SEQ.background-> z_layer >')
    message(f' label_SEQjoin.background z_layer: <label_SEQjoin.background-> z_layer >')
    message(f' panel_MAIN.SEQjoin state: <panel_MAIN.SEQjoin -> hide >')
    message(f' panel_MAIN.SEQjoin x: <panel_MAIN.SEQjoin -> x >')
    message(f' panel_MAIN.SEQjoin y: <panel_MAIN.SEQjoin -> y >')
    
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        label_MAIN.2SEQ.background -> UI_SHOW
        label_SEQjoin.background   -> UI_HIDE

    else
        label_MAIN.2SEQ.background -> UI_HIDE
        label_SEQjoin.background   -> UI_SHOW

        if UIID_MAIN.seq.power [ __LEFT ] -> value = __ON
            fn057.a.hide := __NO
        else
            fn057.a.hide := __NO
        end if
        call fn057_hide_seq_join_steps_leds_counters
    end if
    message(f'UIID_MAIN.seq.step [ __LEFT,  0 ] state:  <UIID_MAIN.seq.step [ __LEFT,  0 ] -> hide  >')

    call show_hide_according_to_combine_state

    message(f'panel_MAIN.2SEQ.LEFT.fluxxArp state: <panel_MAIN.2SEQ.LEFT.fluxxArp -> hide >')
end function

{{ LFO }}
function update_beat_rates
    beat_rates [ 00 ] := (DURATION_SIXTEENTH/8)/1000
    beat_rates [ 01 ] := (DURATION_SIXTEENTH_TRIPLET/2)/1000
    beat_rates [ 02 ] := (DURATION_SIXTEENTH/4)/1000
    beat_rates [ 03 ] := (DURATION_SIXTEENTH_TRIPLET/2)/1000
    beat_rates [ 04 ] := (DURATION_SIXTEENTH/2)/1000
    beat_rates [ 05 ] := (DURATION_SIXTEENTH_TRIPLET)/1000
    beat_rates [ 06 ] := (DURATION_SIXTEENTH)/1000
    beat_rates [ 07 ] := (DURATION_EIGHTH_TRIPLET)/1000
    beat_rates [ 08 ] := (3*DURATION_SIXTEENTH/2)/1000
    beat_rates [ 09 ] := (DURATION_EIGHTH)/1000
    beat_rates [ 10 ] := (DURATION_QUARTER_TRIPLET)/1000
    beat_rates [ 11 ] := (DURATION_SIXTEENTH* 3)/1000
    beat_rates [ 12 ] := (DURATION_QUARTER)/1000
    beat_rates [ 13 ] := (DURATION_QUARTER_TRIPLET * 2)/1000
    beat_rates [ 14 ] := (DURATION_EIGHTH * 3)/1000
    beat_rates [ 15 ] := (DURATION_QUARTER * 2)/1000
    beat_rates [ 16 ] := (DURATION_QUARTER * 3)/1000
    beat_rates [ 17 ] := (DURATION_QUARTER_TRIPLET * 4)/1000
    beat_rates [ 18 ] := (DURATION_QUARTER * 4)/1000
    beat_rates [ 19 ] := (DURATION_QUARTER * 8)/1000
    beat_rates [ 20 ] := (DURATION_QUARTER * 12)/1000
    beat_rates [ 21 ] := (DURATION_QUARTER * 16)/1000
end function

function update_lfo_rate
    if switch_MAIN.LFO.sync = __SYNC_BEAT
        LFO_rate := beat_rates [ int(float( slider_MAIN.LFO.rate) / __LFO_RATE_INDEX_DIVIDER) ]
        SEQ.rate [ __LEFT  ] := beat_rates [ (UIID_MAIN.SEQ.rate_sliders [ __LEFT  ] -> value) / __BEAT_RATE_DIVISOR ]
        SEQ.rate [ __RIGHT ] := beat_rates [ (UIID_MAIN.SEQ.rate_sliders [ __RIGHT ] -> value) / __BEAT_RATE_DIVISOR ]
    else
        if slider_MAIN.LFO.rate <= 100
            LFO_rate := int(1000.0 / (float(slider_MAIN.LFO.rate)/100.00))
        else
            LFO_rate := 1000 / (slider_MAIN.LFO.rate-100)
        end if
    end if
    
    message(f'>>LFO_rate <LFO_rate>')
end function

function LCB_data_update
    if __BPM # round((60000000.0 / float(DURATION_QUARTER)) * 100.0)/100.0
        __BPM := round((60000000.0 / float(DURATION_QUARTER)) * 100.0)/100.0
        message("BPM changed to " & __BPM)
        call update_beat_rates
        call update_lfo_rate
        lcb_ms_counter := 0
        SEQ.rate [ __LEFT  ] := beat_rates [ (UIID_MAIN.SEQ.rate_sliders [ __LEFT  ] -> value) / __BEAT_RATE_DIVISOR ]
        SEQ.rate [ __RIGHT ] := beat_rates [ (UIID_MAIN.SEQ.rate_sliders [ __RIGHT ] -> value) / __BEAT_RATE_DIVISOR ]
    end if 
end function

function fn006_recall_seq_values
    for fn006.l.counter_block := 0 to 3
        for fn006.l.counter_step := 0 to 7
            if  UIID_MAIN.seq.flux_rand_power [ fn006.a.side ] -> value = __ON and ...
                UIID_MAIN.seq.flux_rand_btns [ fn006.a.side, fn006.l.counter_block ] -> value = __ON

                UIID_MAIN.seq.step [ fn006.a.side, fn006.l.counter_block * 8 + fn006.l.counter_step ] -> picture_state := ...
                    int(                                                     ...
                        float(SEQ_XY_H-1) *                                  ...
                        SEQ.data.flux.f [                                    ...
                            fn006.a.side,                               ...
                            SEQ.showing_target [ fn006.a.side ],        ...
                            fn006.l.counter_block * 8 + fn006.l.counter_step ...
                        ]                                                    ...
                    )

            else
                UIID_MAIN.seq.step [ fn006.a.side, fn006.l.counter_block * 8 + fn006.l.counter_step ] -> picture_state := ...
                    int(                                                     ...
                        float(SEQ_XY_H-1) *                                  ...
                        SEQ.data.f [                                         ...
                            fn006.a.side,                               ...
                            SEQ.showing_target [ fn006.a.side ],        ...
                            fn006.l.counter_block * 8 + fn006.l.counter_step ...
                        ]                                                    ...
                    )
            end if
        end for 
    end for 


    // for i.i := 0 to 31
    //     UIID_MAIN.seq.step [ fn006.a.side, i.i ] -> picture_state := ...
    //         int(                                              ...
    //             float(SEQ_XY_H-1) *                           ...
    //             SEQ.data.f [                                  ...
    //                 fn006.a.side,                             ...
    //                 SEQ.showing_target [ fn006.l.mode_side ], ...
    //                 i.i                                       ...
    //             ]                                             ...
    //         )
    // end for
end function

function fn001_get_seq_step_index
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        fn001.l.xy_x := get_control_par_real_arr(   ...
            UIID_MAIN.SEQ.xypads [ fn001.a.side ], ...
            CONTROL_PAR_VALUE,                     ...
            __X_AXIS                               ...
        ) 

        fn001.l.xy_x.normalized := fn001.l.xy_x - 0.25 * float(fn001.a.block_index)

        fn001.r.step_index := int(( fn001.l.xy_x.normalized )/ SEQ.DUAL.step_width [ fn001.a.side, fn001.a.block_index ]) + ...
            8 * fn001.a.block_index

        if fn001.r.step_index = 32
            fn001.r.step_index := 31
        end if
    else
        fn001.l.xy_x := xypad_MAIN.SEQ.join [ __X_AXIS ]
        fn001.l.xy_x.normalized := fn001.l.xy_x - 0.125 * float(fn001.a.block_index)
        fn001.r.step_index := int(( fn001.l.xy_x.normalized )/ SEQ.JOIN.step_width [ fn001.a.block_index ]) + ...
            8 * fn001.a.block_index
        if fn001.r.step_index = 64
            fn001.r.step_index := 63
        end if
    end if
end function

{{ 18 }}
function fn018_set_seq_step_picture_state
    message(f'    ps = <int(float(SEQ_XY_H-1) * fn018.a.value)> | value <fn018.a.value>')
    UIID_MAIN.seq.step [ fn018.a.side, fn018.a.step_index ] -> picture_state := ...
        int(float(SEQ_XY_H-1) * fn018.a.value)
end function

function fn019_set_seq_step_value
    SEQ.data.i [           ...
        fn019.a.side,      ...
        fn019.a.target,    ...
        fn019.a.step_index ...
    ] := int( 1000000.0 * fn019.a.value )

    SEQ.data.f [           ...
        fn019.a.side,      ...
        fn019.a.target,    ...
        fn019.a.step_index ...
    ] := fn019.a.value
    // message(f'FN019: value set to <int( 1000000.0 * fn019.a.value )>')
end function

{{ 2 }}
function fn002_set_seq_step_value
    { storing the value changed
    by the user in the XY pad, into the SEQ.data.i/f }
    if  fn002.a.table_to_update .and. __SEQ_BOTH_TABLES = __SEQ_BOTH_TABLES or ...
        fn002.a.table_to_update .and. __SEQ_ORIGINAL_TABLE = __SEQ_ORIGINAL_TABLE

        fn019.a.side       := fn002.a.side
        fn019.a.step_index := fn002.a.step_index
        fn019.a.value      := fn002.a.value
        fn019.a.target     := fn002.a.target
        call fn019_set_seq_step_value
    end if
    { storing the value input transformed by the dyn slider }
    if  fn002.a.table_to_update .and. __SEQ_BOTH_TABLES = __SEQ_BOTH_TABLES or ...
        fn002.a.table_to_update .and. __SEQ_DYN_TRANSF_TABLE = __SEQ_DYN_TRANSF_TABLE

        fn030.a.side       := fn002.a.side
        fn030.a.step_index := fn002.a.step_index
        fn030.a.value      := fn002.a.value
        fn030.a.target     := fn002.a.target
        call fn030_set_seq_step_dyn_value
    end if

    message(f'FN02 setting value <fn002.a.value> | side: <fn002.a.side> | step: <fn002.a.step_index>')
end function

function fn013_update_seq_step_pictures
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        fn013.l.mode_side := fn013.a.side
    else
        fn013.l.mode_side := __LEFT
    end if
    for fn013.l.step := 0 to 7
        UIID_MAIN.seq.step [ fn013.a.side, fn013.l.step + (fn013.a.block_index mod 4 ) * 8 ] -> picture := ...
            SEQ_step_pictures [                                             ...
                SEQ.DUAL.step_count [ fn013.a.side, fn013.a.block_index mod 4 ] + ...
                SEQ.target_type [ SEQ.showing_target [ fn013.l.mode_side ] ] * 8 ...
            ]
    end for
end function

function fn003_set_block_step_count
    // message("FN003 block_index: " & fn003.a.block_index & " side: " & fn003.a.side)
    fn013.a.side        := fn003.a.side
    fn013.a.block_index := fn003.a.block_index
    call fn013_update_seq_step_pictures
    
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        // fn003.l.block_index_mod := fn003.a.block_index mod 4

        SEQ.DUAL.step_width [ fn003.a.side, fn003.a.block_index ] := ...
            SEQ_XY_DUAL_BLOCK_W / float(SEQ.DUAL.step_count [ fn003.a.side, fn003.a.block_index ] + 1)

        UIID_MAIN.seq.leds [ fn003.a.side, fn003.a.block_index ] -> picture := ...
            SEQ_step_led_pictures [ SEQ.DUAL.step_count [ fn003.a.side, fn003.a.block_index ] ]

        { update the number of step sliders and their pictures }
        for fn003.l.counter := 0 to 7
            if fn003.l.counter <= SEQ.DUAL.step_count [ fn003.a.side, fn003.a.block_index ]
                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + fn003.a.block_index * 8 ] -> UI_SHOW
                
                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + fn003.a.block_index * 8 ] -> pos_x := ...
                    SEQ_STEP_COORD [                                                   ...
                        switch_MAIN.SEQ.combine,                                       ...
                        fn003.a.side,                                                  ...
                        SEQ.DUAL.step_count [ fn003.a.side, fn003.a.block_index ], ...
                        fn003.l.counter                                                ...
                    ] + SEQ_XY_BLOCK_START_OFFSET [ fn003.a.block_index ] + SEQ_RIGHT_X_OFFSET * fn003.a.side

            else
                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + fn003.a.block_index * 8 ] -> UI_HIDE
            end if
        end for

    else  { SEQ JOIN }
        // message(f'FN003: Processing SEQ JOIN - moving ui controls to JOIN position')
        SEQ.JOIN.step_width [ fn003.a.block_index + fn003.a.side * 4 ] := ...
            SEQ_XY_JOIN_BLOCK_W / float(SEQ.JOIN.step_count [ fn003.a.block_index + fn003.a.side * 4  ] + 1)

        UIID_MAIN.seq.leds [ fn003.a.side, fn003.a.block_index] -> picture := ...
            SEQ_step_led_pictures [ SEQ.JOIN.step_count [ fn003.a.block_index + fn003.a.side * 4 ] ]

        for fn003.l.counter := 0 to 7
            if fn003.l.counter <= SEQ.JOIN.step_count [ fn003.a.block_index + fn003.a.side * 4 ]
                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + (fn003.a.block_index) * 8 ] -> UI_SHOW

                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + (fn003.a.block_index) * 8 ] -> pos_x := ...
                    SEQ_STEP_COORD [                                ...
                        switch_MAIN.SEQ.combine,                    ...
                        fn003.a.side,                               ...
                        SEQ.JOIN.step_count [ fn003.a.block_index + fn003.a.side * 4 ],...
                        fn003.l.counter                             ...
                    ] + SEQ_XY_BLOCK_START_OFFSET [ fn003.a.block_index ]

            else
                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + (fn003.a.block_index ) * 8 ] -> UI_HIDE
            end if
        end for

    end if 
end function

function fn004_get_current_seq_block
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        for fn004.l.block_counter := 0 to 3
            if  fn004.a.x_coord >= SEQ_DUAL_XY_BLOCK_START_END [ fn004.l.block_counter, __START ] and ...
                fn004.a.x_coord <= SEQ_DUAL_XY_BLOCK_START_END [ fn004.l.block_counter, __END ]
                fn004.r.block_index := fn004.l.block_counter
            end if
        end for
    else
        for fn004.l.block_counter := 0 to 7
            if  fn004.a.x_coord >= SEQ_JOIN_XY_BLOCK_START_END [ fn004.l.block_counter, __START ] and ...
                fn004.a.x_coord <= SEQ_JOIN_XY_BLOCK_START_END [ fn004.l.block_counter, __END ]
                fn004.r.block_index := fn004.l.block_counter
            end if
        end for 
    end if 
end function

function get_seq_step_index
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        fn004.a.x_coord := get_control_par_real_arr(  ...
            UIID_MAIN.SEQ.xypads [ uics_seq_side ], ...
            CONTROL_PAR_VALUE,                      ...
            __X_AXIS                                ...
        ) 
    else
        fn004.a.x_coord := xypad_MAIN.SEQ.join [ __X_AXIS ]
        // message(f'get seq dual step index JOIN')
    end if

    call fn004_get_current_seq_block
    fn001.a.block_index := fn004.r.block_index
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        fn001.a.side        := uics_seq_side
    else
        fn001.a.side        := -1
    end if
    call fn001_get_seq_step_index
end function

function get_seq_join_step_index
    fn008.a.x_coord := xypad_MAIN.SEQ.join [ 0 ]
    call fn008_get_current_seq_join_block

    fn009.a.block_index := fn008.r.block_index
    // message("GET_SEQ_JOIN_STEP_INDEX, block: " & fn009.a.block_index)

    call fn009_get_seq_join_step_index
end function

function fn008_get_current_seq_join_block
    for fn008.l.block_counter := 0 to 7
        if  fn008.a.x_coord >= SEQ_JOIN_XY_BLOCK_START_END [ fn008.l.block_counter, __START ] and ...
            fn008.a.x_coord <= SEQ_JOIN_XY_BLOCK_START_END [ fn008.l.block_counter, __END ]
            fn008.r.block_index := fn008.l.block_counter
            // message("FN008_GET_CURRENT_SEQ_JOIN_BLOCK " & fn008.r.block_index)
        end if
    end for
end function

function fn009_get_seq_join_step_index
    // message("FN009_GET_SEQ_JOIN_STEP_INDEX ---------- ")
    fn009.l.xy_x := xypad_MAIN.SEQ.join [ 0 ]
    
    fn009.l.xy_x.normalized := fn009.l.xy_x - 0.125 * float(fn009.a.block_index)    

    fn009.r.step_index := int(( fn009.l.xy_x.normalized )/ SEQ.JOIN.step_width [ fn009.a.block_index ]) + ...
        8 * fn009.a.block_index
    // message("        block ______: " & fn009.a.block_index)
    // message("        x __________: " & fn009.l.xy_x)
    // message("        x normalized: " & fn009.l.xy_x.normalized)
    // message("        Step W _____: " & SEQ.JOIN.step_width [ fn009.a.block_index ])
    // message("        step index  : " & fn009.r.step_index)

    if fn009.r.step_index = 32 and xypad_MAIN.SEQ.join [ 0 ] < 0.5
        fn009.r.step_index := 31
    end if
    if fn009.r.step_index = 64 and xypad_MAIN.SEQ.join [ 0 ] > 0.99
        fn009.r.step_index := 63
    end if
end function

function fn010_set_seq_step_value
    // message("FN010_SET_SEQ_STEP_VALUE ---------- ")
    // message("    fn10 side: " & fn010.l.side)
    // message("    fn10 step index: " & fn010.a.step_index)

    UIID_MAIN.seq.step [ fn010.l.side, fn010.a.step_index mod 32 ] -> picture_state := ...
        int(float(SEQ_XY_H-1) * fn010.a.value)

    { depends on the target showing }
    // message("FN10 setting the value for step index: " & fn010.a.step_index)
    SEQ.data.i [                             ...
        fn010.l.side,                        ...
        SEQ.showing_target [ fn010.l.side ], ...
        fn010.a.step_index mod 32            ...
    ] := int( 1000000.0 * fn010.a.value )

    SEQ.data.f [                             ...
        fn010.l.side,                        ...
        SEQ.showing_target [ fn010.l.side ], ...
        fn010.a.step_index mod 32            ...
    ] := fn010.a.value
end function

function fn012_seq_recall_step_count
    for b.i := 0 to 3
        fn003.a.mode        := switch_MAIN.SEQ.combine
        fn003.a.side        := fn012.a.side // __LEFT then __RIGHT
        if switch_MAIN.SEQ.combine = __SEQ_DUAL
            fn003.a.block_index := b.i
        else
            fn003.a.block_index := b.i + 4 * fn012.a.side
        end if

        call fn003_set_block_step_count

    end for
end function

{{ general  }}
function fn005_set_seq_target_selector
    for i.i := 0 to 4
        UIID_MAIN.seq.target_selectors [ i.i ] -> value := __OFF
    end for
    if in_range(fn005.a.selector_index, 0, 4)
        message(f'target selector activated: <fn005.a.selector_index >')
        UIID_MAIN.seq.target_selectors [ fn005.a.selector_index ] -> value := __ON
    end if
end function

function fn011_clear_target_activators
    for i.i := 0 to 4
        UIID_MAIN.seq.target_activators [ fn011.a.side, i.i] -> value := __OFF
    end for
    if in_range(fn011.a.index, 0, 4)
        UIID_MAIN.seq.target_activators [ fn011.a.side, fn011.a.index ] -> value := __ON
    end if
end function

function fn014_seq_recall_target_steps_values_and_pictures
    // message("FN14 called")
    // message("    fn014.a.side: " & fn014.a.side)
    // message("    fn014.a.target_index: " & fn014.a.target_index)
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        fn006.a.side := fn014.a.side
        call fn006_recall_seq_values
        for fn014.l.counter := 0 to 3
            fn013.a.side        := fn014.a.side
            fn013.a.block_index := fn014.l.counter
            call fn013_update_seq_step_pictures
        end for
    else
        { mirror the right side }
        fn011.a.side  := __RIGHT
        fn011.a.index := fn014.a.target_index
        call fn011_clear_target_activators

        SEQ.showing_target [ __RIGHT ] := fn014.a.target_index 

        for fn014.l.counter := 0 to 1
            fn006.a.side := fn014.l.counter
            call fn006_recall_seq_values

            for fn014.l.counter2 := 0 to 3
                fn013.a.side        := fn014.l.counter
                fn013.a.block_index := fn014.l.counter2 + fn014.l.counter * 4
                call fn013_update_seq_step_pictures
            end for
        end for
    end if
end function

function fn015_set_seq_play_direction_btns
    for i.i := 0 to 2
        UIID_MAIN.seq.direction_btns [ fn015.a.side,  i.i] -> value := __OFF
    end for
    UIID_MAIN.seq.direction_btns [ fn015.a.side, fn015.a.btn_index] -> value := __ON
end function

function set_seq_target_selectors_text_alignment
    for i.i := 0 to 4
        UIID_MAIN.seq.target_selectors [ i.i ] -> text_alignment := abs(1 - switch_MAIN.SEQ.combine)
    end for
end function

function fn016_set_data_display_from_seq_xy
    select(SEQ.showing_target [ fn016.a.side ])
        case SEQ_TARGET_VELO  
            @fn016.r.title      := "velocity"
            if fn016.a.value * 127.0 = 0.0
                @fn016.r.text_data := "1"
            else
                @fn016.r.text_data := int(fn016.a.value * 127.0)
            end if

        case SEQ_TARGET_PITCH 
            @fn016.r.title      := "pitch"
            if UIID_MAIN.SEQ.xypads [ fn016.a.side ] -> key_shift = __ON
                @fn016.r.text_data := round((fn016.a.value * 24.0 - 12.0)*100.0)/100.0
            else
                @fn016.r.text_data := int(fn016.a.value * 24.0 - 12.0)
            end if

        case SEQ_TARGET_LENGTH
            @fn016.r.title      := "length"
            // if UIID_MAIN.SEQ.xypads [ fn016.a.side ] -> key_shift = __ON
            //     @fn016.r.text_data := round((fn016.a.value * 4.0 - 2.0)*100.0)/100.0
            // else
                @fn016.r.text_data := int(fn016.a.value * 200.0) & "%"
            // end if

        case SEQ_TARGET_PAN
            @fn016.r.title      := "pan"
            if fn016.a.value < 0.49
                @fn016.r.text_data := int(100.0 - abs(fn016.a.value * 200.0)) & " L"
            else
                if fn016.a.value > 0.51
                    @fn016.r.text_data := int(abs((fn016.a.value-0.5) * 200.0)) & " R"
                else
                    @fn016.r.text_data := "Center"
                end if
            end if

        case SEQ_TARGET_FILTER
            if fn016.a.value < 0.49 { low  pass }
                set_engine_par(ENGINE_PAR_CUTOFF, int(fn016.a.value * 2000000.0), __NO_GROUP, __LP_FILTER_CA_SLOT, NI_BUS_OFFSET+15)
                @fn016.r.title     := "Low Pass"
                @fn016.r.text_data := get_engine_par_disp(ENGINE_PAR_CUTOFF, __NO_GROUP, __LP_FILTER_CA_SLOT, NI_BUS_OFFSET+15) & "hz"
            else                   { high pass }
                if fn016.a.value > 0.51
                    set_engine_par(ENGINE_PAR_CUTOFF, int((fn016.a.value-0.5) * 2000000.0), __NO_GROUP, __HP_FILTER_CA_SLOT, NI_BUS_OFFSET+15)
                    @fn016.r.title     := "High Pass"
                    @fn016.r.text_data := get_engine_par_disp(ENGINE_PAR_CUTOFF, __NO_GROUP, __HP_FILTER_CA_SLOT, NI_BUS_OFFSET+15) & "hz"
                else
                    @fn016.r.title     := "Filter Off"
                    @fn016.r.text_data := "Off"
                end if
            end if

    end select
end function

{ retrieves data from SEQ.data }
{{ 17 }}
function fn017_get_seq_target_data
    if  UIID_MAIN.seq.target_power [ fn017.a.side, SEQ_TARGET_VELO ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_DUAL or ...
        UIID_MAIN.seq.target_power [ __LEFT, SEQ_TARGET_VELO ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_JOIN
        fn017.l.seq_data := ...
                SEQ.data.i [                                            ...
                    fn017.a.side,                                       ...
                    SEQ_TARGET_VELO,                                    ...
                    fn017.a.step_counter + fn017.a.block_step_index * 8 ...
                ]
        if fn017.a.transform_value = __YES
            fn034.a.target_index := SEQ_TARGET_VELO
            fn034.a.value        := fn017.l.seq_data
            call fn034_transform_data_according_to_seq_target
            fn017.r.velocity := fn034.r.transf_value.i
        else
            fn017.r.velocity := fn017.l.seq_data
        end if
    else { if target velocity is off, use the played velocity }
        fn017.r.velocity := layers.note_velo [ fn017.a.side, fn017.a.key_note ]
    end if

    if  UIID_MAIN.seq.target_power [ fn017.a.side, SEQ_TARGET_PITCH ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_DUAL or ...
        UIID_MAIN.seq.target_power [ __LEFT, SEQ_TARGET_PITCH ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_JOIN
        fn017.l.seq_data := ...
                SEQ.data.i [                                            ...
                    fn017.a.side,                                       ...
                    SEQ_TARGET_PITCH,                                    ...
                    fn017.a.step_counter + fn017.a.block_step_index * 8 ...
                ]
        if fn017.a.transform_value = __YES
            fn034.a.target_index := SEQ_TARGET_PITCH
            fn034.a.value        := fn017.l.seq_data
            call fn034_transform_data_according_to_seq_target
            fn017.r.pitch := fn034.r.transf_value.i
        else
            fn017.r.pitch := fn017.l.seq_data
        end if
        message(f'    FN17 | side: <fn017.a.side> | block: <fn017.a.block_step_index> | step: <fn017.a.step_counter> |  fn017.r.pitch: <fn017.r.pitch>')
    else
        fn017.r.pitch := 0
    end if

    if  UIID_MAIN.seq.target_power [ fn017.a.side, SEQ_TARGET_LENGTH ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_DUAL or ...
        UIID_MAIN.seq.target_power [ __LEFT, SEQ_TARGET_LENGTH ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_JOIN
        fn017.l.seq_data := ...
                SEQ.data.i [                                            ...
                    fn017.a.side,                                       ...
                    SEQ_TARGET_LENGTH,                                  ...
                    fn017.a.step_counter + fn017.a.block_step_index * 8 ...
                ]
        if fn017.a.transform_value = __YES
            fn034.a.target_index := SEQ_TARGET_LENGTH
            fn034.a.value        := fn017.l.seq_data
            call fn034_transform_data_according_to_seq_target
            fn017.r.length := fn034.r.transf_value.i
        else 
            fn017.r.length := fn017.l.seq_data
        end if
    else
        fn017.r.length := 0
    end if

    if  UIID_MAIN.seq.target_power [ fn017.a.side, SEQ_TARGET_PAN ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_DUAL or ...
        UIID_MAIN.seq.target_power [ __LEFT, SEQ_TARGET_PAN ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_JOIN
        fn017.l.seq_data := ...
                SEQ.data.i [                                            ...
                    fn017.a.side,                                       ...
                    SEQ_TARGET_PAN,                                     ...
                    fn017.a.step_counter + fn017.a.block_step_index * 8 ...
                ]
        if fn017.a.transform_value = __YES
            fn034.a.target_index := SEQ_TARGET_PAN
            fn034.a.value        := fn017.l.seq_data
            call fn034_transform_data_according_to_seq_target
            fn017.r.pan := fn034.r.transf_value.i
        else
            fn017.r.pan := fn017.l.seq_data
        end if
    else
        fn017.r.pan := 0
    end if

    if  UIID_MAIN.seq.target_power [ fn017.a.side, SEQ_TARGET_FILTER ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_DUAL or ...
        UIID_MAIN.seq.target_power [ __LEFT, SEQ_TARGET_FILTER ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_JOIN
        fn017.r.filter_status := __ON
        fn017.l.seq_data := ...
                SEQ.data.i [                                            ...
                    fn017.a.side,                                       ...
                    SEQ_TARGET_FILTER,                                  ...
                    fn017.a.step_counter + fn017.a.block_step_index * 8 ...
                ]
        { not a transformation per se, just retrieveing the values 
         necessary for the lp/hp filters }
        fn034.a.target_index := SEQ_TARGET_FILTER
        fn034.a.value        := fn017.l.seq_data
        call fn034_transform_data_according_to_seq_target
        fn017.r.filter_value    := fn034.r.transf_value.i
        fn017.r.lp_filter_value := fn034.r.transf_value.i_lp
        fn017.r.hp_filter_value := fn034.r.transf_value.i_hp

    else
        fn017.r.filter_status := __OFF
        fn017.r.filter_value  := 500000
    end if
end function

{{ 20 }}
function fn020_update_seq_target_state
    // message(f'FN020 CALL ()')
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        // message(f'    SEQ DUAL')
        if fn020.a.seq_power_state = __ON
            // message(f'        SEQ power ON')
            if  fn020.a.target_power_uiid -> value = __OFF
                // message(f'          Target Off on side  <fn020.a.side >')
                UIID_MAIN.seq.off_label      [ fn020.a.side ] -> picture := "label_FX.off"
                UIID_MAIN.seq.off_label      [ fn020.a.side ] -> UI_SHOW
                UIID_MAIN.seq.off_label_text [ fn020.a.side ] -> UI_SHOW
                UIID_MAIN.seq.off_label_text [ fn020.a.side ] -> text := "TARGET " & SEQ.target_names [ fn020.a.target_index ] & " IS OFF"
            else
                // message(f'          Target On on side  <fn020.a.side >')
                UIID_MAIN.seq.off_label      [ fn020.a.side ] -> UI_HIDE
                UIID_MAIN.seq.off_label_text [ fn020.a.side ] -> UI_HIDE
                // message(f'          text label hide state: <UIID_MAIN.seq.off_label_text [ fn020.a.side ] -> hide >')
            end if
        else
            // message(f'          Seq off on side  <fn020.a.side >')
            // message(f'        SEQ power OFF')
            UIID_MAIN.seq.off_label      [ fn020.a.side ] -> UI_HIDE
            UIID_MAIN.seq.off_label_text [ fn020.a.side ] -> UI_HIDE
            UIID_MAIN.seq.off_label      [ fn020.a.side ] -> picture := "label_seq_steps_bg"
            UIID_MAIN.seq.off_label_text [ fn020.a.side ] -> text    := ""
        end if

    else
        message(f'    SEQ JOIN')
        if UIID_MAIN.seq.power [ __LEFT ] -> value = __ON
            message(f'        SEQ power ON')
            if  fn020.a.target_power_uiid -> value = __OFF
                message(f'              Target OFF')
                label_MAIN.SEQjoin.off -> picture := "label_MAIN.SEQjoin.off"
                label_MAIN.SEQjoin.off -> UI_SHOW
                label_MAIN.SEQjoin.off -> text := "TARGET " & SEQ.target_names [ fn020.a.target_index ] & " IS OFF"
            else
                message(f'              Target ON')
                label_MAIN.SEQjoin.off -> UI_HIDE
            end if
        else
            message(f'        SEQ power OFF')
            label_MAIN.SEQjoin.off -> UI_SHOW
            label_MAIN.SEQjoin.off -> picture := "label_seq_join_steps_bg"
            label_MAIN.SEQjoin.off -> text    := ""
        end if

    end if
end function

function fn21_get_seq_target_active_activator
    for fn021.l.counter := 0 to 4 { 5 activator buttons per side }
        if  UIID_MAIN.seq.target_activators [ fn021.a.side, fn021.l.counter ] -> value = __ON
            fn021.r.active_index := fn021.l.counter
            exit
        end if
    end for
end function

{{ 22 this will be called when a block is about to start }}
function fn022_get_flux_values
    if  UIID_MAIN.seq.flux_rand_btns  [ fn022.a.side, fn022.a.block_step_index ] -> value = __ON and ...
        UIID_MAIN.seq.flux_rand_power [ fn022.a.side ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_DUAL or ...
        UIID_MAIN.seq.flux_rand_btns  [ fn022.a.side, fn022.a.block_step_index ] -> value = __ON and ...
        UIID_MAIN.seq.flux_rand_power [ __LEFT ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_JOIN
        // message(f'fn22 ______________ side: < fn022.a.side >')
        {{ FLUX RAND VELOCITY }}
        if switch_MAIN.SEQ.combine = __SEQ_DUAL
            fn022.l.seq_mode_side := fn022.a.side
        else
            fn022.l.seq_mode_side := __LEFT
        end if

        if  UIID_MAIN.seq.target_power [ fn022.l.seq_mode_side, SEQ_TARGET_VELO ] -> value = __ON
            if switch_MAIN.SEQ.combine = __SEQ_DUAL
                fn022.l.flux_intensity := SEQ.flux_rand_intensity [ fn022.l.seq_mode_side, SEQ_TARGET_VELO ]
            else
                fn022.l.flux_intensity := SEQ.join.flux_rand_intensity [ SEQ_TARGET_VELO ]
            end if
            { first get the seed based on the flux randomizer intensity amount }
            fn022.l.flux_velo_seed := int(1000000.0 * (float(fn022.l.flux_intensity)/100.0) )
            { generate the actual flux offset value }
            fn022.l.flux_velo      := random( -1 * fn022.l.flux_velo_seed, fn022.l.flux_velo_seed)
            { add to the base value }
            fn022.r.step_velocity := fn022.a.step_velocity + fn022.l.flux_velo
            { clam if needed }
            if fn022.r.step_velocity > 1000000
                fn022.r.step_velocity := 1000000
            end if
            if fn022.r.step_velocity < 1
                fn022.r.step_velocity := 1
            end if

        end if

        {{ FLUX RAND PITCH }}
        if UIID_MAIN.seq.target_power [ fn022.l.seq_mode_side, SEQ_TARGET_PITCH ] -> value = __ON
            if switch_MAIN.SEQ.combine = __SEQ_DUAL
                fn022.l.flux_intensity := SEQ.flux_rand_intensity [ fn022.l.seq_mode_side, SEQ_TARGET_PITCH ]
            else
                fn022.l.flux_intensity := SEQ.join.flux_rand_intensity [ SEQ_TARGET_PITCH ]
            end if
            { flux rand intensity is 0:100, }
            fn022.l.flux_pitch_seed := int(1000000.0 * (float(fn022.l.flux_intensity)/100.0))
            fn022.l.flux_pitch      := random( -1 * fn022.l.flux_pitch_seed, fn022.l.flux_pitch_seed)
            fn022.r.step_pitch := fn022.a.step_pitch + fn022.l.flux_pitch
            // message(f'    fn022.l.flux_pitch_seed : <fn022.l.flux_pitch_seed>')
            // message(f'    fn022.l.flux_pitch :      <fn022.l.flux_pitch>')
            // message(f'    fn022.r.step_pitch :      <fn022.r.step_pitch>')
            if fn022.r.step_pitch > 1000000
                fn022.r.step_pitch := 1000000
            end if
            if fn022.r.step_pitch < 0
                fn022.r.step_pitch := 0
            end if
            message(f'    FN22: processing flux pitch, original value: <fn022.a.step_pitch > | flux pitch: <fn022.r.step_pitch>')
            // message(f'    fn022.r.step_pitch :      <fn022.r.step_pitch>')
        end if

        {{ FLUX RAND length }}
        if UIID_MAIN.seq.target_power [ fn022.l.seq_mode_side, SEQ_TARGET_LENGTH ] -> value = __ON
            if switch_MAIN.SEQ.combine = __SEQ_DUAL
                fn022.l.flux_intensity := SEQ.flux_rand_intensity [ fn022.l.seq_mode_side, SEQ_TARGET_LENGTH ]
            else
                fn022.l.flux_intensity := SEQ.join.flux_rand_intensity [ SEQ_TARGET_LENGTH ]
            end if
            fn022.l.flux_length_seed := int(1000000.0 * (float(fn022.l.flux_intensity )/100.0) )
            fn022.l.flux_length      := random( -1 * fn022.l.flux_length_seed, fn022.l.flux_length_seed)
            fn022.r.step_length := fn022.a.step_length + fn022.l.flux_length
            if fn022.r.step_length > 1000000
                fn022.r.step_length := 1000000
            end if
            if fn022.r.step_length < 0
                fn022.r.step_length := 0
            end if
        end if
        
        {{ FLUX RAND PAN }}
        if UIID_MAIN.seq.target_power [ fn022.l.seq_mode_side, SEQ_TARGET_PAN ] -> value = __ON
            if switch_MAIN.SEQ.combine = __SEQ_DUAL
                fn022.l.flux_intensity := SEQ.flux_rand_intensity [ fn022.l.seq_mode_side, SEQ_TARGET_PAN ]
            else
                fn022.l.flux_intensity := SEQ.join.flux_rand_intensity [ SEQ_TARGET_PAN ]
            end if
            fn022.l.flux_pan_seed := int(1000000.0 * (float(fn022.l.flux_intensity )/100.0) )
            fn022.l.flux_pan      := random( -1 * fn022.l.flux_pan_seed, fn022.l.flux_pan_seed)
            fn022.r.step_pan := fn022.a.step_pan + fn022.l.flux_pan
            if fn022.r.step_pan > 1000000
                fn022.r.step_pan := 1000000
            end if
            if fn022.r.step_pan < 0
                fn022.r.step_pan := 0
            end if
        end if

        {{ FLUX RAND PAN }}
        if UIID_MAIN.seq.target_power [ fn022.l.seq_mode_side, SEQ_TARGET_FILTER ] -> value = __ON
            { not scaling by /100 because the extreme values of the filter just completely close the sound
            so scaling by 150 instead of 100 }
            if switch_MAIN.SEQ.combine = __SEQ_DUAL
                fn022.l.flux_intensity := SEQ.flux_rand_intensity [ fn022.l.seq_mode_side, SEQ_TARGET_PAN ]
            else
                fn022.l.flux_intensity := SEQ.join.flux_rand_intensity [ SEQ_TARGET_FILTER ]
            end if
            fn022.l.flux_filter_seed := int(1000000.0 * (float(fn022.l.flux_intensity )/150.0) )
            fn022.l.flux_filter      := random( -1 * fn022.l.flux_filter_seed, fn022.l.flux_filter_seed)
            fn022.r.step_filter := fn022.a.step_filter + fn022.l.flux_filter
            if fn022.r.step_filter > 850000
                fn022.r.step_filter := 850000
            end if
            if fn022.r.step_filter < 150000
                fn022.r.step_filter := 150000
            end if
            if fn022.r.step_filter > 500000 { high pass }
                fn022.r.step_lp_filter := 1000000
                fn022.r.step_hp_filter := ( fn022.r.step_filter - 500000 ) * 2
            else                        { low pass }
                fn022.r.step_lp_filter := fn022.r.step_filter * 2
                fn022.r.step_hp_filter := 0
            end if
        end if

        { update the step picture we need scaled values 0:1 }
        if UIID_MAIN.seq.target_power [ fn022.l.seq_mode_side, SEQ.showing_target [ fn022.l.seq_mode_side ] ] -> value = __ON
            select(SEQ.showing_target [ fn022.l.seq_mode_side ])
                case SEQ_TARGET_VELO
                    fn018.a.value      := float(fn022.r.step_velocity)/127.0
                case SEQ_TARGET_PITCH
                    fn018.a.value      := float(fn022.r.step_pitch + 1200000)/2400000.0
                case SEQ_TARGET_LENGTH
                    fn018.a.value      := float(fn022.r.step_length)/1000000.0
                case SEQ_TARGET_PAN
                    fn018.a.value      := float(fn022.r.step_pan + 1000)/2000.0
                case SEQ_TARGET_FILTER
                    fn018.a.value      := float(fn022.r.step_filter)/850000.0
            end select
            
            fn018.a.side       := fn022.a.side
            fn018.a.step_index := fn022.a.step_counter + fn022.a.block_step_index * 8
            call fn018_set_seq_step_picture_state
        end if

    end if
end function 

function fn029_clear_arp_mode_btns
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        for fn029.l.counter := 0 to 5
            UIID_MAIN.seq.arp_menu_items [ fn029.a.side, fn029.l.counter ] -> value := __OFF
            if fn029.a.side = __LEFT
                UIID_MAIN.seq.join_arp_menu_items [ fn029.l.counter ] -> value := __OFF
            end if
        end for
        UIID_MAIN.seq.arp_menu_items [ fn029.a.side, fn029.a.index ] -> value := __ON

        UIID_MAIN.seq.arp_menu [ fn029.a.side ] -> text := arp_menu_items_text [ fn029.a.index ]
        if fn029.a.side = __LEFT
            UIID_MAIN.seq.join_arp_menu_items [ fn029.a.index ] -> value := __ON
        end if
    else
        for fn029.l.counter := 0 to 5
            UIID_MAIN.seq.join_arp_menu_items [ fn029.l.counter ]         -> value := __OFF
            UIID_MAIN.seq.arp_menu_items      [ __LEFT, fn029.l.counter ] -> value := __OFF
        end for
        UIID_MAIN.seq.join_arp_menu_items [ fn029.a.index ]         -> value := __ON
        UIID_MAIN.seq.arp_menu_items      [ __LEFT, fn029.a.index ] -> value := __ON
        UIID_MAIN.seq.arp_menu            [ __LEFT ]                -> text := arp_menu_items_text [ fn029.a.index ]
        switch_MAIN.ARP.LEFT.modeMenu                               -> text := arp_menu_items_text [ fn029.a.index ]
    end if
end function

{{ 33 }}
function fn033_transform_step_value_into_dynamic
    if fn033.a.dyn_value >= 0.5
        fn033.l.dyn_transf_value := abs(2.0 * fn033.a.dyn_value - 1.0 )
    else
        fn033.l.dyn_transf_value := 2.0 * fn033.a.dyn_value
    end if

    if fn033.a.dyn_value >= 0.5
        fn033.l.delta_max      := 1.0 - fn033.a.step_value
        fn033.r.transf_value.r := fn033.a.step_value + fn033.l.delta_max * fn033.l.dyn_transf_value
    else
        fn033.r.transf_value.r := fn033.a.step_value * fn033.l.dyn_transf_value
    end if
    fn033.r.transf_value.i := int( 1000000.0 * fn033.r.transf_value.r )
end function

{{ 30 }}
function fn030_set_seq_step_dyn_value
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        fn030.l.mode_side := fn030.a.side
    else
        fn030.l.mode_side := __LEFT
    end if

    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        fn033.a.dyn_value := ...
            get_control_par_real_arr(                       ...
                UIID_MAIN.seq.dyn_slider [ fn030.a.side ], ...
                CONTROL_PAR_VALUE,                         ...
                __Y_AXIS                                   ...
            )
    else
        fn033.a.dyn_value := ...
            get_control_par_real_arr(                       ...
                UIID_MAIN.seq.dyn_slider [ __LEFT ], ...
                CONTROL_PAR_VALUE,                         ...
                __Y_AXIS                                   ...
            )
    end if
    fn033.a.step_value := fn030.a.value
    call fn033_transform_step_value_into_dynamic

    SEQ.data.dyn.i [        ...
        fn030.a.side,       ...
        fn030.a.target,     ...
        fn030.a.step_index  ...
    ] := int( 1000000.0 * fn033.r.transf_value.r )

    SEQ.data.dyn.f [        ...
        fn030.a.side,       ...
        fn030.a.target,     ...
        fn030.a.step_index  ...
    ] := fn033.r.transf_value.r
    message(f'    FN30 Dynamic value stored: < fn033.r.transf_value.r >')
end function

function fn031_set_dyn_sliders_picture
    { update the ui label for the dyn slider }
    if fn031.a.reset = __OFF
        if  UIID_MAIN.seq.dyn_slider [ fn031.a.side ] -> key_control = __OFF

            UIID_MAIN.seq.dyn_slider.label [ fn031.a.side ] -> picture_state := int ( ...
                get_control_par_real_arr(                       ...
                    UIID_MAIN.seq.dyn_slider [ fn031.a.side ],  ...
                    CONTROL_PAR_VALUE,                          ...
                    __Y_AXIS                                    ...
                ) * 132.0 )

        else
            UIID_MAIN.seq.dyn_slider.label [ fn031.a.side ] -> picture_state := 66

            set_control_par_real_arr(                       ...
                UIID_MAIN.seq.dyn_slider [ fn031.a.side ],  ...
                CONTROL_PAR_VALUE,                          ...
                0.5,                                        ...
                1                                           ...
            )
        end if

    else
        UIID_MAIN.seq.dyn_slider.label [ fn031.a.side ] -> picture_state := 66

        set_control_par_real_arr(                       ...
            UIID_MAIN.seq.dyn_slider [ fn031.a.side ],  ...
            CONTROL_PAR_VALUE,                          ...
            0.5,                                        ...
            1                                           ...
        )
    end if

    {
        - a step has int and float values stored
        - when we press mouse down any subsequent update in the
        slider (y axis) will 
            - read from SEQ.data.f and update the sequencer steps pictures
            - the new step values will be stored in 
                SEQ.data.dyn.i
                SEQ.data.dyn.f

            but what does it mean? 
            means that when the flux rand runs, it will update its 
            arrays based on these dyn slider arrays rather than the original arrays

            update the SEQ.data.dyn.f with the new values calculated from
            the SEQ.data.i and the current slider value
            what's the calculation?
    }
end function

{{ 32 }}
function fn032_set_seq_step_value_and_ui_via_dyn_slider
    { as of 3/2025 the syn slider will only act on the 
     velocity target. In case we want to expand this later
     to all targets, we have to use SEQ.showing_target [ fn032.a.side ] 
     instead of the VELO constant on the target argument }

    fn002.a.table_to_update := __SEQ_DYN_TRANSF_TABLE

    for fn032.l.side_counter := __LEFT to __RIGHT

        { process side and flux rand power depending on what mode the sequencer is}
        fn032.l.loop_process_side     := fn032.l.side_counter
        fn032.l.flux_rand_power       := UIID_MAIN.seq.flux_rand_power [ __LEFT ] -> value

        if switch_MAIN.SEQ.combine = __SEQ_DUAL and fn032.l.side_counter = fn032.a.side
            fn032.l.loop_process_side     := fn032.a.side
            fn032.l.flux_rand_power       := UIID_MAIN.seq.flux_rand_power [ fn032.a.side ] -> value
        end if

        if  switch_MAIN.SEQ.combine = __SEQ_JOIN or ...
            switch_MAIN.SEQ.combine = __SEQ_DUAL and fn032.l.side_counter = fn032.a.side

            // message(f'    processing side: < fn032.l.loop_process_side>')
            for fn032.l.block_index := 0 to 3
                { capturing bloc flux rand power depending on the sequencer mode }
                fn032.l.flux_rand_block_power := UIID_MAIN.seq.flux_rand_btns  [ ...
                                                    fn032.l.side_counter,        ...
                                                    fn032.l.block_index          ...
                                                ] -> value

                if switch_MAIN.SEQ.combine = __SEQ_DUAL and fn032.l.side_counter = fn032.a.side
                    fn032.l.flux_rand_block_power := UIID_MAIN.seq.flux_rand_btns  [ ...
                                                    fn032.a.side,                    ...
                                                    fn032.l.block_index              ...
                                                ] -> value
                end if

                { looping through all steps on all blocks }
                for fn032.l.step_index := 0 to 7
                    fn002.a.step_index := fn032.l.block_index * 8 + fn032.l.step_index
                    fn002.a.side       := fn032.l.loop_process_side

                    if  fn032.l.flux_rand_block_power = __ON and fn032.l.flux_rand_power = __ON
                        // Flux SEQ data 
                        // message(f'    fn32 FLUX data')
                        fn002.a.value      :=                                ...
                            SEQ.data.flux.f [                                ...
                                fn032.l.loop_process_side,                   ...
                                SEQ_TARGET_VELO,                             ...
                                fn032.l.block_index * 8 + fn032.l.step_index ...
                            ]
                    else
                        // message(f'    fn32 Original data')
                        // original SEQ data 
                        fn002.a.value      :=                                ...
                            SEQ.data.f [                                     ...
                                fn032.l.loop_process_side,                   ...
                                SEQ_TARGET_VELO,                             ...
                                fn032.l.block_index * 8 + fn032.l.step_index ...
                            ]
                    end if
                    fn002.a.side            := fn032.l.loop_process_side
                    fn002.a.target          := SEQ_TARGET_VELO
                    fn002.a.table_to_update := __SEQ_DYN_TRANSF_TABLE
                    fn002.a.step_index      := fn032.l.block_index * 8 + fn032.l.step_index
                    call fn002_set_seq_step_value

                    { update the step values on the UI in case VELO is showing }
                    if  switch_MAIN.SEQ.combine = __SEQ_DUAL and SEQ.showing_target [ fn032.l.loop_process_side ] = SEQ_TARGET_VELO or ...
                        switch_MAIN.SEQ.combine = __SEQ_JOIN and SEQ.showing_target [ __LEFT ] = SEQ_TARGET_VELO
                        fn018.a.side       := fn032.l.loop_process_side
                        fn018.a.step_index := fn032.l.block_index * 8 + fn032.l.step_index
                        fn018.a.value      :=                                     ...
                            SEQ.data.dyn.f [                                      ...
                                fn032.l.loop_process_side,                        ...
                                SEQ.showing_target [ fn032.l.loop_process_side ], ...
                                fn018.a.step_index                                ...
                            ]
                        call fn018_set_seq_step_picture_state
                        // message(f'    updating UI side: <fn032.l.loop_process_side> | step: <fn018.a.step_index>')
                        if fn032.l.step_index mod 8 = 0
                            // message(f'    side: <fn032.l.loop_process_side> | block: <fn032.l.block_index> | step: <fn032.l.step_index> | value: <fn002.a.value> | pic value: <fn018.a.value>')
                        end if
                    end if
                end for
            end for

        end if

    end for
end function

{{ 34 }}
function fn034_transform_data_according_to_seq_target
    select (fn034.a.target_index)
        case SEQ_TARGET_VELO
            fn034.r.transf_value.i := ((126 * fn034.a.value) / 1000000) + 1

        case SEQ_TARGET_PITCH
            fn034.r.transf_value.i := ((24 * fn034.a.value) / 1000000) - 12

        case SEQ_TARGET_LENGTH
            if fn034.a.value < 500000
                fn034.r.transf_value.i := (990 * fn034.a.value)/500000 + 10 
            else
                fn034.r.transf_value.i := (1000 * fn034.a.value)/500000
            end if

        case SEQ_TARGET_PAN
            if fn034.a.value < 500000
                fn034.r.transf_value.i := (-1) * (1000 - fn034.a.value / 500)
            else
                if fn034.a.value > 500000
                    fn034.r.transf_value.i := (fn034.a.value-500000) / 500
                else
                    fn034.r.transf_value.i := 0
                end if
            end if

        case SEQ_TARGET_FILTER
            fn034.r.transf_value.i := fn034.a.value
            
            if fn034.r.transf_value.i < 490000  { low pass }
                fn034.r.transf_value.i_lp := fn034.r.transf_value.i * 2
                fn034.r.transf_value.i_hp := 0
            else                             { high pass }
                if fn034.r.transf_value.i > 510000
                    fn034.r.transf_value.i_lp := 1000000
                    fn034.r.transf_value.i_hp := (fn034.r.transf_value.i - 500000) * 2
                else { center point, both filters off }
                    fn034.r.transf_value.i_lp := 1000000
                    fn034.r.transf_value.i_hp := 0
                end if 
            end if
            fn034.r.transf_value.r_lp := float(fn034.r.transf_value.i_lp)/1000000.0
            fn034.r.transf_value.r_hp := float(fn034.r.transf_value.i_hp)/1000000.0

    end select

    fn034.r.transf_value.r := float(fn034.a.value)/1000000.0
end function

function fn035_update_random_labels
    UIID_random.picture_labels [ fn035.a.side ] -> picture_state := int(fn035.a.value * 99.0)

    if fn035.a.value = 1.0
        UIID_random.value_labels [ fn035.a.side ] -> x := random_sliders_x_pos [ fn035.a.side ] - 3
    else
        if fn035.a.value > 0.1
            UIID_random.value_labels [ fn035.a.side ] -> x := random_sliders_x_pos [ fn035.a.side ] - 2
        else
            UIID_random.value_labels [ fn035.a.side ] -> x := random_sliders_x_pos [ fn035.a.side ]
        end if
    end if
    UIID_random.value_labels [ fn035.a.side ] -> text := int(fn035.a.value * 100.0) & "%"
end function

function fn036_set_control_param_slider
    message(f'FN036 called, calling fn 37, 38, 39, 40 | value : <fn036.a.control_value> | target: <fn036.a.target>')
    fn037.a.side          := fn036.a.side
    fn037.a.target        := fn036.a.target
    fn037.a.control_value := fn036.a.control_value
    fn037.a.LFO_amount    := UIID_controls_LFO_amount [ fn036.a.target ] -> value
    fn037.a.link          := ...
        UIID_MAIN.FX.links [ UIID_FX.parameter_to_module [ fn036.a.target ] ] -> value
    call fn037_LFO.update_intensity_ring

    fn038.a.side          := fn036.a.side
    fn038.a.target        := fn036.a.target
    fn038.a.control_value := fn036.a.control_value
    fn038.a.LFO_amount    := fn037.a.LFO_amount
    fn038.a.link          := fn037.a.link
    call fn038_LFO_store_LFO_mod_data

    fn039.a.side          := fn036.a.side
    fn039.a.target        := fn036.a.target
    fn039.a.control_value := fn036.a.control_value
    fn039.a.link          := fn037.a.link
    call fn039_set_FX_engine_par

    fn040.a.side := fn036.a.side
    call fn040_set_MATRIX_slider_ps
    
    // UI update for the ui control param only 
    if UIID_MAIN.FX.links [ ...
        UIID_FX.parameter_to_module [ fn036.a.target ] ...
      ] -> value = 1
        message(f'    fn36 LINK is ON')
        // there are 16 elements on the each side 
        if fn036.a.target < 16 // left side 
            MAIN.FX.aux_flip_link := 16 // add 16 to get to right side 
        else                                                    // right side 
            MAIN.FX.aux_flip_link := -16 // subtract 16 to get to left side 
        end if

        fn040.a.side := abs(1-fn040.a.side) 
        call fn040_set_MATRIX_slider_ps

        // UI control update on the other side 
        set_control_par( ...
            UIID_controls [ ...
                fn036.a.target + MAIN.FX.aux_flip_link ...
            ], ...
            CONTROL_PAR_VALUE, ...
            fn036.a.control_value ... 
        )
    end if
end function

function fn042_update_fx_panel_selector_btns
    for fn042.l.panel := 0 to 7
        UIID_MAIN.FX_panel_selectors [ fn042.a.side, fn042.l.panel ] -> value := __OFF
    end for
    UIID_MAIN.FX_panel_selectors [ fn042.a.side, fn042.a.panel ] -> value := __ON

    if UIID_MAIN.FX.links [ fn042.a.panel + 8*fn042.a.side ] -> value = __ON
        fn042.a.other_side := abs(1-fn042.a.side)
        for fn042.l.panel := 0 to 7
            UIID_MAIN.FX_panel_selectors [ fn042.a.other_side, fn042.l.panel ] -> value := __OFF
        end for
        UIID_MAIN.FX_panel_selectors [ fn042.a.other_side, fn042.a.panel ] -> value := __ON
    end if
end function

function fn043_show_hide_fx_panels
    for fn043.l.panel := 0 to 7
        UIID_MAIN.FX_panels [ fn043.a.side, fn043.l.panel ] -> hide := HIDE_WHOLE_CONTROL
    end for
    UIID_MAIN.FX_panels [ fn043.a.side, fn043.a.panel ] -> hide := HIDE_PART_NOTHING

    if UIID_MAIN.FX.links [ fn043.a.panel + 8*fn043.a.side ] -> value = __ON
        fn043.a.other_side := abs(1-fn043.a.side)
        for fn043.l.panel := 0 to 7
            UIID_MAIN.FX_panels [ fn043.a.other_side, fn043.l.panel ] -> hide := HIDE_WHOLE_CONTROL
        end for
        UIID_MAIN.FX_panels [ fn043.a.other_side, fn043.a.panel ] -> hide := HIDE_PART_NOTHING
    end if
end function

function fn045_set_lfo_waveshape_selectors
    { waveshaper selectors update }
    for fn045.l.counter := 0 to 4
        UIID_LFO.waveshape_selectors [ fn045.l.counter ] -> value := __OFF
    end for
    UIID_LFO.waveshape_selectors [ fn045.a.index ] -> value := __ON
    LFO_data [ LFO_WAVESHAPE ] := fn045.a.index

    { ui viz update }
    call update_lfo_viz_picture

    {data update }
end function

function fn048_set_fx_saturation_mode
    for fn048.l.counter := 0 to 2
        UIID_lfp_sat_modes [ fn048.a.side, fn048.l.counter ] -> value := __OFF
    end for
    UIID_lfp_sat_modes [ fn048.a.side, fn048.a.index ] -> value := __ON
end function

function clear_all_leds
    for z.i := 0 to 7
        UIID_MAIN.seq.step_leds [ ...
            z.i / 4,              ...
            z.i mod 4             ...
        ] -> picture_state := 0
    end for
end function

{{ 49 }}
function fn049_set_seq_values_to_original
    if SEQ.showing_target [ fn49.a.side ] = SEQ_TARGET_VELO
        fn030.a.target     := SEQ_TARGET_VELO
        fn030.a.side       := fn49.a.side
        fn030.a.step_index := fn49.a.step + 8 *  fn49.a.block
        fn030.a.value      := SEQ.data.f [ ...
            fn49.a.side,                        ...
            SEQ.showing_target [ fn49.a.side ], ...
            fn49.a.step + 8 *  fn49.a.block     ...
        ]
        call fn030_set_seq_step_dyn_value
    end if
end function

function fn051_set_layer_panels_state
    { single shot elements }
    UIID_MAIN.single_hit_panel      [ fn051.a.side ] -> UI_HIDE
    UIID_MAIN.waveforms             [ fn051.a.side ] -> UI_HIDE
    UIID_MAIN.waveform_cursor       [ fn051.a.side ] -> UI_HIDE
    UIID_MAIN.waveform_overlay      [ fn051.a.side ] -> UI_HIDE
    UIID_MAIN.waveform_xypad_cursor [ fn051.a.side ] -> UI_HIDE

    UIID_MAIN.seq.off_label         [ fn051.a.side ] -> UI_HIDE
    UIID_MAIN.seq.off_label_text    [ fn051.a.side ] -> UI_HIDE
    UIID_MAIN.seq.off_label_text    [ fn051.a.side ] -> text := ''

    UIID_MAIN.single_hit_panel      [ fn051.a.side ] -> UI_HIDE
    UIID_MAIN.seq.flux_panels       [ fn051.a.side ] -> UI_HIDE
    UIID_MAIN.seq.arp_mode_panels   [ fn051.a.side ] -> UI_HIDE

    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        if fn051.a.side = __LEFT
            panel_MAIN.2SEQ.LEFT.controls  -> UI_HIDE
            slider_MAIN.2SEQ.LEFT.off      -> UI_HIDE
            label_MAIN.2SEQ.LEFT.off       -> UI_HIDE
        else
            panel_MAIN.2SEQ.RIGHT.controls -> UI_HIDE
            slider_MAIN.2SEQ.RIGHT.off     -> UI_HIDE
            label_MAIN.2SEQ.RIGHT.off      -> UI_HIDE
        end if
    end if

    if UIID_MAIN.layer.power [ fn051.a.side ] -> value = __ON    { layer on ? }
        if UIID_MAIN.seq.power [ fn051.a.side ] -> value = __OFF { single hit mode ? }
            if switch_MAIN.SEQ.combine = __SEQ_DUAL
                fn056.a.side := fn051.a.side
                call fn056_single_shot_wf_preview

                UIID_MAIN.single_hit_panel      [ fn051.a.side ] -> UI_SHOW
                UIID_MAIN.waveforms             [ fn051.a.side ] -> UI_SHOW
                UIID_MAIN.waveform_cursor       [ fn051.a.side ] -> UI_SHOW
                UIID_MAIN.waveform_overlay      [ fn051.a.side ] -> UI_SHOW
                UIID_MAIN.waveform_xypad_cursor [ fn051.a.side ] -> UI_SHOW

            else
                if fn051.a.side = __LEFT
                    label_MAIN.SEQjoin.off -> UI_SHOW
                end if 
            end if

        else    { SEQ is ON }
            if switch_MAIN.SEQ.combine = __SEQ_DUAL
                if fn051.a.side = __LEFT
                    UIID_MAIN.seq.flux_panels  [ fn051.a.side ] -> UI_SHOW
                    panel_MAIN.2SEQ.LEFT.controls -> UI_SHOW
                    // label_MAIN.2SEQ.LEFT.off      -> UI_SHOW
                else
                    UIID_MAIN.seq.flux_panels  [ fn051.a.side ] -> UI_SHOW
                    panel_MAIN.2SEQ.RIGHT.controls -> UI_SHOW
                    // label_MAIN.2SEQ.RIGHT.off      -> UI_SHOW
                end if
            else
                if fn051.a.side = __LEFT
                    UIID_MAIN.seq.flux_panels  [ __LEFT ] -> UI_SHOW
                    panel_MAIN.2SEQ.LEFT.controls         -> UI_SHOW
                    panel_MAIN.2SEQ.RIGHT.controls        -> UI_SHOW
                    label_MAIN.SEQjoin.off                -> UI_HIDE
                end if 
            end if

        end if
    else
        message(f'Layer state off!')
        if switch_MAIN.SEQ.combine = __SEQ_DUAL
            UIID_MAIN.seq.off_label      [ fn051.a.side ] -> UI_SHOW
            UIID_MAIN.seq.off_label_text [ fn051.a.side ] -> UI_SHOW
            UIID_MAIN.seq.off_label_text [ fn051.a.side ] -> text := 'LAYER OFF'
        else
            label_MAIN.2SEQ.LEFT.off  -> UI_SHOW
            label_MAIN.2SEQ.RIGHT.off -> UI_SHOW
        end if
    end if
end function

function fn052_set_wf_cursor_and_overlay
    UIID_MAIN.waveform_cursor [ fn052.a.side ] -> x := ...
        WF_CURSOR_PROPERTIES [ fn052.a.side ] +        ... { x initial pos depending on side + offset }
        int( fn052.a.value * WF_OVERLAY_WIDTH) 

    UIID_MAIN.waveform_overlay [ fn052.a.side ] -> width := int ( ...
        fn052.a.value * WF_OVERLAY_WIDTH ...
    )
end function

function fn053_update_single_shot_controls
    if UIID_MAIN.seq.power [ fn053.a.side ] -> value = __OFF

        UIID_MAIN.single_shot_controls [ fn053.a.side,  __SINGLE_SHOT_SAMPLE_START ] -> value := ...
            int ( sample_starts [ selected_source [ fn053.a.side ], fn053.a.side, fn053.a.note ] * 1000000.0 )

        fn052.a.side       := fn053.a.side
        fn052.a.value      := sample_starts [ selected_source [ fn053.a.side ], fn053.a.side, fn053.a.note ]
        if fn052.a.value > 0.995
            fn052.a.value := 0.995
        end if
        call fn052_set_wf_cursor_and_overlay

        fn053.l.tune_knob := sample_tuning [ selected_source [ fn053.a.side ], fn053.a.side, fn053.a.note ]

        UIID_MAIN.single_shot_controls [ fn053.a.side,  __SINGLE_SHOT_TUNE ] -> value := ...
            int((1000000.0 * fn053.l.tune_knob)/72.0 + 500000.0)
    end if
end function

function fn054_update_source_buttons
    for fn054.l.counter := 0 to 17
        if source_page [ fn054.a.side ] * 18 + fn054.l.counter < __SOURCE_COUNT
            UIID_BROWSER_source.select.btn [ fn054.a.side, fn054.l.counter ] -> UI_SHOW
            UIID_BROWSER_source.select.btn [ fn054.a.side, fn054.l.counter ] -> value := __OFF
            UIID_BROWSER_source.select.btn [ fn054.a.side, fn054.l.counter ] -> text := f'<source_page [ fn054.a.side ] * 18 + fn054.l.counter + 1>. Coefficient Preset'
            if fn054.l.counter = fn054.a.index mod __MAX_SOURCES_PER_PAGE
                UIID_GLOBAL.source_btns [ fn054.a.side ] -> text := f'<source_page [ fn054.a.side ] * 18 + fn054.l.counter + 1>. Coefficient Preset'
            end if
        else
            UIID_BROWSER_source.select.btn [ fn054.a.side, fn054.l.counter ] -> UI_HIDE
        end if
    end for
    
    if fn054.a.index # -1
        UIID_BROWSER_source.select.btn [ fn054.a.side, fn054.a.index ] -> value := __ON
    end if
end function

{ not used anymore, using a dropdown menu now }
function fn055_recall_source_buttons_page
    for fn055.l.counter := __LEFT to __RIGHT
        source_page [ fn055.l.counter ] := selected_source [ fn055.l.counter ] / __MAX_SOURCES_PER_PAGE
        fn054.a.index := selected_source [ fn055.l.counter ] mod __MAX_SOURCES_PER_PAGE
        fn054.a.side  := fn055.l.counter
        call fn054_update_source_buttons
        UIID_GLOBAL.page_number [ fn055.l.counter ] -> text := (selected_source [ fn055.l.counter ] / __MAX_SOURCES_PER_PAGE) + 1
    end for
end function

function fn057_hide_seq_join_steps_leds_counters
    for fn057.l.counter := 0 to 31
        UIID_MAIN.seq.step [ __LEFT,  fn057.l.counter ] -> hide := HIDE_WHOLE_CONTROL * fn057.a.hide
        UIID_MAIN.seq.step [ __RIGHT, fn057.l.counter ] -> hide := HIDE_WHOLE_CONTROL * fn057.a.hide
    end for
    for fn057.l.counter := 0 to 3
        UIID_MAIN.seq.leds        [ __LEFT,  fn057.l.counter ] -> hide := HIDE_WHOLE_CONTROL * fn057.a.hide
        UIID_MAIN.seq.block_steps [ __RIGHT, fn057.l.counter ] -> hide := HIDE_WHOLE_CONTROL * fn057.a.hide
    end for
end function

function fn060_set_filters_bypas_state
    for fn060.l.counter := 0 to __SOURCE_COUNT - 1
        { set LP's bypass state }
        set_engine_par(                                      ...
            ENGINE_PAR_EFFECT_BYPASS,                        ...
            fn060.a.seq_power_state,                         ...
            fn060.l.counter + fn060.a.side * __SOURCE_COUNT, ...
            __GROUP_LEVEL_LP_FILTER_SLOT,                    ...
            __GROUP_LEVEL                                    ...
        )
        { set HP's bypass state }
        set_engine_par(                                      ...
            ENGINE_PAR_EFFECT_BYPASS,                        ...
            fn060.a.seq_power_state,                         ...
            fn060.l.counter + fn060.a.side * __SOURCE_COUNT, ...
            __GROUP_LEVEL_HP_FILTER_SLOT,                    ...
            __GROUP_LEVEL                                    ...
        )
        
    end for
    set_engine_par(ENGINE_PAR_EFFECT_BYPASS, abs(1-fn060.a.seq_power_state), __GROUP_NONE, __SLOT_B_LOPASS, NI_BUS_OFFSET+fn060.a.side)
    set_engine_par(ENGINE_PAR_EFFECT_BYPASS, abs(1-fn060.a.seq_power_state), __GROUP_NONE, __SLOT_B_HIPASS, NI_BUS_OFFSET+fn060.a.side)
end function


{{ RANDOMIZER FUNCTIONS }}
function randomize_step_count
    if UIID_MAIN.seq.step_lock [ uics_side_counter ] -> value = __OFF
        for uics_counter := 0 to 3
            for uics_counter2 := __LEFT to __RIGHT
                if switch_MAIN.SEQ.combine = __SEQ_DUAL
                    uics_dual_join_side := uics_side_counter
                else
                    uics_dual_join_side := uics_counter2
                end if

                if  switch_MAIN.SEQ.combine = __SEQ_DUAL and uics_counter2 = __LEFT or ...
                    switch_MAIN.SEQ.combine = __SEQ_JOIN

                    uics_current_value := UIID_MAIN.seq.block_steps [ uics_dual_join_side, uics_counter ] -> value
                    uics_random_delta  := int(float(random (-7, 7)) * uics_r_value)
                   
                    UIID_MAIN.seq.block_steps [ uics_dual_join_side, uics_counter ] -> value := uics_random_delta + uics_current_value
                    SEQ.DUAL.step_count       [ uics_dual_join_side, uics_counter ]          := uics_random_delta + uics_current_value
                    SEQ.JOIN.step_count       [ uics_dual_join_side * 4 + uics_counter ]     := uics_random_delta + uics_current_value
                    
                    if uics_current_value + uics_random_delta > 7 
                        UIID_MAIN.seq.block_steps [ uics_dual_join_side, uics_counter ]      -> value := 7
                        SEQ.DUAL.step_count       [ uics_dual_join_side, uics_counter ]               := 7
                        SEQ.JOIN.step_count       [ uics_dual_join_side * 4 + uics_counter ]          := 7
                    else
                        if uics_current_value + uics_random_delta < 0
                            UIID_MAIN.seq.block_steps [ uics_dual_join_side, uics_counter ] -> value := 0
                            SEQ.DUAL.step_count       [ uics_dual_join_side, uics_counter ]               := 0
                            SEQ.JOIN.step_count       [ uics_dual_join_side * 4 + uics_counter ]          := 0
                        end if
                    end if

                    fn003.a.side        := uics_dual_join_side
                    fn003.a.mode        := switch_MAIN.SEQ.combine
                    fn003.a.block_index := uics_counter
                    call fn003_set_block_step_count
                end if

            end for
        end for
    end if
end function

function randomize_step_values
    for uics_counter := 0 to 3
        for uics_counter2 := 0 to 7
            uics_current_value.r := ...
                SEQ.data.f [                              ...
                    uics_side_counter,                        ...
                    SEQ.showing_target [ uics_side_counter ], ...
                    uics_counter * 8 + uics_counter2      ...
                ]

            uics_random_delta.r := (float(random(-10000,10000))/10000.0) * uics_r_value

            SEQ.data.f [                                  ...
                    uics_side_counter,                        ...
                    SEQ.showing_target [ uics_side_counter ], ...
                    uics_counter * 8 + uics_counter2      ...
                ] := uics_current_value.r + uics_random_delta.r

            { clamping values out of range }
            if uics_current_value.r + uics_random_delta.r > 1.0
                SEQ.data.f [                              ...
                    uics_side_counter,                        ...
                    SEQ.showing_target [ uics_side_counter ], ...
                    uics_counter * 8 + uics_counter2      ...
                ] := 1.0

            else
                if uics_current_value.r + uics_random_delta.r < 0.0
                    SEQ.data.f [                              ...
                        uics_side_counter,                        ...
                        SEQ.showing_target [ uics_side_counter ], ...
                        uics_counter * 8 + uics_counter2      ...
                    ] := 0.0
                end if

            end if

            fn018.a.side       := uics_side_counter
            fn018.a.step_index := uics_counter * 8 + uics_counter2
            fn018.a.value      :=                         ...
                SEQ.data.f [                              ...
                    uics_side_counter,                        ...
                    SEQ.showing_target [ uics_side_counter ], ...
                    uics_counter * 8 + uics_counter2      ...
                ]
            call fn018_set_seq_step_picture_state

            fn002.a.side            := uics_side_counter
            fn002.a.value           := fn018.a.value
            fn002.a.target          := SEQ.showing_target [ uics_side_counter ]
            fn002.a.table_to_update := __SEQ_DYN_TRANSF_TABLE
            fn002.a.step_index      := uics_counter * 8 + uics_counter2
            call fn002_set_seq_step_value
        end for
    end for
end function

function fn058_clamp_value
    fn058.r.int_clamped_value := fn058.a.int_value
    if fn058.a.int_value > fn058.a.int_clamp_max
        fn058.r.int_clamped_value := fn058.a.int_clamp_max
        exit
    end if
    if fn058.a.int_value < fn058.a.int_clamp_min
        fn058.r.int_clamped_value := fn058.a.int_clamp_min
        exit
    end if

    fn058.r.float_clamped_value := fn058.a.float_value
    if fn058.a.float_value > fn058.a.float_clamp_max
        fn058.r.float_clamped_value := fn058.a.float_clamp_max
        exit
    end if
    if fn058.a.float_value < fn058.a.float_clamp_min
        fn058.r.float_clamped_value := fn058.a.float_clamp_min
        exit
    end if
end function

function fn059_randomize_common_lfp
    for fn059.l.target_counter := fn059.a.target_start to fn059.a.target_end
        { LFO amount }
        fn059.l.lfo_amount := ...
            int ( float(random(-1000000,1000000)) * fn059.a.random_value) + ...
            UIID_controls_LFO_amount [ fn059.l.target_counter + uics_side_counter * __MAIN.FX.RIGHT.OFFSET ] -> value
        fn058.a.int_clamp_min := 0
        fn058.a.int_clamp_max := 1000000
        fn058.a.int_value     := fn059.l.lfo_amount
        call fn058_clamp_value
        UIID_controls_LFO_amount [ fn059.l.target_counter + uics_side_counter * __MAIN.FX.RIGHT.OFFSET ] -> value := fn058.r.int_clamped_value
        
        { LFO phase }
        UIID_controls_LFO_phase [ fn059.l.target_counter + uics_side_counter * __MAIN.FX.RIGHT.OFFSET ] -> value := random(0,1)

        { param value }
        fn036.a.side          := uics_side_counter
        fn036.a.target        := fn059.l.target_counter + uics_side_counter * __MAIN.FX.RIGHT.OFFSET
        fn036.a.control_value := ...
            get_engine_par(...
                LFO_targets_engine_pars [ fn059.l.target_counter ],          ...
                0, ... // LFO_targets_GROUP [ fn059.l.target_counter ],                ... { test }
                LFO_targets_SLOT  [ fn059.l.target_counter ],                ...
                LFO_targets_BUS   [ fn059.l.target_counter ] + uics_side_counter ...
            )
        fn036.a.control_value := int ( float(random(-1000000,1000000)) * fn059.a.random_value) + fn036.a.control_value

        fn058.a.int_clamp_min := 0
        fn058.a.int_clamp_max := 1000000
        fn058.a.int_value     := fn036.a.control_value
        call fn058_clamp_value
        fn036.a.control_value := fn058.r.int_clamped_value

        UIID_controls [ fn059.l.target_counter + uics_side_counter * __MAIN.FX.RIGHT.OFFSET ] -> value := fn058.r.int_clamped_value
        call fn036_set_control_param_slider()
    end for 
end function

function randomize_lfp_saturation
    fn059.a.random_value := uics_r_value { assuming we will only call this function from the randomizer control callback }
    fn059.a.target_start := __MAIN.FX.SATURATION
    fn059.a.target_end   := __MAIN.FX.SATURATION
    call fn059_randomize_common_lfp

    fn048.a.index := random(0,2)
    fn048.a.side  := uics_side_counter
    call fn048_set_fx_saturation_mode

    set_engine_par(                           ...
        ENGINE_PAR_SHAPE_TYPE,                ...
        FX_saturation_type [ fn048.a.index ], ...
        0,                                    ... { PENDING this is a test group }
        __SLOT_G_SATURATION,                  ...
        __GROUP_LEVEL                         ...
    )
end function

function randomize_lfp_distortion
    fn059.a.random_value := uics_r_value { assuming we will only call this function from the randomizer control callback }
    fn059.a.target_start := __MAIN.FX.DISTORTION.DAMP
    fn059.a.target_end   := __MAIN.FX.DISTORTION.DRIVE
    call fn059_randomize_common_lfp

    uics_random_value := random(0,1)
    UIID_lfp_dst_modes [ uics_side_counter ] -> value := uics_random_value

    set_engine_par(                               ...
        ENGINE_PAR_DISTORTION_TYPE,               ...
        FX_distortion_type [ uics_random_value ], ...
        0,                                        ... { PENDING temp group }
        __SLOT_G_DISTORTION,                      ...
        __GROUP_LEVEL                             ...
    )
end function

function randomize_lfp_lofi
    fn059.a.random_value := uics_r_value { assuming we will only call this function from the randomizer control callback }
    fn059.a.target_start := __MAIN.FX.LOFI.BITS
    fn059.a.target_end   := __MAIN.FX.LOFI.NOISE
    call fn059_randomize_common_lfp

    uics_value := ...
            int ( float(random(-1000000,1000000)) * uics_r_value) + UIID_lfp_lofi_noise [ uics_side_counter ] -> value
    fn058.a.int_clamp_min := 0
    fn058.a.int_clamp_max := 1000000
    fn058.a.int_value     := uics_value
    call fn058_clamp_value
    { set the UI knob value }
    UIID_lfp_lofi_noise [ uics_side_counter ] -> value := fn058.r.int_clamped_value
    { set the engine par value }
    set_engine_par(ENGINE_PAR_NOISECOLOR, fn058.r.int_clamped_value, __GROUP_NONE, __SLOT_B_LOFI, NI_BUS_OFFSET+uics_side_counter)
end function

function randomize_lfp_tapesat
    fn059.a.random_value := uics_r_value { assuming we will only call this function from the randomizer control callback }
    fn059.a.target_start := __MAIN.FX.TAPESAT.GAIN
    fn059.a.target_end   := __MAIN.FX.TAPESAT.WARMTH
    call fn059_randomize_common_lfp

    uics_value := ...
            int ( float(random(-1000000,1000000)) * uics_r_value) + UIID_lfp_tape_sat.hf_cut [ uics_side_counter ] -> value
    fn058.a.int_clamp_min := 0
    fn058.a.int_clamp_max := 1000000
    fn058.a.int_value     := uics_value
    call fn058_clamp_value
    { set the UI knob value }
    UIID_lfp_tape_sat.hf_cut [ uics_side_counter ] -> value := fn058.r.int_clamped_value
    { set the engine par value }
    set_engine_par(ENGINE_PAR_TP_HF_ROLLOFF, fn058.r.int_clamped_value, __GROUP_NONE, __SLOT_B_TAPESAT, NI_BUS_OFFSET+uics_side_counter)
end function

function randomize_lfp_delay
    uics_slot    := __SLOT_B_DELAY
    uics_generic := NI_BUS_OFFSET+uics_seq_side

    { ping pong }
    uics_random_value := random(0,1)
    UIID_lfp_delay_controls [ uics_side_counter, __FX_DELAY_PINGPONG ] -> value := uics_random_value { set ui control value }

    set_engine_par(                                  ...
        FX_delay_engine_par [ __FX_DELAY_PINGPONG ], ...
        uics_random_value,                           ...
        __GROUP_NONE,                                ...
        uics_slot,                                   ...
        uics_generic                                 ...
    )

    { lo / hi cut / feedback }
    for uics_counter := __FX_DELAY_LOCUT to __FX_DELAY_FEEDBACK
        uics_value := ...
                int ( float(random(-1000000,1000000)) * uics_r_value) + UIID_lfp_delay_controls [ uics_side_counter, uics_counter ] -> value
        fn058.a.int_clamp_min := 0
        fn058.a.int_clamp_max := 1000000
        fn058.a.int_value     := uics_value
        call fn058_clamp_value
        { set the UI knob value }
        UIID_lfp_delay_controls [ uics_side_counter, uics_counter ] -> value := fn058.r.int_clamped_value
        { set the engine par value }
        set_engine_par(                               ...
            FX_delay_engine_par [ uics_counter ], ...
            uics_value,                               ...
            __GROUP_NONE,                             ...
            __SLOT_B_DELAY,                           ...
            NI_BUS_OFFSET+uics_seq_side               ...
        )
    end for

    { dry / wet - only wet really  }
    uics_value := ...
            int ( float(random(-1000000,1000000)) * uics_r_value) + UIID_lfp_delay_controls [ uics_side_counter, __FX_DELAY_DRYWET ] -> value
    fn058.a.int_clamp_min := 0
    fn058.a.int_clamp_max := 1000000
    fn058.a.int_value     := uics_value
    call fn058_clamp_value
    { set the UI knob value }
    UIID_lfp_delay_controls [ uics_side_counter, __FX_DELAY_DRYWET ] -> value := fn058.r.int_clamped_value
    { set the engine par value }
    set_engine_par(                          ...
        ENGINE_PAR_SEND_EFFECT_OUTPUT_GAIN,  ...
        uics_value,                          ...
        __GROUP_NONE,                        ...
        __SLOT_B_DELAY,                      ...
        NI_BUS_OFFSET+uics_side_counter      ...
    )

    { time }
    uics_value := ...
            int ( float(random(-1000000,1000000)) * uics_r_value) + UIID_lfp_delay_controls [ uics_side_counter, __FX_DELAY_TIME ] -> value
    fn058.a.int_clamp_min := 0
    fn058.a.int_clamp_max := 1000000
    fn058.a.int_value     := uics_value
    call fn058_clamp_value
    { set the UI knob value }
    UIID_lfp_delay_controls [ uics_side_counter, __FX_DELAY_DRYWET ] -> value := fn058.r.int_clamped_value
    { set the engine par value }
    if  get_engine_par(                     ...
            ENGINE_PAR_RDL_TIME_UNIT,       ...
            __GROUP_NONE,                   ...
            __SLOT_B_DELAY,                 ...
            NI_BUS_OFFSET+uics_side_counter ...
        ) = NI_SYNC_UNIT_ABS

        set_engine_par(                     ...
            ENGINE_PAR_RDL_TIME,            ...
            uics_value,                     ...
            __GROUP_NONE,                   ...
            __SLOT_B_DELAY,                 ...
            NI_BUS_OFFSET+uics_side_counter ...
        )

    else
        set_engine_par(                                            ...
            ENGINE_PAR_RDL_TIME_UNIT,                              ...
            fx_delay_units [ uics_value / FX_DELAY_SYNC_DIVISOR ], ...
            __GROUP_NONE,                                          ...
            __SLOT_B_DELAY,                                        ...
            NI_BUS_OFFSET+uics_side_counter                        ...
        )
        set_engine_par(                                           ...
            ENGINE_PAR_RDL_TIME,                                  ...
            fx_delay_sync [ uics_value / FX_DELAY_SYNC_DIVISOR ], ...
            __GROUP_NONE,                                         ...
            __SLOT_B_DELAY,                                       ...
            NI_BUS_OFFSET+uics_side_counter                       ...
        )

    end if

    { sync, depends on time control value }
    uics_random_value := random(0,1)
    UIID_lfp_delay_controls [ uics_side_counter, __FX_DELAY_TIME_UNIT ] -> value := uics_random_value { set ui control value }
    if  uics_random_value = __OFF
        { ms }
        set_engine_par(ENGINE_PAR_RDL_TIME_UNIT, NI_SYNC_UNIT_ABS, __GROUP_NONE, uics_slot, uics_generic)
    else
        set_engine_par(               ...
            ENGINE_PAR_RDL_TIME_UNIT, ...
            fx_delay_units [ (UIID_lfp_delay_controls [ uics_side_counter, __FX_DELAY_TIME ] -> value)/FX_DELAY_SYNC_DIVISOR ], ...
            __GROUP_NONE,             ...
            uics_slot,                ...
            uics_generic              ...
        )
        set_engine_par(               ...
            ENGINE_PAR_RDL_TIME, ...
            fx_delay_sync [ (UIID_lfp_delay_controls [ uics_side_counter, __FX_DELAY_TIME ] -> value)/FX_DELAY_SYNC_DIVISOR ], ...
            __GROUP_NONE,             ...
            uics_slot,                ...
            uics_generic              ...
        )
    end if
end function

function randomize_lfp_chorus
    fn059.a.random_value := uics_r_value { assuming we will only call this function from the randomizer control callback }
    fn059.a.target_start := __MAIN.FX.CHORUS.DRYWET
    fn059.a.target_end   := __MAIN.FX.CHORUS.PHASE
    call fn059_randomize_common_lfp
end function

function randomize_lfp_reverb
    fn059.a.random_value := uics_r_value { assuming we will only call this function from the randomizer control callback }
    fn059.a.target_start := __MAIN.FX.REVERB.DRYWET
    fn059.a.target_end   := __MAIN.FX.REVERB.DRYWET
    call fn059_randomize_common_lfp

    { dry / wet - only wet really  }
    uics_value := ...
            int ( float(random(-1000000,1000000)) * uics_r_value) + UIID_lfp_rvb_controls [ uics_side_counter, __FX_REVERB_PREDELAY ] -> value
    fn058.a.int_clamp_min := 0
    fn058.a.int_clamp_max := 1000000
    fn058.a.int_value     := uics_value
    call fn058_clamp_value
    { set the UI knob value }
    UIID_lfp_rvb_controls [ uics_side_counter, __FX_REVERB_PREDELAY ] -> value := fn058.r.int_clamped_value
    { set the engine par value }
    set_engine_par(                     ...
        ENGINE_PAR_IRC_PREDELAY,        ...
        uics_value,                     ...
        __GROUP_NONE,                   ...
        __SLOT_B_REVERB,                ...
        NI_BUS_OFFSET+uics_side_counter ...
    )
    { size, lp, hp for early and long reflections }
    for uics_counter := 1 to 3 { uiid indices }
        uics_value := ...
                int ( float(random(-1000000,1000000)) * uics_r_value) + UIID_lfp_rvb_controls [ uics_side_counter, uics_counter ] -> value
        fn058.a.int_clamp_min := 0
        fn058.a.int_clamp_max := 1000000
        fn058.a.int_value     := uics_value
        call fn058_clamp_value
        { set the UI knob value }
        UIID_lfp_rvb_controls [ uics_side_counter, uics_counter ] -> value := fn058.r.int_clamped_value
        { set the engine par value }
        set_engine_par(                         ...
            FX_reverb_engine_par[uics_counter], ...
            uics_value,                         ...
            __GROUP_NONE,                       ...
            __SLOT_B_REVERB,                    ...
            NI_BUS_OFFSET+uics_side_counter     ...
        )
        set_engine_par(                           ...
            FX_reverb_engine_par[uics_counter+3], ...
            uics_value,                           ...
            __GROUP_NONE,                         ...
            __SLOT_B_REVERB,                      ...
            NI_BUS_OFFSET+uics_side_counter       ...
        )
    end for
end function

{{ LFO Functions }}
function fn037_LFO.update_intensity_ring()
    message("CALL fn037 __________________________________________ ")
    message("    target = " & fn037.a.target)
    message("    fn037.a.control_value = " & fn037.a.control_value)

    if fn037.a.target < 32 and fn037.a.target mod 16 = __MAIN.FX.LAYER.WIDTH
        fn037.l.picture_state_start := ...
            int ( ...
                    127.0 - ( ...
                        float ( fn037.a.control_value ) / 1000000.0 ...
                    * ...
                        float   ( get_control_par( ... 
                                    UIID_controls_LFO_amount[ fn037.a.target ], ...
                                    CONTROL_PAR_VALUE ...
                                ) ...
                        ) / 1000000.0 ...
                    ) * 127.0 ...
            )

        fn037.l.picture_state_end := fn037.l.picture_state_start
    else { all other controls }
        fn037.l.picture_state_start := ... 
            int ( ...
                    ( ...
                        float ( fn037.a.control_value ) / 1000000.0 ...
                        - ...
                        float   ( get_control_par( ... 
                                    UIID_controls_LFO_amount[ fn037.a.target  ], ...
                                    CONTROL_PAR_VALUE ...
                                ) / 2 ...
                        ) / 1000000.0 ...
                    ) * 255.0 ...
            )

        fn037.l.picture_state_end := ... 
            int ( ...
                    ( ...
                        (1.0 - float( fn037.a.control_value ) / 1000000.0 ) ...
                        - ...
                        float ( get_control_par( ... 
                                    UIID_controls_LFO_amount[ fn037.a.target ], ...
                                    CONTROL_PAR_VALUE ...
                                ) / 2 ...
                        ) / 1000000.0 ...
                    ) * 255.0 ...
            )
    end if 
    set_control_par (                                   ...
        UIID_controls_LFO_mod_start [ fn037.a.target ], ...
        CONTROL_PAR_PICTURE_STATE,                      ...
        fn037.l.picture_state_start                     ...
    )

    set_control_par (                                 ...
        UIID_controls_LFO_mod_end [ fn037.a.target ], ...
        CONTROL_PAR_PICTURE_STATE,                    ...
        fn037.l.picture_state_end                     ...
    )
    message(f'     fn037.l.picture_state_start:< fn037.l.picture_state_start >')
    message(f'     fn037.l.picture_state_end  :< fn037.l.picture_state_end >')

    if fn037.a.link = __ON
        message("link is on - updating both blue rings masks")
        if fn037.a.target < 16 { left side }
            MAIN.FX.aux_flip_side := 16 { add 16 to get to right side }
        else                                                    { right side }
            MAIN.FX.aux_flip_side := -16 { subtract 16 to get to left side }
        end if

        set_control_par (...
            UIID_controls_LFO_mod_start [ fn037.a.target + MAIN.FX.aux_flip_side  ], ...
            CONTROL_PAR_PICTURE_STATE, ...
            fn037.l.picture_state_start ...
        )

        set_control_par (...
            UIID_controls_LFO_mod_end [ fn037.a.target + MAIN.FX.aux_flip_side  ], ...
            CONTROL_PAR_PICTURE_STATE, ...
            fn037.l.picture_state_end ...
        )
    end if
    // message(...
    //     "fn037.l.picture_state_start  = " & fn037.l.picture_state_start & ...
    //     " | fn037.l.picture_state_end  = " & fn037.l.picture_state_end ...
    // )
end function

function fn038_LFO_store_LFO_mod_data()
    // message("CALLED FN038 store data for target "&fn038.a.target&" ________________________________________________ ")
    { using this loop to avoid writing this code twice because of the link }
    for fn038.l.counter := 0 to 1
        // message("fn038.l.counter = " & fn038.l.counter & " | fn038.a.link = " & fn038.a.link & " | " & fn038.a.target + MAIN.FX.aux_flip_side)
        
        if (fn038.l.counter = 1 and fn038.a.link = 1) or fn038.l.counter = 0
            // message("    capturing data")
            if fn038.l.counter = 0 
                MAIN.FX.aux_flip_side := 0 { first cycle we go unchanged on target value }
            end if

            LFO_amount_pct [ fn038.a.target + MAIN.FX.aux_flip_side ] := float( fn038.a.LFO_amount ) / 1000000.0

            LFO_mod_center  := float( fn038.a.control_value )

            LFO_mod_amount  := float( LFO_control_value_max [ fn038.a.target + MAIN.FX.aux_flip_side ] ) * ...
                LFO_amount_pct [ fn038.a.target + MAIN.FX.aux_flip_side ] 

            LFO_mod_min     := LFO_mod_center - LFO_mod_amount
            LFO_mod_max     := LFO_mod_center + LFO_mod_amount

            { for the rebel way on the mod ring animation | 3921 = 1000000/255 }
            LFO_mod_ring_center := int(LFO_mod_center / 3921.568627)
            LFO_mod_ring_min    := int(LFO_mod_min / 3921.568627)
            LFO_mod_ring_max    := int(LFO_mod_max / 3921.568627)

            LFO_modulation_data [ fn038.a.target + MAIN.FX.aux_flip_side, __LFO_TARGET_CONTROL_VALUE ]     := LFO_mod_center
            LFO_modulation_data [ fn038.a.target + MAIN.FX.aux_flip_side, __LFO_TARGET_CONTROL_VALUE_PCT ] := LFO_mod_center / 1000000.0
            LFO_modulation_data [ fn038.a.target + MAIN.FX.aux_flip_side, __LFO_MOD_MIN ]                  := LFO_mod_min
            LFO_modulation_data [ fn038.a.target + MAIN.FX.aux_flip_side, __LFO_MOD_MAX ]                  := LFO_mod_max

            LFO_modulation_ring_data [ fn038.a.target + MAIN.FX.aux_flip_side, __LFO_TARGET_CONTROL_VALUE ] := LFO_mod_ring_center
            LFO_modulation_ring_data [ fn038.a.target + MAIN.FX.aux_flip_side, __LFO_MOD_MIN ]              := LFO_mod_ring_min   
            LFO_modulation_ring_data [ fn038.a.target + MAIN.FX.aux_flip_side, __LFO_MOD_MAX ]              := LFO_mod_ring_max   
        end if

        { sets the flip variable for the next loop cycle }
        if fn038.a.link = __ON
            { store the data on the other side too }
            if fn038.a.side = __LEFT
                MAIN.FX.aux_flip_side := 16 { add 16 to get to right side }
            else                                                    { right side }
                MAIN.FX.aux_flip_side := -16 { subtract 16 to get to left side }
            end if
        end if
    end for
end function

function fn039_set_FX_engine_par()
    message(f'FN39 value: <fn039.a.control_value >')
    message(f'    target engine par: <LFO_targets_engine_pars [ fn039.a.target mod 16 ] >')
    message(f'    ENGINE_PAR_VOLUME: <LFO_targets_engine_pars [ fn039.a.target mod 16 ] >')
    set_engine_par(...
        LFO_targets_engine_pars [ fn039.a.target mod 16 ],         ...
        fn039.a.control_value,                                     ...
        LFO_targets_GROUP [ fn039.a.side, fn039.a.target mod 16 ], ...
        LFO_targets_SLOT  [ fn039.a.target mod 16 ],               ...
        LFO_targets_BUS   [ fn039.a.target mod 16 ] + fn039.a.side ...
    )
    if fn039.a.link = 1
        fn039.a.side := abs( 1 - fn039.a.side) { flip to get the other side }
        set_engine_par(...
            LFO_targets_engine_pars [ fn039.a.target  mod 16 ],        ...
            fn039.a.control_value,                                     ...
            LFO_targets_GROUP [ fn039.a.side, fn039.a.target mod 16 ], ...
            LFO_targets_SLOT  [ fn039.a.target mod 16 ],               ...
            LFO_targets_BUS   [ fn039.a.target mod 16 ] + fn039.a.side ...
        )
    end if
end function

function fn040_set_MATRIX_slider_ps // picture state
    if fn040.a.side = __LEFT
        label_MAIN.matrix.centerLR -> picture_state := 255 - int( float(slider_MAIN.FX.LEFT.layer.volume) * 0.000001 * 255.0)
        label_MAIN.matrix.left     -> picture_state := int( float(slider_MAIN.FX.LEFT.layer.volume) * 0.000001 * 255.0)
        // label_MATRIX.matrix.centerLR -> picture_state := 255 - (slider_MAIN.FX.LEFT.layer.volume / 3921)
    else
        label_MAIN.matrix.centerRL -> picture_state := int( float(slider_MAIN.FX.RIGHT.layer.volume) * 0.000001 * 255.0)
        label_MAIN.matrix.right    -> picture_state := int( float(slider_MAIN.FX.RIGHT.layer.volume) * 0.000001 * 255.0)
        // label_MATRIX.matrix.centerRL -> picture_state := slider_MAIN.FX.RIGHT.layer.volume / 3921
    end if
end function

function fn041_LFO_off_restore_buffer_value()
    message(f'FN 41 called ')
    fn041.l.target := fn041.a.target + fn041.a.side * __MAIN.FX.RIGHT.OFFSET
    message(f'    fn041.l.target: <fn041.l.target>')
    message(f'    fn041.a.target: <fn041.a.target>')

    if  UIID_controls_LFO_power [ fn041.l.target ] -> value = __OFF or ...
        switch_MAIN.LFO.power = __OFF

        set_engine_par(                                                                 ...
            LFO_targets_engine_pars  [ fn041.a.target ],                                ...
            int( LFO_modulation_data [ fn041.a.target , __LFO_TARGET_CONTROL_VALUE ] ), ...
            LFO_targets_GROUP        [ fn041.a.side, fn041.a.target ],                  ...
            LFO_targets_SLOT         [ fn041.a.target ],                                ...
            LFO_targets_BUS          [ fn041.a.target ] + fn041.a.side                  ...
        )

        set_control_par(                                    ...
            UIID_controls_LFO_mod_cursor[ fn041.l.target ], ...
            CONTROL_PAR_PICTURE_STATE,                      ...
            0                                               ...
        )
    end if
end function

function fn044_LFO_calculate_engine_value()
    // message("CALLED FN044 - Target: " & fn044.a.target)
    { for cleanliness }
    LFO_engine_min := LFO_modulation_data [ fn044.a.target, __LFO_MOD_MIN ]
    LFO_engine_max := LFO_modulation_data [ fn044.a.target, __LFO_MOD_MAX ]
    LFO_depth_offset := (LFO_engine_max-LFO_engine_min)*(1.0-GLOBAL_LFO.depth_float_pct)

    { PENDING, review as our LFO values now go from -1 to 1  }
    { rebel way, that goes over the max and min }
    fn044.l.calc := ...
        ( LFO_engine_max - LFO_engine_min ) * fn044.a.sine_value * GLOBAL_LFO.depth_float_pct +  ...
        (LFO_depth_offset / 2.0) + LFO_engine_min

    { debug }
        // if LFO_lcb_rate_ms_counter mod 250 = 0 and print_sine_lcb = 1
        //     message("fn044: target " & fn044.a.target &  ...
        //         " | fn044.a.sine_value = " & fn044.a.sine_value)
        //     message(...
        //         " Max = " & LFO_engine_max & ...  
        //         " | Min = " & LFO_engine_min & ...  
        //         " | d = " & LFO_depth_offset & ... 
        //         " | v = " & int(fn044.l.calc) ...
        //     )
        // end if

    { smooth way, only to the max / min ranges }
        // fn044.l.calc := ... 
        //     (LFO_sine_value * LFO_amount_pct [ __MAIN.FX.SATURATION ] * 1000000.0) + ... { offset }
        //     (LFO_modulation_data [ fn002.a.target, __LFO_TARGET_CONTROL_VALUE_PCT ] - ...
        //     LFO_modulation_data [ fn002.a.target, __LFO_TARGET_CONTROL_VALUE_PCT ] * ...
        //     LFO_amount_pct [ __MAIN.FX.SATURATION ]) * 1000000.0

    { almost sure it is only needed on the rebel way }
    fn044.r.engine_value := int(fn044.l.calc)
    if fn044.l.calc < 0.0 
        fn044.r.engine_value := 0
    end if
    if fn044.l.calc > 1000000.0 
        fn044.r.engine_value := 1000000
    end if
    // if lcb_control_counter = 1//__MAIN.FX.LAYER.WIDTH
    //     if lcb_ms_counter mod 250 = 0
    //         message(f'fn044.r.engine_value <fn044.r.engine_value >')
    //         message(f' LFO_engine_min < LFO_engine_min >')
    //         message(f' LFO_engine_max < LFO_engine_max >')
    //     end if
    // end if
end function

function fn046_set_lfo_depth_globally
    if fn046.a.caller = __LFO_AMOUNT_CONTROL
        fn046.l.global_value  := fn046.a.target_value
        slider_MAIN.LFO.depth := fn046.a.target_value
        message(f'FN46, LOCAL value: <slider_MAIN.LFO.depth>')
    else
        message(f'FN46, GLOBAL value: <slider_MAIN.LFO.depth>')
        fn046.l.global_value := slider_MAIN.LFO.depth
    end if
    message(f'    Target: < fn046.a.target >')
    for LFO.depth.lock_mode_counter := 0 to 31
        UIID_controls_LFO_amount [ LFO.depth.lock_mode_counter ] -> value := fn046.l.global_value
        fn037.a.target        := LFO.depth.lock_mode_counter
        fn037.a.control_value := UIID_controls [ fn037.a.target ] -> value
        fn037.a.LFO_amount    := fn046.l.global_value  { LFO amount value - global }
        call fn037_LFO.update_intensity_ring
        
        fn038.a.target        := fn037.a.target
        fn038.a.side          := fn037.a.side
        fn038.a.LFO_amount    := fn037.a.LFO_amount
        fn038.a.control_value := fn037.a.control_value { FX parameter value }
        call fn038_LFO_store_LFO_mod_data
    end for
    label_MAIN.LFO.visualRate  -> picture_state := ...
        (slider_MAIN.LFO.depth/31250) * 64 + int(float(slider_MAIN.LFO.rate)/2.539682)

    ~GLOBAL_LFO.depth_float_pct := float(slider_MAIN.LFO.depth)/1000000.0
        
    label_MAIN.LFO.depth -> text := slider_MAIN.LFO.depth / 10000 & "%"
end function

function fn047_update_all_lfo_controls_data_and_ui
    for fn047.l.counter := 0 to 31
        for fn047.l.side_counter := __LEFT to __RIGHT
            fn037.a.side          := fn047.l.side_counter
            fn037.a.target        := fn047.l.counter
            fn037.a.control_value := UIID_controls [ fn037.a.target ] -> value
            fn037.a.LFO_amount    := UIID_controls_LFO_amount [ fn047.l.counter ] -> value
            call fn037_LFO.update_intensity_ring
            
            fn038.a.side          := fn047.l.side_counter
            fn038.a.target        := fn037.a.target
            fn038.a.LFO_amount    := fn037.a.LFO_amount
            fn038.a.control_value := fn037.a.control_value { FX parameter value }
            call fn038_LFO_store_LFO_mod_data
        end for
    end for
end function

function update_lfo_aux_data
    { rate data updates }
    if switch_MAIN.LFO.sync = __SYNC_BEAT
        LFO_lcb_rate  := __RATE_ELEMENTS_COUNT - 1 - ( int(float(slider_MAIN.LFO.rate)/ __LFO_RATE_INDEX_DIVIDER))
        label_MAIN.LFO.rate -> text := beat_rates_display[ int(float(slider_MAIN.LFO.rate)/ __LFO_RATE_INDEX_DIVIDER) ]
        
        { setting the supporting variables for all waveforms at every call 
          this way we don't need to run this function again when the user 
          changes the waveform type }
        LFO_rate_cycles := LFO_rate // LFO.ms_rates[LFO_lcb_rate]/1000 { for rect and random waveforms }
        // LFO_tri_period  := float(LFO_rate)
        LFO_sine_step   := __TWO_PI / float(LFO_rate) //(float(LFO.ms_rates[ LFO_lcb_rate ])*0.001)

    else  { sync = HZ}
        if slider_MAIN.LFO.rate <= 100
            tau_hz_ms_rate_divisor := float(slider_MAIN.LFO.rate)/100.0
        else
            tau_hz_ms_rate_divisor := float(slider_MAIN.LFO.rate-100)
        end if
        // LFO_rate_pct := float(slider_MAIN.LFO.rate)*0.000001
        // if LFO_rate_pct < 0.5
        //     tau_hz_ms_rate_divisor := pow(4.0, LFO_rate_pct)-1.0
        //     if tau_hz_ms_rate_divisor < 0.01
        //         tau_hz_ms_rate_divisor := 0.01 { clamping the value, we don't want much slower than this }
        //     end if
        //     LFO_ms_rate_label_disp_value := round(tau_hz_ms_rate_divisor * 100.0)/100.0
        // else
        //     tau_hz_ms_rate_divisor := 59.0 * log2(LFO_rate_pct) + 60.0
        //     LFO_ms_rate_label_disp_value := round(tau_hz_ms_rate_divisor)
        // end if

        if slider_MAIN.LFO.rate <= 100
            label_MAIN.LFO.rate -> text := (float(slider_MAIN.LFO.rate)/100.0) & "hz"
        else
            label_MAIN.LFO.rate -> text := slider_MAIN.LFO.rate-100 & "hz"
        end if

        { same reason here as above }
        LFO_sine_step := __TWO_PI / (1000.0/tau_hz_ms_rate_divisor)
        LFO_rate_cycles := int((1.0 / tau_hz_ms_rate_divisor) * 1000.0) { for rect and random waveforms }
        // LFO_tri_period  := (1.0 / tau_hz_ms_rate_divisor) * 1000.0
    end if

    // LFO_tri_step    :=  1.0 / LFO_tri_period
end function

function UICBS_MAIN.FX.modules.power()
    { we have to check which side we are in, there problably could be a better way to do this. }
    // if uicbs_custom_id - UICTRL_FX_MODULES_POWER_OFFSET < 8
    //     uicbs_fx_panel_side := __LEFT
    // else
    //     uicbs_fx_panel_side := __RIGHT
    // end if

    // if  uicbs_custom_id - UICTRL_FX_MODULES_POWER_OFFSET # 0 or ...
    //     uicbs_custom_id - UICTRL_FX_MODULES_POWER_OFFSET # 8
    //     set_engine_par(...
    //         ENGINE_PAR_EFFECT_BYPASS, ...
    //         abs(1-uicbs_control_par_value), ...
    //         __GROUP_NONE, ...
    //         (uicbs_custom_id - UICTRL_FX_MODULES_POWER_OFFSET) mod 8, ...
    //         LFO_targets_BUS [ (uicbs_custom_id - UICTRL_FX_MODULES_POWER_OFFSET) mod 8 ] + uicbs_fx_panel_side)

    // end if
    // { if link is on, we have to power both sides }
    // if UIID_MAIN.FX.links [ ...
    //         uicbs_custom_id - UICTRL_FX_MODULES_POWER_OFFSET ...
    //     ] -> value = 1

    //     { to access the related pair on the other side of the calling control }
    //     if uicbs_custom_id - UICTRL_FX_MODULES_POWER_OFFSET < 8 { left side }
    //         MAIN.FX.aux_flip_link := 8 { add 8 to get to right side }
    //         MAIN.FX.aux_flip_bus  := 1
    //     else                                                    { right side }
    //         MAIN.FX.aux_flip_link := -8 { subtract 8 to get to left side }
    //         MAIN.FX.aux_flip_bus  := 0
    //     end if

    //     { UI control update on the other side }
    //     set_control_par( ...
    //         UIID_FX.modules.power [ ...
    //             uicbs_custom_id - UICTRL_FX_MODULES_POWER_OFFSET + MAIN.FX.aux_flip_link ...
    //         ], ...
    //         CONTROL_PAR_VALUE, ...
    //         uicbs_control_par_value ... 
    //     )

    //     { engine update for the other side }
    //     { not 0 or 8 because these are layer power, to be taken care somewhere else }
    //     if  uicbs_custom_id - UICTRL_FX_MODULES_POWER_OFFSET # 0 or ...
    //         uicbs_custom_id - UICTRL_FX_MODULES_POWER_OFFSET # 8
            
    //         set_engine_par(...
    //             ENGINE_PAR_EFFECT_BYPASS, ...
    //             abs(1-uicbs_control_par_value), ...
    //             __GROUP_NONE, ...
    //             (uicbs_custom_id - UICTRL_FX_MODULES_POWER_OFFSET) mod 8, ...
    //             LFO_targets_BUS [ ...
    //                 (uicbs_custom_id - UICTRL_FX_MODULES_POWER_OFFSET) mod 8 ...
    //             ] + MAIN.FX.aux_flip_bus ...
    //         )
    //     end if
    // end if
end function

function UICBS_MAIN.FX.modules.links()
    if uicbs_custom_id - UICTRL_FX_MODULES_LINK_OFFSET < 8 { left side }
        MAIN.FX.aux_flip_link := 8 { add 8 to get to right side }
    else
        MAIN.FX.aux_flip_link := -8 { subtract 8 to get to left side }
    end if
    { sets links on both sides to the same value }
    set_control_par( ...
        UIID_MAIN.FX.links [ ...
            uicbs_custom_id - UICTRL_FX_MODULES_LINK_OFFSET + MAIN.FX.aux_flip_link ...
        ], ...
        CONTROL_PAR_VALUE, ...
        uicbs_control_par_value ... 
    )
end function


{{ play engine ____________________________________________________________________ }}
{{ 7 }}
function fn007_update_block_and_steps_ts
    if switch_MAIN.SEQ.combine = __SEQ_DUAL

        { update current block index, current block step duration and 
          each step's timestamp }
        if  seq.direction_status [ fn007.a.side ] = SEQ_DIRECTION_FORWARD
            inc(SEQ.DUAL.current_block [ fn007.a.side ])

            { block start, update the flux values and UI }
            if SEQ.DUAL.current_block [ fn007.a.side ] > 3
                { check the actual selected direction button }
                if  layers.seq_play_direction [ fn007.a.side ] = SEQ_DIRECTION_FWBW
                    SEQ.DUAL.current_block [ fn007.a.side ] := 3
                    seq.direction_status [ fn007.a.side ] := SEQ_DIRECTION_BACKWARD
                else { regular forward motion }
                    SEQ.DUAL.current_block [ fn007.a.side ] := 0
                end if
            end if

            { Update step duration }
            SEQ.DUAL.step_duration [ fn007.a.side ] := ...
                SEQ.rate [ fn007.a.side ] / ( SEQ.DUAL.step_count [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ] ] + 1 )

            { Generate timestamps for each step in the block }
            for s.i := 0 to SEQ.DUAL.step_count [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ] ]
                if s.i > 0
                    SEQ.DUAL.steps_timestamps [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ], s.i ] := ...
                        ENGINE_UPTIME + s.i * SEQ.DUAL.step_duration [ fn007.a.side ] + ...
                        random(-SEQ.humanize [ fn007.a.side ], SEQ.humanize [ fn007.a.side ])
                else
                    SEQ.DUAL.steps_timestamps [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ], s.i ] := ...
                        ENGINE_UPTIME + s.i * SEQ.DUAL.step_duration [ fn007.a.side ]
                end if
            end for

        else
            if  seq.direction_status [ fn007.a.side ] = SEQ_DIRECTION_BACKWARD 
                dec(SEQ.DUAL.current_block [ fn007.a.side ])
                if SEQ.DUAL.current_block [ fn007.a.side ] < 0
                    if layers.seq_play_direction [ fn007.a.side ] = SEQ_DIRECTION_FWBW
                        SEQ.DUAL.current_block [ fn007.a.side ] := 0
                        seq.direction_status [ fn007.a.side ] := SEQ_DIRECTION_FORWARD
                    else { regular backward motion }
                        SEQ.DUAL.current_block [ fn007.a.side ] := 3 
                    end if
                end if

                SEQ.DUAL.step_duration [ fn007.a.side ] := ...
                    SEQ.rate [ fn007.a.side ] / ( SEQ.DUAL.step_count [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ] ] + 1 )

                for s.i := 0 to SEQ.DUAL.step_count [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ] ]
                    SEQ.DUAL.steps_timestamps [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ], s.i ] := ...
                        ENGINE_UPTIME + s.i * SEQ.DUAL.step_duration [ fn007.a.side ]
                end for
            end if

        end if

        if UIID_MAIN.seq.flux_rand_power [ fn007.a.side ] -> value = __ON
            {{ UPDATES WHOLE BLOCK FLUX DATA and UI STEPS ACCORDING TO FLUX RANDOMIZER INFLUENCE }}
            fn025.a.side := fn007.a.side
            call fn025_update_flux_on_all_block_steps
        end if

    else { JOIN sequencer }

        if  seq_join.direction_status = SEQ_DIRECTION_FORWARD

            inc(SEQ.JOIN.current_block )
            { block start, update the flux values and UI }
            if SEQ.JOIN.current_block > 7
                { check the actual selected direction button }
                if  layers.seq_join_play_direction = SEQ_DIRECTION_FWBW
                    SEQ.JOIN.current_block := 7
                    seq_join.direction_status := SEQ_DIRECTION_BACKWARD
                else { regular forward motion }
                    SEQ.JOIN.current_block := 0
                end if
            end if

            { Update step duration }
            SEQ.JOIN.step_duration := ...
                SEQ.rate [ __LEFT ] / ( SEQ.JOIN.step_count [ SEQ.JOIN.current_block ] + 1 )

            for s.i := 0 to SEQ.JOIN.step_count [ SEQ.JOIN.current_block ]
                // SEQ.JOIN.steps_timestamps [ SEQ.JOIN.current_block, s.i ] := ...
                //     ENGINE_UPTIME + s.i * SEQ.JOIN.step_duration

                if s.i > 0
                    SEQ.JOIN.steps_timestamps [ SEQ.JOIN.current_block, s.i ] := ...
                        ENGINE_UPTIME + s.i * SEQ.JOIN.step_duration + ...
                        random(-SEQ.humanize [ __LEFT ], SEQ.humanize [ __LEFT ])
                else
                    SEQ.JOIN.steps_timestamps [ SEQ.JOIN.current_block, s.i ] := ...
                        ENGINE_UPTIME + s.i * SEQ.JOIN.step_duration
                end if
            end for

        else { backwards }
            if  seq_join.direction_status = SEQ_DIRECTION_BACKWARD 
                dec(SEQ.JOIN.current_block)
                if SEQ.JOIN.current_block < 0
                    if layers.seq_join_play_direction = SEQ_DIRECTION_FWBW
                        SEQ.JOIN.current_block := 0
                        seq_join.direction_status := SEQ_DIRECTION_FORWARD
                    else { regular backward motion }
                        SEQ.JOIN.current_block := 7
                    end if
                end if

                SEQ.JOIN.step_duration := ...
                    SEQ.rate [ __LEFT ] / ( SEQ.JOIN.step_count [ SEQ.JOIN.current_block ] + 1 )

                for s.i := 0 to SEQ.JOIN.step_count [ SEQ.JOIN.current_block ]
                    SEQ.JOIN.steps_timestamps [ SEQ.JOIN.current_block, s.i ] := ...
                        ENGINE_UPTIME + s.i * SEQ.JOIN.step_duration
                end for
            end if

        end if

        if UIID_MAIN.seq.flux_rand_power [ __LEFT ] -> value = __ON
            {{ UPDATES WHOLE BLOCK FLUX DATA and UI STEPS ACCORDING TO FLUX RANDOMIZER INFLUENCE }}
            fn025.a.side := __FLUX_ON_ALL_BLOCKS
            call fn025_update_flux_on_all_block_steps
        end if

    end if 
end function

{ not really being used }
function fn023_check_block_start
    fn023.r.check := 0
    if fn023.a.counter = 0
        fn023.r.check := fn023.r.check .or. __STEP_COUNTER_0 // 1
    end if
    if UIID_MAIN.seq.direction_btns [ fn023.a.side, 0 ] -> value = __ON
        fn023.r.check := fn023.r.check .or. __DIR_BTN_FORWARD //2
    end if
    if UIID_MAIN.seq.direction_btns [ fn023.a.side, 1 ] -> value = __ON
        fn023.r.check := fn023.r.check .or. __DIR_BTN_BACKWARD //4
    end if
    if UIID_MAIN.seq.direction_btns [ fn023.a.side, 2 ] -> value = __ON
        fn023.r.check := fn023.r.check .or. __DIR_BTN_FWBW //8
    end if
    if SEQ.ts_counter = SEQ.DUAL.step_count [ fn023.a.side, SEQ.DUAL.current_block [ fn023.a.side ] ]
        fn023.r.check := fn023.r.check .or. __STEP_COUNTER_LAST //16
    end if
    if seq.direction_status [ fn023.a.side ] = SEQ_DIRECTION_FORWARD
        fn023.r.check := fn023.r.check .or. __DIR_PLAY_FORWARD //32
    end if
    if seq.direction_status [ fn023.a.side ] = SEQ_DIRECTION_BACKWARD
        fn023.r.check := fn023.r.check .or. __DIR_PLAY_BACKWARD //64
    end if
end function

{ this function will update the SEQ.data.flux.i/f arrays and the steps height on th UI in the current block }
{{ 24 }}
function fn024_update_flux_data_and_ui
    { at this moment (03/2025) the velocity is the only parameter
     being affected by the dynamic slider }
    {{ VELOCITY }}
    fn033.a.dyn_value := ...
        get_control_par_real_arr(                       ...
            UIID_MAIN.seq.dyn_slider [ fn024.a.side ], ...
            CONTROL_PAR_VALUE,                         ...
            __Y_AXIS                                   ...
        )
    fn033.a.step_value := float(fn024.a.step_velocity)/1000000.0
    call fn033_transform_step_value_into_dynamic

    SEQ.data.flux.i [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_VELO,                                    ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := fn033.r.transf_value.i

    SEQ.data.flux.f [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_VELO,                                    ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := fn033.r.transf_value.r

    fn024.l.step_velocity_flux := fn033.r.transf_value.r


    // message(f'fn024: input PITCH value: <fn024.a.step_pitch>')
    {{ PITCH }}
    SEQ.data.flux.i [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_PITCH,                                   ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := fn024.a.step_pitch

    SEQ.data.flux.f [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_PITCH,                                   ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := float(fn024.a.step_pitch)/1000000.0
    fn024.l.step_pitch_flux := float(fn024.a.step_pitch)/1000000.0


    {{ LENGTH }}
    SEQ.data.flux.i [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_LENGTH,                                  ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := fn024.a.step_length

    SEQ.data.flux.f [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_LENGTH,                                  ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := float(fn024.a.step_length)/1000000.0
    fn024.l.step_length_flux := float(fn024.a.step_length)/1000000.0


    {{ PAN }}
    SEQ.data.flux.i [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_PAN,                                     ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := fn024.a.step_pan

    SEQ.data.flux.f [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_PAN,                                     ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := float(fn024.a.step_pan)/1000000.0
    fn024.l.step_pan_flux := float(fn024.a.step_pan)/1000000.0


    {{ FILTER }}
    SEQ.data.flux.i [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_FILTER,                                  ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := fn024.a.step_filter

    SEQ.data.flux.f [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_FILTER,                                  ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := float(fn024.a.step_filter)/1000000.0
    fn024.l.step_filter_flux := float(fn024.a.step_filter)/1000000.0

    select(SEQ.showing_target [ fn024.a.side ])
        case SEQ_TARGET_VELO
            fn024.l.picture_state := fn024.l.step_velocity_flux
        case SEQ_TARGET_PITCH
            fn024.l.picture_state := fn024.l.step_pitch_flux
            message(f'          FN24: updating picture to < int(float(SEQ_XY_H-1) * fn024.l.picture_state) >')
        case SEQ_TARGET_LENGTH
            fn024.l.picture_state := fn024.l.step_length_flux
        case SEQ_TARGET_PAN
            fn024.l.picture_state := fn024.l.step_pan_flux
        case SEQ_TARGET_FILTER
            fn024.l.picture_state := fn024.l.step_filter_flux
    end select

    { update ui step picture value }
    UIID_MAIN.seq.step [ fn024.a.side, fn024.a.step_counter + fn024.a.block_step_index * 8 ] -> picture_state := ...
        int(float(SEQ_XY_H-1) * fn024.l.picture_state)
end function

{{ 25 }}
function fn025_update_flux_on_all_block_steps
    if  fn025.a.side # __FLUX_ON_ALL_BLOCKS { SEQ DUAL }
        if  SEQ.DUAL.current_block [ fn025.a.side ] = 0 and seq.direction_status [ fn025.a.side ] = SEQ_DIRECTION_FORWARD or ...
            SEQ.DUAL.current_block [ fn025.a.side ] = 3  and seq.direction_status [ fn025.a.side ] = SEQ_DIRECTION_BACKWARD

            for fn025.l.counter2 := 0 to 3
                if  UIID_MAIN.seq.flux_rand_btns  [ fn025.a.side, fn025.l.counter2 ] -> value = __ON and ...
                    UIID_MAIN.seq.flux_rand_power [ fn025.a.side ] -> value = __ON
                    for fn025.l.counter := 0 to SEQ.DUAL.step_count [ fn025.a.side, fn025.l.counter2 ]

                        { retrieves data from the SEQ.data table }
                        fn017.a.transform_value  := __NO
                        fn017.a.side             := fn025.a.side
                        fn017.a.step_counter     := fn025.l.counter
                        fn017.a.block_step_index := fn025.l.counter2
                        call fn017_get_seq_target_data
                        { return values from fn017_get_seq_target_data() used below }

                        fn022.a.side             := fn025.a.side
                        fn022.a.step_counter     := fn025.l.counter
                        fn022.a.block_step_index := fn025.l.counter2
                        fn022.a.step_velocity    := fn017.r.velocity     // value returned from fn017
                        fn022.a.step_pitch       := fn017.r.pitch        // value returned from fn017
                        fn022.a.step_length      := fn017.r.length       // value returned from fn017
                        fn022.a.step_pan         := fn017.r.pan          // value returned from fn017
                        fn022.a.step_filter      := fn017.r.filter_value // value returned from fn017
                        call fn022_get_flux_values

                        {{ LOG }}
                            // message(f'    <fn025.l.counter2> | <fn025.l.counter> | fn022.a.step_velocity : <fn022.a.step_velocity >')
                            // message(f'<fn025.l.counter2> | <fn025.l.counter> | fn024.a.step_pitch    : <fn024.a.step_pitch    >')
                            // message(f'<fn025.l.counter2> | <fn025.l.counter> | fn024.a.step_length   : <fn024.a.step_length   >')
                            // message(f'<fn025.l.counter2> | <fn025.l.counter> | fn024.a.step_pan      : <fn024.a.step_pan      >')
                            // message(f'<fn025.l.counter2> | <fn025.l.counter> | fn024.a.step_filter   : <fn024.a.step_filter   >')
                            // message(f'<fn025.l.counter2> | <fn025.l.counter> | fn024.a.step_lp_filter: <fn024.a.step_lp_filter>')
                            // message(f'<fn025.l.counter2> | <fn025.l.counter> | fn024.a.step_hp_filter: <fn024.a.step_hp_filter>')

                        fn024.a.step_velocity    := fn022.r.step_velocity
                        fn024.a.step_pitch       := fn022.r.step_pitch
                        fn024.a.step_length      := fn022.r.step_length
                        fn024.a.step_pan         := fn022.r.step_pan
                        fn024.a.step_filter      := fn022.r.step_filter
                        fn024.a.step_lp_filter   := fn022.r.step_lp_filter
                        fn024.a.step_hp_filter   := fn022.r.step_hp_filter
                        fn024.a.side             := fn025.a.side
                        fn024.a.step_counter     := fn025.l.counter
                        fn024.a.block_step_index := fn025.l.counter2
                        call fn024_update_flux_data_and_ui

                        fn033.a.dyn_value := ...
                            get_control_par_real_arr(                       ...
                                UIID_MAIN.seq.dyn_slider [ fn025.a.side ],  ...
                                CONTROL_PAR_VALUE,                          ...
                                __Y_AXIS                                    ...
                            )
                        fn033.a.step_value := ...
                            SEQ.data.flux.f [                          ...
                                fn025.a.side,                          ...
                                SEQ_TARGET_VELO,                       ...
                                fn025.l.counter2 * 8 + fn025.l.counter ...
                            ]

                        call fn033_transform_step_value_into_dynamic

                        SEQ.data.dyn.i [                          ...
                            fn025.a.side,                          ...
                            SEQ_TARGET_VELO,                       ...
                            fn025.l.counter2 * 8 + fn025.l.counter ...
                        ] := fn033.r.transf_value.i

                        SEQ.data.dyn.f [                          ...
                            fn025.a.side,                          ...
                            SEQ_TARGET_VELO,                       ...
                            fn025.l.counter2 * 8 + fn025.l.counter ...
                        ] := fn033.r.transf_value.r

                        // message(f'    <fn025.l.counter2> | <fn025.l.counter> | fn024.a.step_velocity : <fn024.a.step_velocity >')
                        // message(f'    <fn025.l.counter2> | <fn025.l.counter> | fn024.a.step_pitch : <fn024.a.step_pitch >')
                    end for
                end if
            end for
        end if

    else                                    { SEQ JOIN }
        if  SEQ.JOIN.current_block = 0 and seq_join.direction_status = SEQ_DIRECTION_FORWARD or ...
            SEQ.JOIN.current_block = 7 and seq_join.direction_status = SEQ_DIRECTION_BACKWARD
            message(f'FN 25 _____________________________')
            for fn025.l.join_side_counter := __LEFT to __RIGHT
                for fn025.l.counter2 := 0 to 3
                    if  UIID_MAIN.seq.flux_rand_btns  [ fn025.l.join_side_counter, fn025.l.counter2 ] -> value = __ON and ...
                        UIID_MAIN.seq.flux_rand_power [ __LEFT ] -> value = __ON

                        for fn025.l.counter := 0 to SEQ.JOIN.step_count [ fn025.l.counter2 + fn025.l.join_side_counter * 4 ]
                            message(f'FN25 | side: < fn025.l.join_side_counter > | block: < fn025.l.counter2 > | step: < fn025.l.counter > -----------------')
                            { retrieves data from the SEQ.data table }
                            fn017.a.transform_value  := __NO
                            fn017.a.side             := fn025.l.join_side_counter
                            fn017.a.step_counter     := fn025.l.counter
                            fn017.a.block_step_index := fn025.l.counter2
                            call fn017_get_seq_target_data
                            { return values from fn017_get_seq_target_data() used below }
                            fn022.a.side             := fn025.l.join_side_counter
                            fn022.a.step_counter     := fn025.l.counter
                            fn022.a.block_step_index := fn025.l.counter2
                            fn022.a.step_velocity    := fn017.r.velocity
                            fn022.a.step_pitch       := fn017.r.pitch
                            fn022.a.step_length      := fn017.r.length
                            fn022.a.step_pan         := fn017.r.pan
                            fn022.a.step_filter      := fn017.r.filter_value
                            call fn022_get_flux_values

                            fn024.a.step_velocity    := fn022.r.step_velocity
                            fn024.a.step_pitch       := fn022.r.step_pitch
                            fn024.a.step_length      := fn022.r.step_length
                            fn024.a.step_pan         := fn022.r.step_pan
                            fn024.a.step_filter      := fn022.r.step_filter
                            fn024.a.step_lp_filter   := fn022.r.step_lp_filter
                            fn024.a.step_hp_filter   := fn022.r.step_hp_filter
                            fn024.a.side             := fn025.l.join_side_counter
                            fn024.a.step_counter     := fn025.l.counter
                            fn024.a.block_step_index := fn025.l.counter2
                            call fn024_update_flux_data_and_ui

                            fn033.a.dyn_value := ...
                                get_control_par_real_arr(                ...
                                    UIID_MAIN.seq.dyn_slider [ __LEFT ], ...
                                    CONTROL_PAR_VALUE,                   ...
                                    __Y_AXIS                             ...
                                )
                            fn033.a.step_value := ...
                                SEQ.data.flux.f [                          ...
                                    fn025.l.join_side_counter,             ...
                                    SEQ_TARGET_VELO,                       ...
                                    fn025.l.counter2 * 8 + fn025.l.counter ...
                                ]

                            call fn033_transform_step_value_into_dynamic

                            SEQ.data.dyn.i [                           ...
                                fn025.l.join_side_counter,             ...
                                SEQ_TARGET_VELO,                       ...
                                fn025.l.counter2 * 8 + fn025.l.counter ...
                            ] := fn033.r.transf_value.i

                            SEQ.data.dyn.f [                           ...
                                fn025.l.join_side_counter,             ...
                                SEQ_TARGET_VELO,                       ...
                                fn025.l.counter2 * 8 + fn025.l.counter ...
                            ] := fn033.r.transf_value.r

                        end for
                    end if
                end for
            end for

        end if

    end if
end function

{{ 26 }}
function fn026_get_seq_target_data
    if  UIID_MAIN.seq.target_power [ fn026.a.side, SEQ_TARGET_VELO ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_DUAL or ...
        UIID_MAIN.seq.target_power [ __LEFT, SEQ_TARGET_VELO ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_JOIN
        fn026.r.velocity := ...
            SEQ.data.dyn.i [                                        ...
                fn026.a.side,                                       ...
                SEQ_TARGET_VELO,                                    ...
                fn026.a.step_counter + fn026.a.block_step_index * 8 ...
            ]

        fn034.a.target_index := SEQ_TARGET_VELO
        fn034.a.value        := fn026.r.velocity
        call fn034_transform_data_according_to_seq_target
        fn026.r.velocity     := fn034.r.transf_value.i

    else
        fn026.r.velocity := layers.note_velo [ fn026.a.side, fn026.a.key_note ]
    end if

    if  UIID_MAIN.seq.target_power [ fn026.a.side, SEQ_TARGET_PITCH ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_DUAL or ...
        UIID_MAIN.seq.target_power [ __LEFT, SEQ_TARGET_PITCH ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_JOIN

        if fn026.a.data_type = __FLUX_DATA
            fn026.r.pitch := (                                          ...
                SEQ.data.flux.i [                                       ...
                    fn026.a.side,                                       ...
                    SEQ_TARGET_PITCH,                                   ...
                    fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                ] )
        else
            { DYN is only for Velocity, here used to differentiate from FLUX }
            if fn026.a.data_type = __ORIGINAL_DATA 
                fn026.r.pitch := ...
                    SEQ.data.i [                                            ...
                        fn026.a.side,                                       ...
                        SEQ_TARGET_PITCH,                                   ...
                        fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                    ]
            end if
        end if

        fn034.a.target_index := SEQ_TARGET_PITCH
        fn034.a.value        := fn026.r.pitch
        call fn034_transform_data_according_to_seq_target
        fn026.r.pitch        := fn034.r.transf_value.i

    else
        fn026.r.pitch := 0
    end if

    if  UIID_MAIN.seq.target_power [ fn026.a.side, SEQ_TARGET_LENGTH ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_DUAL or ...
        UIID_MAIN.seq.target_power [ __LEFT, SEQ_TARGET_LENGTH ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_JOIN

        if fn026.a.data_type = __FLUX_DATA
            fn026.r.length := (                                         ...
                SEQ.data.flux.i [                                       ...
                    fn026.a.side,                                       ...
                    SEQ_TARGET_LENGTH,                                  ...
                    fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                ] )
        else
            { DYN is only for Velocity, here used to differentiate from FLUX }
            if fn026.a.data_type = __ORIGINAL_DATA
                fn026.r.length := ...
                    SEQ.data.i [                                            ...
                        fn026.a.side,                                       ...
                        SEQ_TARGET_LENGTH,                                  ...
                        fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                    ]
            end if
        end if

        fn034.a.target_index := SEQ_TARGET_LENGTH
        fn034.a.value        := fn026.r.length
        // message(f'fn026.r.length before transform <fn026.r.length >')
        call fn034_transform_data_according_to_seq_target
        fn026.r.length        := fn034.r.transf_value.i
        // message(f'fn026.r.length after transform <fn026.r.length >')

    else
        fn026.r.length := 0
    end if

    if  UIID_MAIN.seq.target_power [ fn026.a.side, SEQ_TARGET_PAN ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_DUAL or ...
        UIID_MAIN.seq.target_power [ __LEFT, SEQ_TARGET_PAN ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_JOIN
        // message(f'retrieving Flux PAN')
        if fn026.a.data_type = __FLUX_DATA
            fn026.r.pan := (                                            ...
                SEQ.data.flux.i [                                       ...
                    fn026.a.side,                                       ...
                    SEQ_TARGET_PAN,                                     ...
                    fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                ] )
        else
            // message(f'retrieving Original PAN')
            { DYN is only for Velocity, here used to differentiate from FLUX }
            if fn026.a.data_type = __ORIGINAL_DATA
                fn026.r.pan := ...
                    SEQ.data.i [                                            ...
                        fn026.a.side,                                       ...
                        SEQ_TARGET_PAN,                                     ...
                        fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                    ]
            end if
        end if

        fn034.a.target_index := SEQ_TARGET_PAN
        fn034.a.value        := fn026.r.pan
        call fn034_transform_data_according_to_seq_target
        fn026.r.pan          := fn034.r.transf_value.i

    else
        fn026.r.pan := 0
    end if

    if  UIID_MAIN.seq.target_power [ fn026.a.side, SEQ_TARGET_FILTER ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_DUAL or ...
        UIID_MAIN.seq.target_power [ __LEFT, SEQ_TARGET_FILTER ] -> value = __ON and switch_MAIN.SEQ.combine = __SEQ_JOIN

        fn026.r.filter_status := __ON
        if fn026.a.data_type = __FLUX_DATA
            fn026.r.filter_value := (                                   ...
                SEQ.data.flux.i [                                       ...
                    fn026.a.side,                                       ...
                    SEQ_TARGET_FILTER,                                  ...
                    fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                ] )
        else
            { DYN is only for Velocity, here used to differentiate from FLUX }
            if fn026.a.data_type = __ORIGINAL_DATA
                fn026.r.filter_value := ...
                    SEQ.data.i [                                            ...
                        fn026.a.side,                                       ...
                        SEQ_TARGET_FILTER,                                  ...
                        fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                    ]
                
            end if
        end if

        fn034.a.target_index := SEQ_TARGET_FILTER
        fn034.a.value        := fn026.r.filter_value
        call fn034_transform_data_according_to_seq_target
        fn026.r.filter_value    := fn034.r.transf_value.i
        fn026.r.lp_filter_value := fn034.r.transf_value.i_lp
        fn026.r.hp_filter_value := fn034.r.transf_value.i_hp

    else
        fn026.r.filter_status := __OFF
        fn026.r.filter_value  := 500000
    end if
end function

function fn028_update_arp_note_buffers
    if fn028.a.side = __LEFT
        ARP.i := 0
        while (ARP.i <= 127)
            if (ARP.i < ARP.cursor [ fn028.a.side ] )
                ARP.sorted_buffer_LEFT      [ ARP.i ] := ARP.note_buffer_LEFT [ ARP.i ]
                ARP.sorted_vel_buffer_LEFT  [ ARP.i ] := ARP.vel_buffer_LEFT  [ ARP.i ]
            else
                ARP.sorted_buffer_LEFT     [ ARP.i ] := 0
                ARP.sorted_vel_buffer_LEFT [ ARP.i ] := -1
                ARP.note_buffer_LEFT       [ ARP.i ] := 0
                ARP.vel_buffer_LEFT        [ ARP.i ] := -1
            end if

            inc(ARP.i)
        end while
        { using insertion sort here because the velocity buffer needs to follow the sorting of the note buffer }
        ARP.o := 1
        while ( ARP.o < num_elements(ARP.sorted_buffer_LEFT))
            ARP.temp1 := ARP.sorted_buffer_LEFT     [ ARP.o]
            ARP.temp2 := ARP.sorted_vel_buffer_LEFT [ ARP.o]

            ARP.p :=  ARP.o - 1
            while ( ARP.p >= 0 and ( ARP.sorted_buffer_LEFT [ ARP.p ] <  ARP.temp1 ) )
                ARP.sorted_buffer_LEFT     [ ARP.p + 1] := ARP.sorted_buffer_LEFT     [ ARP.p ]
                ARP.sorted_vel_buffer_LEFT [ ARP.p + 1] := ARP.sorted_vel_buffer_LEFT [ ARP.p ]
                dec( ARP.p )
            end while

            ARP.sorted_buffer_LEFT     [ ARP.p + 1 ] :=  ARP.temp1
            ARP.sorted_vel_buffer_LEFT [ ARP.p + 1 ] :=  ARP.temp2

            inc( ARP.o)
        end while

        { create play buffers }
        ARP.i := 0
        while ( ARP.i <  ARP.cursor [ fn028.a.side ] )
            ARP.play_buffer_LEFT          [ ARP.i ] := ARP.note_buffer_LEFT       [ ARP.i ]
            ARP.play_up_buffer_LEFT       [ ARP.i ] := ARP.sorted_buffer_LEFT     [ ARP.cursor [ fn028.a.side ] - 1 -  ARP.i ]
            ARP.play_down_buffer_LEFT     [ ARP.i ] := ARP.sorted_buffer_LEFT     [ ARP.i ]
            ARP.play_vel_buffer_LEFT      [ ARP.i ] := ARP.vel_buffer_LEFT        [ ARP.i ]
            ARP.play_up_vel_buffer_LEFT   [ ARP.i ] := ARP.sorted_vel_buffer_LEFT [ ARP.cursor [ fn028.a.side ] - 1 -  ARP.i ]
            ARP.play_down_vel_buffer_LEFT [ ARP.i ] := ARP.sorted_vel_buffer_LEFT [ ARP.i ]

            inc( ARP.i )
        end while

    else
        ARP.i := 0
        while (ARP.i <= 127)
            if (ARP.i < ARP.cursor [ fn028.a.side ])
                ARP.sorted_buffer_RIGHT      [ ARP.i ] := ARP.note_buffer_RIGHT [ ARP.i ]
                ARP.sorted_vel_buffer_RIGHT  [ ARP.i ] := ARP.vel_buffer_RIGHT  [ ARP.i ]
            else
                ARP.sorted_buffer_RIGHT     [ ARP.i ] := 0
                ARP.sorted_vel_buffer_RIGHT [ ARP.i ] := -1
                ARP.note_buffer_RIGHT       [ ARP.i ] := 0
                ARP.vel_buffer_RIGHT        [ ARP.i ] := -1
            end if

            inc(ARP.i)
        end while
        { using insertion sort here because the velocity buffer needs to follow the sorting of the note buffer }
        ARP.o := 1
        while ( ARP.o < num_elements(ARP.sorted_buffer_RIGHT))
            ARP.temp1 := ARP.sorted_buffer_RIGHT     [ ARP.o]
            ARP.temp2 := ARP.sorted_vel_buffer_RIGHT [ ARP.o]

            ARP.p :=  ARP.o - 1
            while ( ARP.p >= 0 and ( ARP.sorted_buffer_RIGHT [ ARP.p ] <  ARP.temp1 ) )
                ARP.sorted_buffer_RIGHT     [ ARP.p + 1] := ARP.sorted_buffer_RIGHT     [ ARP.p ]
                ARP.sorted_vel_buffer_RIGHT [ ARP.p + 1] := ARP.sorted_vel_buffer_RIGHT [ ARP.p ]
                dec( ARP.p )
            end while

            ARP.sorted_buffer_RIGHT     [ ARP.p + 1 ] :=  ARP.temp1
            ARP.sorted_vel_buffer_RIGHT [ ARP.p + 1 ] :=  ARP.temp2

            inc( ARP.o)
        end while

        { create play buffers }
        ARP.i := 0
        while ( ARP.i <  ARP.cursor [ fn028.a.side ] )
            ARP.play_buffer_RIGHT          [ ARP.i ] := ARP.note_buffer_RIGHT       [ ARP.i ]
            ARP.play_up_buffer_RIGHT       [ ARP.i ] := ARP.sorted_buffer_RIGHT     [ ARP.cursor [ fn028.a.side ] - 1 -  ARP.i ]
            ARP.play_down_buffer_RIGHT     [ ARP.i ] := ARP.sorted_buffer_RIGHT     [ ARP.i ]
            ARP.play_vel_buffer_RIGHT      [ ARP.i ] := ARP.vel_buffer_RIGHT        [ ARP.i ]
            ARP.play_up_vel_buffer_RIGHT   [ ARP.i ] := ARP.sorted_vel_buffer_RIGHT [ ARP.cursor [ fn028.a.side ] - 1 -  ARP.i ]
            ARP.play_down_vel_buffer_RIGHT [ ARP.i ] := ARP.sorted_vel_buffer_RIGHT [ ARP.i ]

            inc( ARP.i )
        end while
    end if
end function

function fn050_seq.arp.get_play_note_from_buffer
    select (arp_mode[ fn50.a.side ])
        case __ARP_MODE_AS_PLAYED
            if fn50.a.side = __LEFT
                ARP.played_note [ fn50.a.side ]     := ARP.play_buffer_LEFT [ ARP.play_counter [ fn50.a.side ] ]{ + ($ARP.oct_counter * 12)}
            else
                ARP.played_note [ fn50.a.side ]     := ARP.play_buffer_RIGHT [ ARP.play_counter [ fn50.a.side ] ]{ + ($ARP.oct_counter * 12)}
            end if

        case __ARP_MODE_UP
            if fn50.a.side = __LEFT
                ARP.played_note [ fn50.a.side ] := ARP.play_up_buffer_LEFT [ ARP.play_counter [ fn50.a.side ] ]
            else
                ARP.played_note [ fn50.a.side ] := ARP.play_up_buffer_RIGHT [ ARP.play_counter [ fn50.a.side ] ]
            end if

        case __ARP_MODE_DOWN
            if fn50.a.side = __LEFT
                ARP.played_note [ fn50.a.side ] := ARP.play_down_buffer_LEFT [ ARP.play_counter [ fn50.a.side ] ]
            else
                ARP.played_note [ fn50.a.side ] := ARP.play_down_buffer_RIGHT [ ARP.play_counter [ fn50.a.side ] ]
            end if

        case __ARP_MODE_UP_DOWN
            if fn50.a.side = __LEFT
                ARP.played_note [ fn50.a.side ] := ARP.play_up_buffer_LEFT [ ARP.up_down_counter [ fn50.a.side ] ]
            else
                ARP.played_note [ fn50.a.side ] := ARP.play_up_buffer_RIGHT [ ARP.up_down_counter [ fn50.a.side ] ]
            end if

        case __ARP_MODE_RANDOM
            if fn50.a.side = __LEFT
                ARP.temp3 := random(0, ARP.cursor [ fn50.a.side ] - 1)
                // while (ARP.last_random_note [ fn50.a.side ] = ARP.played_note [ fn50.a.side ])
                ARP.played_note [ fn50.a.side ] := ARP.play_buffer_LEFT [ ARP.temp3 ]
                // end while
            else
                ARP.temp4 := random(0, ARP.cursor [ fn50.a.side ] - 1)
                // while (ARP.last_random_note [ fn50.a.side ] = ARP.played_note [ fn50.a.side ])
                ARP.played_note [ fn50.a.side ] := ARP.play_buffer_RIGHT [ ARP.temp4 ]
                // end while
            end if

        case __ARP_MODE_CHORD { treated directly at the play level }
    end select
end function

function PLAY_NOTE_NCB
    layers.note_events [ pn_ncb.a.side,  pn_ncb.a.note ] := play_note(pn_ncb.a.note, pn_ncb.a.velo, -1, -1)
    set_event_par_arr(layers.note_events [ pn_ncb.a.side, pn_ncb.a.note ], EVENT_PAR_ALLOW_GROUP, __OFF, ALL_GROUPS)
    
    set_event_par_arr(                                       ...
        layers.note_events [ pn_ncb.a.side, pn_ncb.a.note ], ...
        EVENT_PAR_ALLOW_GROUP,                               ...
        __ON,                                                ...
        selected_source [ pn_ncb.a.side ]                    ...
    )

    { only to load the waveform but not playing anything }
    if pn_ncb.a.mute_note = __YES
        change_vol( layers.note_events [ pn_ncb.a.side,  pn_ncb.a.note ], -200000, 0)
    else
        { adjust sample start }
        message(f'side: <pn_ncb.a.side > | sample start: <sample_starts [ selected_source [ pn_ncb.a.side ], pn_ncb.a.side, pn_ncb.a.note ]>')
        set_event_par_arr(                                                                                      ...
            layers.note_events [ pn_ncb.a.side, pn_ncb.a.note ],                                                ...
            EVENT_PAR_MOD_VALUE_ID,                                                                             ...
            int(sample_starts [ selected_source [ pn_ncb.a.side ], pn_ncb.a.side, pn_ncb.a.note ] * 1000000.0), ...
            __FS_SNG_SHT_SAMPLE_START_LAYER_1 + pn_ncb.a.side                                                   ...
        )

        change_tune(                                                                                              ...
            layers.note_events [ pn_ncb.a.side, pn_ncb.a.note ],                                                  ...
            int(sample_tuning [ selected_source [ pn_ncb.a.side ], pn_ncb.a.side, last_played_note ] * 100000.0), ...
            0                                                                                                     ...
        )

        { recalling ui values per key }
        UIID_MAIN.single_shot_controls [ pn_ncb.a.side, __SINGLE_SHOT_LP_CUT ] -> value := ...
            sample_low_cutoff  [ selected_source [ pn_ncb.a.side ], pn_ncb.a.side, pn_ncb.a.note ]

        UIID_MAIN.single_shot_controls [ pn_ncb.a.side, __SINGLE_SHOT_LP_RES ] -> value := ...
            sample_low_reso    [ selected_source [ pn_ncb.a.side ], pn_ncb.a.side, pn_ncb.a.note ]

        UIID_MAIN.single_shot_controls [ pn_ncb.a.side, __SINGLE_SHOT_HP_CUT ] -> value := ...
            sample_high_cutoff [ selected_source [ pn_ncb.a.side ], pn_ncb.a.side, pn_ncb.a.note ]

        UIID_MAIN.single_shot_controls [ pn_ncb.a.side, __SINGLE_SHOT_HP_RES ] -> value := ...
            sample_high_reso   [ selected_source [ pn_ncb.a.side ], pn_ncb.a.side, pn_ncb.a.note ]

        { from script modulating Low Pass Cutoff }
        set_event_par_arr(                                                                          ...
            layers.note_events [ pn_ncb.a.side, pn_ncb.a.note ],                                    ...
            EVENT_PAR_MOD_VALUE_ID,                                                                 ...
            sample_low_cutoff  [ selected_source [ pn_ncb.a.side ], pn_ncb.a.side, pn_ncb.a.note ], ...
            __FS_SNG_SHT_LP_CUTOFF + pn_ncb.a.side * __FS_SNG_SHT_FILTER_LAYER_OFFSET               ...
        )
        { from script modulating Low Pass Reso }
        set_event_par_arr(                                                                        ...
            layers.note_events [ pn_ncb.a.side, pn_ncb.a.note ],                                  ...
            EVENT_PAR_MOD_VALUE_ID,                                                               ...
            sample_low_reso  [ selected_source [ pn_ncb.a.side ], pn_ncb.a.side, pn_ncb.a.note ], ...
            __FS_SNG_SHT_LP_RESO + pn_ncb.a.side * __FS_SNG_SHT_FILTER_LAYER_OFFSET               ...
        )
        { from script modulating Hi Pass Cutoff }
        set_event_par_arr(                                                                           ...
            layers.note_events [ pn_ncb.a.side, pn_ncb.a.note ],                                     ...
            EVENT_PAR_MOD_VALUE_ID,                                                                  ...
            sample_high_cutoff  [ selected_source [ pn_ncb.a.side ], pn_ncb.a.side, pn_ncb.a.note ], ...
            __FS_SNG_SHT_HP_CUTOFF + pn_ncb.a.side * __FS_SNG_SHT_FILTER_LAYER_OFFSET                ...
        )
        { from script modulating Hi Pass Reso }
        set_event_par_arr(                                                                         ...
            layers.note_events [ pn_ncb.a.side, pn_ncb.a.note ],                                   ...
            EVENT_PAR_MOD_VALUE_ID,                                                                ...
            sample_high_reso  [ selected_source [ pn_ncb.a.side ], pn_ncb.a.side, pn_ncb.a.note ], ...
            __FS_SNG_SHT_HP_RESO + pn_ncb.a.side * __FS_SNG_SHT_FILTER_LAYER_OFFSET                ...
        )

    end if


    wait(1)
    if pn_ncb.a.side = __LEFT
        attach_zone( ...
            waveform_MAIN.2SEQ.LEFT.display,   ...
            get_event_par(layers.note_events [ pn_ncb.a.side,  pn_ncb.a.note ], EVENT_PAR_ZONE_ID), ...
            0                                 ...
        )
    else
        attach_zone( ...
            waveform_MAIN.2SEQ.RIGHT.display,  ...
            get_event_par(layers.note_events [ pn_ncb.a.side,  pn_ncb.a.note ], EVENT_PAR_ZONE_ID), ...
            0                                 ...
        )
        
    end if 
end function

function fn027_play_lcb_core
    message(f'Playing side <fn027.a.side > | note: < fn027.a.note>')
    if SEQ.step_velocity > 1
        if  SEQ.step_length = 0
            SEQ.step_length := 1000
        end if
        if  switch_MAIN.SEQ.combine = __SEQ_DUAL
            fn027.l.step_duration := SEQ.DUAL.step_duration [ fn027.a.side ] * SEQ.step_length
            message(f'    length: <SEQ.step_length >')
        else
            fn027.l.step_duration := SEQ.JOIN.step_duration * SEQ.step_length
        end if

        layers.note_events [ fn027.a.side, fn027.a.note ] := ...
            play_note(                      ...
                fn027.a.note,               ...
                SEQ.step_velocity,          ...
                -1,                         ...
                fn027.l.step_duration       ...
            )                               ...

        set_event_par_arr(layers.note_events [ fn027.a.side, fn027.a.note ], EVENT_PAR_ALLOW_GROUP, __OFF, ALL_GROUPS)
        
        set_event_par_arr(                                     ...
            layers.note_events [ fn027.a.side, fn027.a.note ], ...
            EVENT_PAR_ALLOW_GROUP,                             ...
            __ON,                                              ...
            selected_source [ fn027.a.side ]                   ...
        )
        message(f'      Allowing group <selected_source [ fn027.a.side ] >')

        set_event_par_arr(                                                                                     ...
            layers.note_events [ fn027.a.side, fn027.a.note ],                                                 ...
            EVENT_PAR_MOD_VALUE_ID,                                                                            ...
            int(sample_starts [ selected_source [ fn027.a.side ], fn027.a.side, fn027.a.note ] * 1000000.0),   ...
            pn_ncb.a.side + 1                                                                                  ...
        )

        { adjust event according to seq modulations }
        change_tune(                                                                                ...
            layers.note_events [ fn027.a.side, fn027.a.note ],                                      ...
            int(sample_tuning [ selected_source [ fn027.a.side ], fn027.a.side, fn027.a.note ] * 100000.0) + SEQ.step_pitch * 100000, ...
            0                                                                                       ...
        )

        change_pan( ...
            layers.note_events [ fn027.a.side, fn027.a.note ], ...
            SEQ.step_pan, 0 )

        { filter seq setting }
        if fn026.r.filter_status = __ON
            set_engine_par(ENGINE_PAR_CUTOFF, SEQ.step_lp_filter, __NO_GROUP, __LP_FILTER_SLOT, NI_BUS_OFFSET+fn027.a.side)
            set_engine_par(ENGINE_PAR_CUTOFF, SEQ.step_hp_filter, __NO_GROUP, __HP_FILTER_SLOT, NI_BUS_OFFSET+fn027.a.side)
        else
            set_engine_par(ENGINE_PAR_CUTOFF, 1000000, __NO_GROUP, __LP_FILTER_SLOT, NI_BUS_OFFSET+fn027.a.side)
            set_engine_par(ENGINE_PAR_CUTOFF,       0, __NO_GROUP, __HP_FILTER_SLOT, NI_BUS_OFFSET+fn027.a.side)
        end if

    end if
end function

function PLAY_LCB
    if switch_MAIN.SEQ.combine = __SEQ_DUAL 
        select(seq.direction_status [ p_lcb.a.side ])
            case SEQ_DIRECTION_FORWARD  
                p_lcb.l.ts_counter := SEQ.ts_counter

            case SEQ_DIRECTION_BACKWARD 
                p_lcb.l.ts_counter := ...
                    SEQ.DUAL.step_count [ p_lcb.a.side, SEQ.DUAL.current_block [ p_lcb.a.side ] ] - SEQ.ts_counter
        end select
    else { SEQ JOIN }
        select(seq_join.direction_status)
            case SEQ_DIRECTION_FORWARD  
                p_lcb.l.ts_counter := SEQ.ts_counter

            case SEQ_DIRECTION_BACKWARD 
                p_lcb.l.ts_counter := SEQ.JOIN.step_count [ SEQ.JOIN.current_block ] - SEQ.ts_counter
        end select
    end if

    if  switch_MAIN.SEQ.combine = __SEQ_DUAL and ...
        SEQ.DUAL.steps_timestamps [ p_lcb.a.side, SEQ.DUAL.current_block [ p_lcb.a.side ], p_lcb.l.ts_counter ] = ENGINE_UPTIME

        { update step leds - has to be here, at the timestamp of each step }
        for lcb_block_counter := 0 to 3
            if lcb_block_counter = SEQ.DUAL.current_block [ lcb_play_side ]
                UIID_MAIN.seq.step_leds [                    ...
                    lcb_play_side,                           ...
                    SEQ.DUAL.current_block [ lcb_play_side ] ...
                ] -> picture_state := SEQ.ts_counter + 1
            else
                UIID_MAIN.seq.step_leds [                    ...
                    lcb_play_side,                           ...
                    lcb_block_counter                        ...
                ] -> picture_state := 0
            end if
        end for

        {{ play dual }}
        if UIID_MAIN.seq.arp_power [ p_lcb.a.side ] -> value = __OFF
            for SEQ.key_count := 0 to 127
                if KEY_DOWN[ SEQ.key_count ] = __ON
                    { kill the note we are about to play (in case it is still there from NCB or something else )}
                    if layers.note_events [ p_lcb.a.side, SEQ.key_count ] > 0
                        // fade_out( layers.note_events [ p_lcb.a.side, SEQ.key_count ], 2000, 1)
                        note_off(layers.note_events [ p_lcb.a.side, SEQ.key_count ])
                    end if

                    if UIID_MAIN.seq.flux_rand_power [ p_lcb.a.side ] -> value = __ON
                        fn026.a.data_type := __FLUX_DATA
                    else
                        fn026.a.data_type := __ORIGINAL_DATA
                    end if
                    fn026.a.side             := p_lcb.a.side
                    fn026.a.key_note         := SEQ.key_count
                    fn026.a.step_counter     := SEQ.ts_counter
                    fn026.a.block_step_index := SEQ.DUAL.current_block [ fn026.a.side ]
                    call fn026_get_seq_target_data
                    { return values from fn026_get_seq_target_data() }

                    { LOG }
                        // message(f'PLAY_LCB, | fn026.r.velocity: <fn026.r.velocity> ')
                        // message(f'PLAY_LCB, | fn026.r.pitch:    <fn026.r.pitch>')
                        // message(f'PLAY_LCB, | fn026.r.length: <fn026.r.length> ')
                        // message(f'PLAY_LCB, | fn026.r.pan: <fn026.r.pan> ')
                        // message(f'PLAY_LCB, | fn026.r.filter_value:    <fn026.r.filter_value>')
                        // message(f'PLAY_LCB, | fn026.r.lp_filter_value:    <fn026.r.lp_filter_value>')
                        // message(f'PLAY_LCB, | fn026.r.hp_filter_value:    <fn026.r.hp_filter_value>')

                    SEQ.step_velocity  := fn026.r.velocity
                    SEQ.step_pitch     := fn026.r.pitch
                    SEQ.step_length    := fn026.r.length
                    // message(f'SEQ.step_length: <SEQ.step_length >')
                    SEQ.step_pan       := fn026.r.pan
                    SEQ.step_filter    := fn026.r.filter_value
                    SEQ.step_lp_filter := fn026.r.lp_filter_value
                    SEQ.step_hp_filter := fn026.r.hp_filter_value

                    fn027.a.side         := p_lcb.a.side
                    fn027.a.note         := SEQ.key_count
                    fn027.a.step_counter := SEQ.ts_counter
                    call fn027_play_lcb_core
                end if
            end for

        else { Arpeggiated notes here }
            fn028.a.side := p_lcb.a.side
            call fn028_update_arp_note_buffers
            
            {{ get played note from buffer according to play mode }}
            fn50.a.side := p_lcb.a.side
            call fn050_seq.arp.get_play_note_from_buffer

            {{ Actual note generation }}
            if arp_mode [ p_lcb.a.side ] # __ARP_MODE_CHORD
                ARP.played_duration [ p_lcb.a.side ] := SEQ.DUAL.step_duration [ p_lcb.a.side ] * SEQ.step_length
                ARP.played_velocity [ p_lcb.a.side ] := SEQ.step_velocity

                if  UIID_MAIN.seq.flux_rand_power [ p_lcb.a.side ] -> value = __ON and ...
                    UIID_MAIN.seq.flux_rand_btns [ p_lcb.a.side, SEQ.DUAL.current_block [ p_lcb.a.side ] ] -> value = __ON

                    fn026.a.data_type        := __FLUX_DATA

                else
                    fn026.a.data_type        := __ORIGINAL_DATA

                end if
                fn026.a.side             := p_lcb.a.side
                fn026.a.key_note         := ARP.played_note [ p_lcb.a.side ]
                fn026.a.step_counter     := SEQ.ts_counter
                fn026.a.block_step_index := SEQ.DUAL.current_block [ p_lcb.a.side ]
                call fn026_get_seq_target_data

                { return values from fn026_get_seq_target_data() }
                SEQ.step_velocity  := fn026.r.velocity
                SEQ.step_pitch     := fn026.r.pitch
                SEQ.step_length    := fn026.r.length
                SEQ.step_pan       := fn026.r.pan
                SEQ.step_filter    := fn026.r.filter_value
                SEQ.step_lp_filter := fn026.r.lp_filter_value
                SEQ.step_hp_filter := fn026.r.hp_filter_value

                // if layers.note_events [ p_lcb.a.side, ARP.played_note [ p_lcb.a.side ] ] > 0
                //     fade_out( layers.note_events [ p_lcb.a.side, ARP.played_note [ p_lcb.a.side ] ], 2000, 1)
                // end if

                if (in_range(ARP.played_note [ p_lcb.a.side ], 0, 127))
                    fn027.a.side         := p_lcb.a.side
                    fn027.a.note         := ARP.played_note [ p_lcb.a.side ]
                    fn027.a.step_counter := SEQ.ts_counter
                    call fn027_play_lcb_core
                end if

            else { CHORD MODE HERE }
                ARP.i := 0
                while (ARP.i < ARP.cursor [ p_lcb.a.side ] )
                    if p_lcb.a.side = __LEFT
                        ARP.played_note [ p_lcb.a.side ] := ARP.play_buffer_LEFT [ ARP.i ]
                    else
                        ARP.played_note [ p_lcb.a.side ] := ARP.play_buffer_RIGHT [ ARP.i ]
                    end if

                    ARP.played_duration [ p_lcb.a.side ] := SEQ.DUAL.step_duration [ p_lcb.a.side ] * SEQ.step_length
                    ARP.played_velocity [ p_lcb.a.side ] := SEQ.step_velocity

                    if  UIID_MAIN.seq.flux_rand_power [ p_lcb.a.side ] -> value = __ON and ...
                    UIID_MAIN.seq.flux_rand_btns [ p_lcb.a.side, SEQ.DUAL.current_block [ p_lcb.a.side ] ] -> value = __ON

                        fn026.a.data_type        := __FLUX_DATA

                    else
                        fn026.a.data_type        := __ORIGINAL_DATA
                        
                    end if
                    fn026.a.side             := p_lcb.a.side
                    fn026.a.key_note         := ARP.played_note [ p_lcb.a.side ]
                    fn026.a.step_counter     := SEQ.ts_counter
                    fn026.a.block_step_index := SEQ.DUAL.current_block [ p_lcb.a.side ]
                    call fn026_get_seq_target_data
                    { return values from fn026_get_seq_target_data() }

                    SEQ.step_velocity  := fn026.r.velocity
                    SEQ.step_pitch     := fn026.r.pitch
                    SEQ.step_length    := fn026.r.length
                    SEQ.step_pan       := fn026.r.pan
                    SEQ.step_filter    := fn026.r.filter_value
                    SEQ.step_lp_filter := fn026.r.lp_filter_value
                    SEQ.step_hp_filter := fn026.r.hp_filter_value

                    // if layers.note_events [ p_lcb.a.side, ARP.played_note [ p_lcb.a.side ] ] > 0
                    //     fade_out( layers.note_events [ p_lcb.a.side, ARP.played_note [ p_lcb.a.side ] ], 2000, 1)
                    // end if

                    if (in_range(ARP.played_note [ p_lcb.a.side ], 0, 127))
                        fn027.a.side         := p_lcb.a.side
                        fn027.a.note         := ARP.played_note [ p_lcb.a.side ]
                        fn027.a.step_counter := SEQ.ts_counter
                        call fn027_play_lcb_core
                    end if

                    inc(ARP.i)
                end while

            end if

            if arp_mode [ p_lcb.a.side ] = __ARP_MODE_UP_DOWN
                if (ARP.cursor  [ p_lcb.a.side ] = 2)
                    inc( ARP.up_down_counter [ p_lcb.a.side ] )
                    if ( ARP.up_down_counter [ p_lcb.a.side ] = 2)
                        ARP.up_down_counter [ p_lcb.a.side ] := 0
                    end if
                end if

                if (ARP.cursor  [ p_lcb.a.side ] > 2)
                    if (ARP.up_down_counter  [ p_lcb.a.side ] >= ARP.cursor  [ p_lcb.a.side ] - 1)
                        ARP.up_down_direction  [ p_lcb.a.side ] := 1  { go down }
                    end if

                    if (ARP.up_down_counter  [ p_lcb.a.side ] <= 0)
                        ARP.up_down_direction  [ p_lcb.a.side ] := 0  { go up }
                    end if

                    if ARP.up_down_direction  [ p_lcb.a.side ] = 1 
                        dec( ARP.up_down_counter [ p_lcb.a.side ] )
                    else
                        inc( ARP.up_down_counter [ p_lcb.a.side ] )
                    end if
                end if
            end if

            if arp_mode [ p_lcb.a.side ] = __ARP_MODE_RANDOM
                ARP.last_random_note [ p_lcb.a.side ] := ARP.played_note [ p_lcb.a.side ]
            end if

            { advance play counter }
            inc( ARP.play_counter [ p_lcb.a.side ] )
            if ( ARP.play_counter [ p_lcb.a.side ] >= ARP.cursor [ p_lcb.a.side ] )  { we have finished a cycle }
                 ARP.play_counter [ p_lcb.a.side ] := 0
            end if

        end if
    end if

    if  switch_MAIN.SEQ.combine = __SEQ_JOIN and ...
        SEQ.JOIN.steps_timestamps [ SEQ.JOIN.current_block, p_lcb.l.ts_counter ] = ENGINE_UPTIME

        seq_join_side := __LEFT
        if SEQ.JOIN.current_block > 3
            seq_join_side := __RIGHT
        end if

        { update leds }
        UIID_MAIN.seq.step_leds [        ...
            seq_join_side,               ...
            SEQ.JOIN.current_block mod 4 ...
        ] -> picture_state := SEQ.ts_counter + 1

        { clear the non current leds }
        if  seq_join.direction_status = SEQ_DIRECTION_FORWARD
            if SEQ.JOIN.current_block > 0 { not the first block }
                UIID_MAIN.seq.step_leds [              ...
                    SEQ.JOIN.current_block / 4,        ...
                    (SEQ.JOIN.current_block mod 4) - 1 ...
                ] -> picture_state := 0
            else
                UIID_MAIN.seq.step_leds [       ...
                    SEQ.JOIN.current_block / 4, ...
                    7                           ...
                ] -> picture_state := 0
            end if
        else

            if SEQ.JOIN.current_block < 7 { not the first block }
                UIID_MAIN.seq.step_leds [              ...
                    SEQ.JOIN.current_block / 4,        ...
                    (SEQ.JOIN.current_block mod 4) + 1 ...
                ] -> picture_state := 0
            else
                UIID_MAIN.seq.step_leds [       ...
                    __LEFT, ...
                    0                           ...
                ] -> picture_state := 0
            end if
        end if

        if switch_MAIN.FLUXX.LEFT.arp.power = __OFF
            for SEQ.key_count := 0 to 127
                if KEY_DOWN[ SEQ.key_count ] = 1
                    { play both layers }
                    for play_layer_count := __LEFT to __RIGHT
                        // message(f'Playing layer < play_layer_count >')
                        if UIID_MAIN.layer.power [ play_layer_count ] -> value = __ON
                            // if layers.note_events [ play_layer_count, SEQ.key_count ] > 0
                            //     fade_out( layers.note_events [ play_layer_count, SEQ.key_count ], 2000, 1)
                            // end if

                            if  UIID_MAIN.seq.flux_rand_power [ __LEFT ] -> value = __ON and ...
                                UIID_MAIN.seq.flux_rand_btns [ play_layer_count, SEQ.JOIN.current_block mod 4 ] -> value = __ON
                                fn026.a.data_type := __FLUX_DATA
                            else
                                fn026.a.data_type := __ORIGINAL_DATA
                            end if
                            fn026.a.side             := SEQ.JOIN.current_block / 4 
                            fn026.a.key_note         := SEQ.key_count
                            fn026.a.step_counter     := SEQ.ts_counter
                            fn026.a.block_step_index := SEQ.JOIN.current_block mod 4
                            call fn026_get_seq_target_data

                            SEQ.step_velocity  := fn026.r.velocity
                            SEQ.step_pitch     := fn026.r.pitch
                            SEQ.step_length    := fn026.r.length
                            SEQ.step_pan       := fn026.r.pan
                            SEQ.step_filter    := fn026.r.filter_value
                            SEQ.step_lp_filter := fn026.r.lp_filter_value
                            SEQ.step_hp_filter := fn026.r.hp_filter_value

                            fn027.a.side         := play_layer_count
                            fn027.a.note         := SEQ.key_count
                            fn027.a.step_counter := SEQ.ts_counter
                            call fn027_play_lcb_core
                        end if
                    end for
                end if
            end for

        else { Arpeggiated notes here ------------------------------------- }

            fn028.a.side := __LEFT { we are using only one arpeggiator }
            call fn028_update_arp_note_buffers
            
            {{ get played note from buffer according to play mode }}
            fn50.a.side := __LEFT
            call fn050_seq.arp.get_play_note_from_buffer
            // message(f'   note from buffer <ARP.played_note [ __LEFT ] >')

            {{ Actual note generation }}
            if arp_mode [ __LEFT ] # __ARP_MODE_CHORD
                ARP.played_duration [ __LEFT ] := SEQ.JOIN.step_duration * SEQ.step_length
                ARP.played_velocity [ __LEFT ] := SEQ.step_velocity

                if  UIID_MAIN.seq.flux_rand_power [ __LEFT ] -> value = __ON and ...
                    UIID_MAIN.seq.flux_rand_btns [ seq_join_side, SEQ.JOIN.current_block mod 4 ] -> value = __ON
                    fn026.a.data_type        := __FLUX_DATA
                else
                    fn026.a.data_type        := __ORIGINAL_DATA

                end if

                for play_layer_count := __LEFT to __RIGHT
                    fn026.a.side             := SEQ.JOIN.current_block / 4
                    fn026.a.key_note         := ARP.played_note [ __LEFT ]
                    fn026.a.step_counter     := SEQ.ts_counter
                    fn026.a.block_step_index := SEQ.JOIN.current_block mod 4
                    call fn026_get_seq_target_data

                    { return values from fn026_get_seq_target_data() }
                    SEQ.step_velocity  := fn026.r.velocity
                    SEQ.step_pitch     := fn026.r.pitch
                    SEQ.step_length    := fn026.r.length
                    SEQ.step_pan       := fn026.r.pan
                    SEQ.step_filter    := fn026.r.filter_value
                    SEQ.step_lp_filter := fn026.r.lp_filter_value
                    SEQ.step_hp_filter := fn026.r.hp_filter_value

                    // message(f'    SEQ.step_pan: <SEQ.step_pan>')

                    // if layers.note_events [ play_layer_count, ARP.played_note [ __LEFT ] ] > 0
                    //     fade_out( layers.note_events [ play_layer_count, ARP.played_note [ __LEFT ] ], 2000, 1)
                    // end if

                    if (in_range(ARP.played_note [ __LEFT ], 0, 127))
                        fn027.a.side         := play_layer_count
                        fn027.a.note         := ARP.played_note [ __LEFT ]
                        fn027.a.step_counter := SEQ.ts_counter
                        call fn027_play_lcb_core
                    end if
                end for

            else { CHORD MODE HERE }
                ARP.i := 0
                while (ARP.i < ARP.cursor [ p_lcb.a.side ] )
                    if p_lcb.a.side = __LEFT
                        ARP.played_note [ p_lcb.a.side ] := ARP.play_buffer_LEFT [ ARP.i ]
                    else
                        ARP.played_note [ p_lcb.a.side ] := ARP.play_buffer_RIGHT [ ARP.i ]
                    end if

                    ARP.played_duration [ p_lcb.a.side ] := SEQ.DUAL.step_duration [ p_lcb.a.side ] * SEQ.step_length
                    ARP.played_velocity [ p_lcb.a.side ] := SEQ.step_velocity

                    for play_layer_count := __LEFT to __RIGHT
                        if  UIID_MAIN.seq.flux_rand_power [ p_lcb.a.side ] -> value = __ON and ...
                        UIID_MAIN.seq.flux_rand_btns [ p_lcb.a.side, SEQ.JOIN.current_block mod 4 ] -> value = __ON

                            fn026.a.data_type        := __FLUX_DATA

                        else
                            fn026.a.data_type        := __ORIGINAL_DATA
                            
                        end if
                        fn026.a.side             := SEQ.JOIN.current_block / 4
                        fn026.a.key_note         := ARP.played_note [ __LEFT ]
                        fn026.a.step_counter     := SEQ.ts_counter
                        fn026.a.block_step_index := SEQ.JOIN.current_block mod 4
                        call fn026_get_seq_target_data
                        { return values from fn026_get_seq_target_data() }

                        SEQ.step_velocity  := fn026.r.velocity
                        SEQ.step_pitch     := fn026.r.pitch
                        SEQ.step_length    := fn026.r.length
                        SEQ.step_pan       := fn026.r.pan
                        SEQ.step_filter    := fn026.r.filter_value
                        SEQ.step_lp_filter := fn026.r.lp_filter_value
                        SEQ.step_hp_filter := fn026.r.hp_filter_value

                        // if layers.note_events [ play_layer_count, ARP.played_note [ __LEFT ] ] > 0
                        //     fade_out( layers.note_events [ play_layer_count, ARP.played_note [ __LEFT ] ], 2000, 1)
                        // end if

                        if (in_range(ARP.played_note [ __LEFT ], 0, 127))
                            fn027.a.side         := play_layer_count
                            fn027.a.note         := ARP.played_note [ __LEFT ]
                            fn027.a.step_counter := SEQ.ts_counter
                            call fn027_play_lcb_core
                        end if
                    end for

                    inc(ARP.i)
                end while

            end if

            if arp_mode [ __LEFT ] = __ARP_MODE_UP_DOWN
                if (ARP.cursor  [ __LEFT ] = 2)
                    inc( ARP.up_down_counter [ __LEFT ] )
                    if ( ARP.up_down_counter [ __LEFT ] = 2)
                        ARP.up_down_counter [ __LEFT ] := 0
                    end if
                end if

                if (ARP.cursor  [ __LEFT ] > 2)
                    if (ARP.up_down_counter  [ __LEFT ] >= ARP.cursor  [ __LEFT ] - 1)
                        ARP.up_down_direction  [ __LEFT ] := 1  { go down }
                    end if

                    if (ARP.up_down_counter  [ __LEFT ] <= 0)
                        ARP.up_down_direction  [ __LEFT ] := 0  { go up }
                    end if

                    if ARP.up_down_direction  [ __LEFT ] = 1 
                        dec( ARP.up_down_counter [ __LEFT ] )
                    else
                        inc( ARP.up_down_counter [ __LEFT ] )
                    end if
                end if
            end if

            if arp_mode [ __LEFT ] = __ARP_MODE_RANDOM
                ARP.last_random_note [ __LEFT ] := ARP.played_note [ __LEFT ]
            end if

            { advance play counter }
            inc( ARP.play_counter [ __LEFT ] )
            if ( ARP.play_counter [ __LEFT ] >= ARP.cursor [ __LEFT ] )  { we have finished a cycle }
                 ARP.play_counter [ __LEFT ] := 0
            end if

        end if
    end if
end function

