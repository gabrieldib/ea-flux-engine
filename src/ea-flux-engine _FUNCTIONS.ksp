// import "ARP/__ARP 03 functions.ksp"

{{ LFO }}
function update_lfo_ms_rates
    beat_rates [ 00 ] := (DURATION_SIXTEENTH/8)/1000
    beat_rates [ 01 ] := (DURATION_SIXTEENTH_TRIPLET/2)/1000
    beat_rates [ 02 ] := (DURATION_SIXTEENTH/4)/1000
    beat_rates [ 03 ] := (DURATION_SIXTEENTH_TRIPLET/2)/1000
    beat_rates [ 04 ] := (DURATION_SIXTEENTH/2)/1000
    beat_rates [ 05 ] := (DURATION_SIXTEENTH_TRIPLET)/1000
    beat_rates [ 06 ] := (DURATION_SIXTEENTH)/1000
    beat_rates [ 07 ] := (DURATION_EIGHTH_TRIPLET)/1000
    beat_rates [ 08 ] := (3*DURATION_SIXTEENTH/2)/1000
    beat_rates [ 09 ] := (DURATION_EIGHTH)/1000
    beat_rates [ 10 ] := (DURATION_QUARTER_TRIPLET)/1000
    beat_rates [ 11 ] := (DURATION_SIXTEENTH* 3)/1000
    beat_rates [ 12 ] := (DURATION_QUARTER)/1000
    beat_rates [ 13 ] := (DURATION_QUARTER_TRIPLET * 2)/1000
    beat_rates [ 14 ] := (DURATION_EIGHTH * 3)/1000
    beat_rates [ 15 ] := (DURATION_QUARTER * 2)/1000
    beat_rates [ 16 ] := (DURATION_QUARTER * 3)/1000
    beat_rates [ 17 ] := (DURATION_QUARTER_TRIPLET * 4)/1000
    beat_rates [ 18 ] := (DURATION_QUARTER * 4)/1000
    LFO_rate := beat_rates [ slider_MAIN.LFO.rate / __BEAT_RATE_DIVISOR ]
    SEQ.rate [ __LEFT  ] := beat_rates [ (UIID_MAIN.SEQ.rate_sliders [ 0 ] -> value) / __BEAT_RATE_DIVISOR ]
    SEQ.rate [ __RIGHT ] := beat_rates [ (UIID_MAIN.SEQ.rate_sliders [ 1 ] -> value) / __BEAT_RATE_DIVISOR ]
    LFO_sine_step := (2.0 * NI_MATH_PI) / float(LFO_rate)
end function

function LCB_data_update
    if __BPM # round((60000000.0 / float(DURATION_QUARTER)) * 100.0)/100.0
        __BPM := round((60000000.0 / float(DURATION_QUARTER)) * 100.0)/100.0
        message("BPM changed to " & __BPM)
        call update_lfo_ms_rates
        lcb_ms_counter := 0

    end if 
end function

{{ SEQ }}
function fn001_get_seq_step_index
    fn001.l.xy_x := get_control_par_real_arr(   ...
        UIID_MAIN.SEQ.xypads [ fn001.a.side ], ...
        CONTROL_PAR_VALUE,                     ...
        0                                      ...
    ) 
    
    fn001.l.xy_x.normalized := fn001.l.xy_x - 0.25 * float(fn001.a.block_index)

    fn001.r.step_index := int(( fn001.l.xy_x.normalized )/ SEQ.step_width [ fn001.a.side, fn001.a.block_index ]) + ...
        8 * fn001.a.block_index

    if fn001.r.step_index = 32
        fn001.r.step_index := 31
    end if
end function

function fn002_set_seq_step_value
    UIID_MAIN.seq.step [ fn002.a.side, fn002.a.step_index ] -> picture_state := ...
        int(float(SEQ_XY_H-1) * fn002.a.value)

    { depends on the target showing }

    SEQ.data.i [                             ...
        fn002.a.side,                        ...
        SEQ.showing_target [ fn002.a.side ], ...
        fn002.a.step_index                   ...
    ] := int( 1000000.0 * fn002.a.value )

    SEQ.data.f [                             ...
        fn002.a.side,                        ...
        SEQ.showing_target [ fn002.a.side ], ...
        fn002.a.step_index                   ...
    ] := fn002.a.value

end function

function fn003_set_block_step_count
    { needed for the seq xy }
    SEQ.step_width [ fn003.a.side, fn003.a.block_index ] := ...
        SEQ_XY_BLOCK_W / float(SEQ.MAIN.step_count [ fn003.a.side, fn003.a.block_index ] + 1)

    UIID_MAIN.seq.leds [ fn003.a.side, fn003.a.block_index ] -> picture := ...
        SEQ_step_led_pictures [ SEQ.MAIN.step_count [ fn003.a.side, fn003.a.block_index ] ]
        
    { update the number of step sliders and their pictures }
    for i.i := 0 to 7
        if i.i <= SEQ.MAIN.step_count [ fn003.a.side, fn003.a.block_index ]
            UIID_MAIN.seq.step [ fn003.a.side, i.i + fn003.a.block_index * 8 ] -> UI_SHOW
            
            UIID_MAIN.seq.step [ fn003.a.side, i.i + fn003.a.block_index * 8 ] -> picture := ...
                SEQ_step_pictures [ SEQ.MAIN.step_count [ fn003.a.side, fn003.a.block_index ] + ...
                    SEQ.target_type [ SEQ.showing_target [ fn003.a.side ] ] * 8 ]

            UIID_MAIN.seq.step [ fn003.a.side, i.i + fn003.a.block_index * 8 ] -> pos_x := ...
                SEQ_STEP_COORD [                                     ...
                    fn003.a.side,                                          ...
                    SEQ.MAIN.step_count [ fn003.a.side, fn003.a.block_index ], ...
                    i.i                                              ...
                ] + SEQ_XY_BLOCK_START_OFFSET [ fn003.a.block_index ]

        else
            UIID_MAIN.seq.step [ fn003.a.side, i.i + fn003.a.block_index * 8 ] -> UI_HIDE
        end if
    end for
end function

function fn004_get_current_seq_block
    if fn004.a.x_coord >= SEQ_XY_B1_START and fn004.a.x_coord <= SEQ_XY_B1_END
        fn004.r.block_index := 0
    end if
    if fn004.a.x_coord >= SEQ_XY_B2_START and fn004.a.x_coord <= SEQ_XY_B2_END
        fn004.r.block_index := 1
    end if
    if fn004.a.x_coord >= SEQ_XY_B3_START and fn004.a.x_coord <= SEQ_XY_B3_END
        fn004.r.block_index := 2
    end if
    if fn004.a.x_coord >= SEQ_XY_B4_START and fn004.a.x_coord <= SEQ_XY_B4_END
        fn004.r.block_index := 3
    end if
end function

function get_seq_step_index
    fn004.a.x_coord := get_control_par_real_arr(  ...
        UIID_MAIN.SEQ.xypads [ uics_uiid_index ], ...
        CONTROL_PAR_VALUE,                        ...
        0                                         ...
    ) 
    call fn004_get_current_seq_block
    fn001.a.block_index := fn004.r.block_index
    fn001.a.side        := uics_uiid_index
    call fn001_get_seq_step_index
end function

function fn006_recall_seq_values
    for i.i := 0 to 31
        UIID_MAIN.seq.step [ fn006.a.side, i.i ] -> picture_state := ...
            int(                                         ...
                float(SEQ_XY_H-1) *                      ...
                SEQ.data.f [                             ...
                    fn006.a.side,                        ...
                    SEQ.showing_target [ fn006.a.side ], ...
                    i.i                                  ...
                ]                                        ...
            )
    end for
end function


{{ general  }}
function fn005_set_seq_target_selector
    for i.i := 0 to 4
        UIID_MAIN.target_selectors [ i.i ] -> value := __OFF
    end for
    UIID_MAIN.target_selectors [ fn005.a.selector_index ] -> value := __ON
end function


{{ play engine }}
function fn007_update_block_and_steps_ts
    inc(SEQ.current_block [ fn007.a.side ])
    if SEQ.current_block [ fn007.a.side ] > 3
        SEQ.current_block [ fn007.a.side ] := 0
    end if

    { left sequencer }
    SEQ.step_duration [ fn007.a.side ] := ...
        SEQ.rate [ fn007.a.side ] / ( SEQ.MAIN.step_count [ fn007.a.side, SEQ.current_block [ fn007.a.side ] ] + 1 )
    for s.i := 0 to SEQ.MAIN.step_count [ fn007.a.side, SEQ.current_block [ fn007.a.side ] ]
        SEQ.steps_timestamps [ fn007.a.side, SEQ.current_block [ fn007.a.side ], s.i ] := ...
            ENGINE_UPTIME + s.i * SEQ.step_duration [ fn007.a.side ]
    end for
end function

function PLAY_NOTE_NCB
    layers.note_events [ pn_ncb.a.side,  pn_ncb.a.note ] := play_note(pn_ncb.a.note, pn_ncb.a.velo, -1, -1)
    set_event_par_arr(layers.note_events [ pn_ncb.a.side, pn_ncb.a.note ], EVENT_PAR_ALLOW_GROUP, __OFF, ALL_GROUPS)
    { PENDING: group as side here is just for testing}
    set_event_par_arr(layers.note_events [ pn_ncb.a.side, pn_ncb.a.note ], EVENT_PAR_ALLOW_GROUP, __ON,  pn_ncb.a.side)

end function

function PLAY_LCB
    if SEQ.steps_timestamps [ p_lcb.a.side, SEQ.current_block [ p_lcb.a.side ], SEQ.ts_counter ] = ENGINE_UPTIME
        if switch_MAIN.FLUXX.LEFT.arp.power = __OFF
            for SEQ.key_count := 0 to 127
                if KEY_DOWN[ SEQ.key_count ] = 1
                    // message(SEQ.key_count & " <-- key pressed")
                    if layers.note_events [ p_lcb.a.side, SEQ.key_count ] > 0
                        fade_out( layers.note_events [ p_lcb.a.side, SEQ.key_count ], 2000, 1)
                        // message("    Killing note:  " & SEQ.key_count & " | UT: " & ENGINE_UPTIME)
                    end if
                    SEQ.step_velocity := (126 *                         ...
                        SEQ.data.i [                                    ...
                            p_lcb.a.side,                                     ...
                            SEQ_TARGET_VELO,                            ...
                            SEQ.ts_counter + SEQ.current_block [ p_lcb.a.side ] * 8 ...
                        ] ) / 1000000 + 1

                    // message("    " & SEQ.current_block [ p_lcb.a.side ] & " | " & SEQ.ts_counter & " | step velo: " & SEQ.step_velocity)
                    if SEQ.step_velocity > 1
                        layers.note_events [ p_lcb.a.side, SEQ.key_count ] := ...
                            play_note(                      ...
                                SEQ.key_count,              ...
                                SEQ.step_velocity,          ...
                                -1,                         ...
                                SEQ.step_duration [ p_lcb.a.side ] * 500     ...
                            )                               ...

                        set_event_par_arr(layers.note_events [ p_lcb.a.side, SEQ.key_count ], EVENT_PAR_ALLOW_GROUP, __OFF, ALL_GROUPS)
                        { PENDING: group here is just for testing example -> side }
                        set_event_par_arr(layers.note_events [ p_lcb.a.side, SEQ.key_count ], EVENT_PAR_ALLOW_GROUP, __ON,  p_lcb.a.side)
                    end if
                end if
            end for

        else { Arpeggiated notes here }

        end if
    end if
end function