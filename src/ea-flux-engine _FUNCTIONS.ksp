import "ARP/__ARP 03 functions.ksp"

{{ MAIN }}
function draw_seq
    { SHOW / HIDE dual and joined seq panels }
    panel_MAIN.2SEQ    -> hide := switch_MAIN.SEQ.combine * HIDE_WHOLE_CONTROL
    panel_MAIN.SEQjoin -> hide := abs(1-switch_MAIN.SEQ.combine) * HIDE_WHOLE_CONTROL

    if switch_MAIN.SEQ.combine = 0 { dual seq }
        label_SEQjoin.background    -> parent_panel := get_ui_id(panel_MAIN.2SEQ)
        label_SEQjoin.background    -> UI_HIDE
    else
        label_SEQjoin.background    -> parent_panel := get_ui_id(panel_MAIN.SEQjoin)
        label_SEQjoin.background    -> UI_SHOW
    end if
    
    for ds.counter := 0 to SEQ.COMMON_ELEMENTS_COUNT-1
        { change ui_control parent }
        SEQ.common_elements_data [ ds.counter, ELEMENT_UIID ] -> parent_panel := ...
            SEQ.common_elements_data [ ds.counter, switch_MAIN.SEQ.combine ]

        { update the coordinates }
        if switch_MAIN.SEQ.combine = 0 { dual seq }
            // message("drawing dual seq ")
            SEQ.common_elements_data [ ds.counter, ELEMENT_UIID ] -> pos_x := ...
                SEQ.common_elements_data [ ds.counter, PANEL_DUAL_SEQ_X_COORD ]

            SEQ.common_elements_data [ ds.counter, ELEMENT_UIID ] -> pos_y := ...
                SEQ.common_elements_data [ ds.counter, PANEL_DUAL_SEQ_Y_COORD ]

            if in_range(ds.counter, 29, 32)
                UIID_FLUX_RAND_RIGHT [ ds.counter - 29 ] -> picture := "button_fluxx_block_" & ds.counter - 28
            end if

        else                           { join seq }
            // message("drawing join seq ")
            SEQ.common_elements_data [ ds.counter, ELEMENT_UIID ] -> pos_x := ...
                SEQ.common_elements_data [ ds.counter, PANEL_JOIN_SEQ_X_COORD ]

            SEQ.common_elements_data [ ds.counter, ELEMENT_UIID ] -> pos_y := ...
                SEQ.common_elements_data [ ds.counter, PANEL_JOIN_SEQ_Y_COORD ]

            if in_range(ds.counter, 29, 32)
                UIID_FLUX_RAND_RIGHT [ ds.counter - 29 ] -> picture := "button_fluxx_block_" & ds.counter - 24
            end if
        end if
    end for
    

    
    // message("DUAL hide state: " & SEQ.common_elements_data [ 0, PANEL_DUAL_SEQ_PARENT_UIID ] -> hide)
    // message("JOIN hide state: " & SEQ.common_elements_data [ 0, PANEL_JOIN_SEQ_PARENT_UIID ] -> hide)
    // message("switch_MAIN.SEQ.combine: " & switch_MAIN.SEQ.combine)"
end function

{{ LFO }}
function update_lfo_ms_rates
    beat_rates [ 00 ] := (DURATION_SIXTEENTH/8)/1000
    beat_rates [ 01 ] := (DURATION_SIXTEENTH_TRIPLET/2)/1000
    beat_rates [ 02 ] := (DURATION_SIXTEENTH/4)/1000
    beat_rates [ 03 ] := (DURATION_SIXTEENTH_TRIPLET/2)/1000
    beat_rates [ 04 ] := (DURATION_SIXTEENTH/2)/1000
    beat_rates [ 05 ] := (DURATION_SIXTEENTH_TRIPLET)/1000
    beat_rates [ 06 ] := (DURATION_SIXTEENTH)/1000
    beat_rates [ 07 ] := (DURATION_EIGHTH_TRIPLET)/1000
    beat_rates [ 08 ] := (3*DURATION_SIXTEENTH/2)/1000
    beat_rates [ 09 ] := (DURATION_EIGHTH)/1000
    beat_rates [ 10 ] := (DURATION_QUARTER_TRIPLET)/1000
    beat_rates [ 11 ] := (DURATION_SIXTEENTH* 3)/1000
    beat_rates [ 12 ] := (DURATION_QUARTER)/1000
    beat_rates [ 13 ] := (DURATION_QUARTER_TRIPLET * 2)/1000
    beat_rates [ 14 ] := (DURATION_EIGHTH * 3)/1000
    beat_rates [ 15 ] := (DURATION_QUARTER * 2)/1000
    beat_rates [ 16 ] := (DURATION_QUARTER * 3)/1000
    beat_rates [ 17 ] := (DURATION_QUARTER_TRIPLET * 4)/1000
    beat_rates [ 18 ] := (DURATION_QUARTER * 4)/1000
    LFO_rate := beat_rates [ slider_MAIN.LFO.rate / __BEAT_RATE_DIVISOR ]
    SEQ.rate [ __LEFT  ] := beat_rates [ (UIID_MAIN.SEQ.rate_sliders [ 0 ] -> value) / __BEAT_RATE_DIVISOR ]
    SEQ.rate [ __RIGHT ] := beat_rates [ (UIID_MAIN.SEQ.rate_sliders [ 1 ] -> value) / __BEAT_RATE_DIVISOR ]
    LFO_sine_step := (2.0 * NI_MATH_PI) / float(LFO_rate)
end function

function LCB_data_update
    if __BPM # round((60000000.0 / float(DURATION_QUARTER)) * 100.0)/100.0
        __BPM := round((60000000.0 / float(DURATION_QUARTER)) * 100.0)/100.0
        message("BPM changed to " & __BPM)
        call update_lfo_ms_rates
        lcb_ms_counter := 0

    end if 
end function

{{ SEQ COMMON }}
function fn006_recall_seq_values
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        fn006.l.mode_side := fn006.a.side
    else
        fn006.l.mode_side := __LEFT
    end if
    // message("fn006 showing target: " & SEQ.showing_target [ fn006.l.mode_side ])
    // message("     fn006.a.side: " & fn006.a.side)

    for i.i := 0 to 31
        UIID_MAIN.seq.step [ fn006.a.side, i.i ] -> picture_state := ...
            int(                                              ...
                float(SEQ_XY_H-1) *                           ...
                SEQ.data.f [                                  ...
                    fn006.a.side,                             ...
                    SEQ.showing_target [ fn006.l.mode_side ], ...
                    i.i                                       ...
                ]                                             ...
            )
    end for
end function

{{ SEQ DUAL }}
function fn001_get_seq_step_index
    fn001.l.xy_x := get_control_par_real_arr(   ...
        UIID_MAIN.SEQ.xypads [ fn001.a.side ], ...
        CONTROL_PAR_VALUE,                     ...
        0                                      ...
    ) 
    
    fn001.l.xy_x.normalized := fn001.l.xy_x - 0.25 * float(fn001.a.block_index)

    fn001.r.step_index := int(( fn001.l.xy_x.normalized )/ SEQ.DUAL.step_width [ fn001.a.side, fn001.a.block_index ]) + ...
        8 * fn001.a.block_index

    if fn001.r.step_index = 32
        fn001.r.step_index := 31
    end if
end function

function fn018_set_seq_step_picture_state
    // message(f'    ps = <int(float(SEQ_XY_H-1) * fn018.a.value)> | value <fn018.a.value>')
    UIID_MAIN.seq.step [ fn018.a.side, fn018.a.step_index ] -> picture_state := ...
        int(float(SEQ_XY_H-1) * fn018.a.value)
end function

function fn019_set_seq_step_value
    // if switch_MAIN.SEQ.combine = __SEQ_DUAL
    //     fn019.l.mode_side := fn019.a.side
    // else
    //     fn019.l.mode_side := __LEFT
    // end if

    SEQ.data.i [           ...
        fn019.a.side,      ...
        fn019.a.target,    ...
        fn019.a.step_index ...
    ] := int( 1000000.0 * fn019.a.value )

    SEQ.data.f [           ...
        fn019.a.side,      ...
        fn019.a.target,    ...
        fn019.a.step_index ...
    ] := fn019.a.value
    // message(f'FN019: value set to <int( 1000000.0 * fn019.a.value )>')

end function

function fn002_set_seq_step_value
    { storing the value changed
    by the user in the XY pad, into the SEQ.data.i/f }
    if  fn002.a.table_to_update .and. __SEQ_BOTH_TABLES = __SEQ_BOTH_TABLES or ...
        fn002.a.table_to_update .and. __SEQ_ORIGINAL_TABLE = __SEQ_ORIGINAL_TABLE

        fn019.a.side       := fn002.a.side
        fn019.a.step_index := fn002.a.step_index
        fn019.a.value      := fn002.a.value
        fn019.a.target     := fn002.a.target
        call fn019_set_seq_step_value
    end if
    { storing the value input transformed by the dyn slider }
    if  fn002.a.table_to_update .and. __SEQ_BOTH_TABLES = __SEQ_BOTH_TABLES or ...
        fn002.a.table_to_update .and. __SEQ_DYN_TRANSF_TABLE = __SEQ_DYN_TRANSF_TABLE

        fn030.a.side       := fn002.a.side
        fn030.a.step_index := fn002.a.step_index
        fn030.a.value      := fn002.a.value
        fn030.a.target     := fn002.a.target
        call fn030_set_seq_step_dyn_value
    end if

    // message("FN02 setting the value for step index: " & fn002.a.step_index)
end function

function fn013_update_seq_step_pictures
    // message("FN13 updating step pictures UNI/BIP")
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        fn013.l.mode_side := fn013.a.side
    else
        fn013.l.mode_side := __LEFT
    end if
    // message("    updating side: " & fn013.l.mode_side )
    for fn013.l.step := 0 to 7
        UIID_MAIN.seq.step [ fn013.a.side, fn013.l.step + (fn013.a.block_index mod 4 ) * 8 ] -> picture := ...
            SEQ_step_pictures [                                             ...
                SEQ.DUAL.step_count [ fn013.a.side, fn013.a.block_index mod 4 ] + ...
                SEQ.target_type [ SEQ.showing_target [ fn013.l.mode_side ] ] * 8 ...
            ]
        // message("    step picture set to " & SEQ_step_pictures [                                             ...
        //         SEQ.DUAL.step_count [ fn013.a.side, fn013.a.block_index mod 4 ] + ...
        //         SEQ.target_type [ SEQ.showing_target [ fn013.l.mode_side ] ] * 8 ...
        //     ])
    end for
end function

function fn003_set_block_step_count
    { PENDING OPTIMIZE CODE }

    { needed for the seq xy }
    // message("FN003 block_index: " & fn003.a.block_index & " side: " & fn003.a.side)
    fn013.a.side        := fn003.a.side
    fn013.a.block_index := fn003.a.block_index
    call fn013_update_seq_step_pictures

    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        // message("    DUAL step count: "  & SEQ.DUAL.step_count [ fn003.a.side, fn003.a.block_index mod 4  ])
        fn003.l.block_index_mod := fn003.a.block_index mod 4

        SEQ.DUAL.step_width [ fn003.a.side, fn003.l.block_index_mod ] := ...
            SEQ_XY_DUAL_BLOCK_W / float(SEQ.DUAL.step_count [ fn003.a.side, fn003.l.block_index_mod ] + 1)
        // message(" SEQ.DUAL.step_width = " & SEQ.DUAL.step_width [ fn003.a.side, fn003.a.block_index ])

        UIID_MAIN.seq.leds [ fn003.a.side, fn003.l.block_index_mod ] -> picture := ...
            SEQ_step_led_pictures [ SEQ.DUAL.step_count [ fn003.a.side, fn003.l.block_index_mod ] ]

        { update the number of step sliders and their pictures }
        for fn003.l.counter := 0 to 7
            if fn003.l.counter <= SEQ.DUAL.step_count [ fn003.a.side, fn003.l.block_index_mod ]
                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + fn003.l.block_index_mod * 8 ] -> UI_SHOW
                
                // UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + fn003.a.block_index * 8 ] -> picture := ...
                //     SEQ_step_pictures [ SEQ.DUAL.step_count [ fn003.a.side, fn003.a.block_index ] + ...
                //         SEQ.target_type [ SEQ.showing_target [ fn003.a.side ] ] * 8 ]

                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + fn003.l.block_index_mod * 8 ] -> pos_x := ...
                    SEQ_STEP_COORD [                                               ...
                        fn003.a.mode,                                              ...
                        fn003.a.side,                                              ...
                        SEQ.DUAL.step_count [ fn003.a.side, fn003.l.block_index_mod ], ...
                        fn003.l.counter                                                        ...
                    ] + SEQ_XY_BLOCK_START_OFFSET [ fn003.l.block_index_mod ]

            else
                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + fn003.l.block_index_mod * 8 ] -> UI_HIDE
            end if
        end for
    else

        SEQ.JOIN.step_width [ fn003.a.block_index ] := ...
            SEQ_XY_JOIN_BLOCK_W / float(SEQ.JOIN.step_count [ fn003.a.block_index ] + 1)
        // message(" SEQ.JOIN.step_width = " & SEQ.JOIN.step_width [ fn003.a.block_index ])
        UIID_MAIN.seq.leds [ fn003.a.side, fn003.a.block_index mod 4 ] -> picture := ...
            SEQ_step_led_pictures [ SEQ.JOIN.step_count [ fn003.a.block_index ] ]

        // message("    JOIN step count: " & SEQ.JOIN.step_count [ fn003.a.block_index ])

        for fn003.l.counter := 0 to 7
            if fn003.l.counter <= SEQ.JOIN.step_count [ fn003.a.block_index ]
                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + (fn003.a.block_index mod 4 ) * 8 ] -> UI_SHOW
                
                // UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + (fn003.a.block_index mod 4 ) * 8 ] -> picture := ...
                //     SEQ_step_pictures [ SEQ.JOIN.step_count [ fn003.a.block_index ] + ...
                //         SEQ.target_type [ SEQ.showing_target [ fn003.a.side ] ] * 8 ]

                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + (fn003.a.block_index mod 4 ) * 8 ] -> pos_x := ...
                    SEQ_STEP_COORD [                                               ...
                        fn003.a.mode,                                              ...
                        fn003.a.side,                                              ...
                        SEQ.JOIN.step_count [ fn003.a.block_index ], ...
                        fn003.l.counter                                                        ...
                    ] + SEQ_XY_BLOCK_START_OFFSET [ fn003.a.block_index mod 4 ]

            else
                UIID_MAIN.seq.step [ fn003.a.side, fn003.l.counter + (fn003.a.block_index mod 4 ) * 8 ] -> UI_HIDE
            end if
        end for

    end if 
end function

function fn004_get_current_seq_block
    for fn004.l.block_counter := 0 to 3
        if  fn004.a.x_coord >= SEQ_DUAL_XY_BLOCK_START_END [ fn004.l.block_counter, __START ] and ...
            fn004.a.x_coord <= SEQ_DUAL_XY_BLOCK_START_END [ fn004.l.block_counter, __END ]
            fn004.r.block_index := fn004.l.block_counter
        end if
    end for
end function

function get_seq_dual_step_index
    fn004.a.x_coord := get_control_par_real_arr(  ...
        UIID_MAIN.SEQ.xypads [ uics_seq_side ], ...
        CONTROL_PAR_VALUE,                        ...
        0                                         ...
    ) 
    call fn004_get_current_seq_block
    fn001.a.block_index := fn004.r.block_index
    fn001.a.side        := uics_seq_side
    call fn001_get_seq_step_index
end function

{{ SEQ JOIN }}
function get_seq_join_step_index
    fn008.a.x_coord := xypad_MAIN.SEQ.join [ 0 ]
    call fn008_get_current_seq_join_block

    fn009.a.block_index := fn008.r.block_index
    // message("GET_SEQ_JOIN_STEP_INDEX, block: " & fn009.a.block_index)

    call fn009_get_seq_join_step_index
end function

function fn008_get_current_seq_join_block
    for fn008.l.block_counter := 0 to 7
        if  fn008.a.x_coord >= SEQ_JOIN_XY_BLOCK_START_END [ fn008.l.block_counter, __START ] and ...
            fn008.a.x_coord <= SEQ_JOIN_XY_BLOCK_START_END [ fn008.l.block_counter, __END ]
            fn008.r.block_index := fn008.l.block_counter
            // message("FN008_GET_CURRENT_SEQ_JOIN_BLOCK " & fn008.r.block_index)
        end if
    end for
end function

function fn009_get_seq_join_step_index
    // message("FN009_GET_SEQ_JOIN_STEP_INDEX ---------- ")
    fn009.l.xy_x := xypad_MAIN.SEQ.join [ 0 ]
    
    fn009.l.xy_x.normalized := fn009.l.xy_x - 0.125 * float(fn009.a.block_index)    

    fn009.r.step_index := int(( fn009.l.xy_x.normalized )/ SEQ.JOIN.step_width [ fn009.a.block_index ]) + ...
        8 * fn009.a.block_index
    // message("        block ______: " & fn009.a.block_index)
    // message("        x __________: " & fn009.l.xy_x)
    // message("        x normalized: " & fn009.l.xy_x.normalized)
    // message("        Step W _____: " & SEQ.JOIN.step_width [ fn009.a.block_index ])
    // message("        step index  : " & fn009.r.step_index)

    if fn009.r.step_index = 32 and xypad_MAIN.SEQ.join [ 0 ] < 0.5
        fn009.r.step_index := 31
    end if
    if fn009.r.step_index = 64 and xypad_MAIN.SEQ.join [ 0 ] > 0.99
        fn009.r.step_index := 63
    end if
end function

function fn010_set_seq_step_value
    // message("FN010_SET_SEQ_STEP_VALUE ---------- ")
    // message("    fn10 side: " & fn010.l.side)
    // message("    fn10 step index: " & fn010.a.step_index)

    UIID_MAIN.seq.step [ fn010.l.side, fn010.a.step_index mod 32 ] -> picture_state := ...
        int(float(SEQ_XY_H-1) * fn010.a.value)

    { depends on the target showing }
    // message("FN10 setting the value for step index: " & fn010.a.step_index)
    SEQ.data.i [                             ...
        fn010.l.side,                        ...
        SEQ.showing_target [ fn010.l.side ], ...
        fn010.a.step_index mod 32            ...
    ] := int( 1000000.0 * fn010.a.value )

    SEQ.data.f [                             ...
        fn010.l.side,                        ...
        SEQ.showing_target [ fn010.l.side ], ...
        fn010.a.step_index mod 32            ...
    ] := fn010.a.value
end function

function fn012_seq_recall_step_count
    for b.i := 0 to 3
        fn003.a.mode        := switch_MAIN.SEQ.combine
        fn003.a.side        := fn012.a.side // __LEFT then __RIGHT
        if switch_MAIN.SEQ.combine = __SEQ_DUAL
            fn003.a.block_index := b.i
        else
            fn003.a.block_index := b.i + 4 * fn012.a.side
        end if

        call fn003_set_block_step_count

    end for
end function

{{ general  }}
function fn005_set_seq_target_selector
    for i.i := 0 to 4
        UIID_MAIN.seq.target_selectors [ i.i ] -> value := __OFF
    end for
    if in_range(fn005.a.selector_index, 0, 4)
        UIID_MAIN.seq.target_selectors [ fn005.a.selector_index ] -> value := __ON
    end if
end function

function fn011_clear_target_activators
    for i.i := 0 to 4
        UIID_MAIN.seq.target_activators [ fn011.a.side, i.i] -> value := __OFF
    end for
    if in_range(fn011.a.index, 0, 4)
        UIID_MAIN.seq.target_activators [ fn011.a.side, fn011.a.index ] -> value := __ON
    end if
end function

function fn014_seq_recall_target_steps_values_and_pictures
    // message("FN14 called")
    // message("    fn014.a.side: " & fn014.a.side)
    // message("    fn014.a.target_index: " & fn014.a.target_index)
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        fn006.a.side := fn014.a.side
        call fn006_recall_seq_values
        for fn014.l.counter := 0 to 3
            fn013.a.side        := fn014.a.side
            fn013.a.block_index := fn014.l.counter
            call fn013_update_seq_step_pictures
        end for
    else
        { mirror the right side }
        fn011.a.side  := __RIGHT
        fn011.a.index := fn014.a.target_index
        call fn011_clear_target_activators

        SEQ.showing_target [ __RIGHT ] := fn014.a.target_index 

        for fn014.l.counter := 0 to 1
            fn006.a.side := fn014.l.counter
            call fn006_recall_seq_values

            for fn014.l.counter2 := 0 to 3
                fn013.a.side        := fn014.l.counter
                fn013.a.block_index := fn014.l.counter2 + fn014.l.counter * 4
                call fn013_update_seq_step_pictures
            end for
        end for
    end if
end function

function fn015_set_seq_play_direction_btns
    for i.i := 0 to 2
        UIID_MAIN.seq.direction_btns [ fn015.a.side,  i.i] -> value := __OFF
    end for
    UIID_MAIN.seq.direction_btns [ fn015.a.side, fn015.a.btn_index] -> value := __ON
end function

function set_seq_target_selectors_text_alignment
    for i.i := 0 to 4
        UIID_MAIN.seq.target_selectors [ i.i ] -> text_alignment := abs(1 - switch_MAIN.SEQ.combine)
    end for
end function

function fn016_set_data_display_from_seq_xy
    select(SEQ.showing_target [ fn016.a.side ])
        case SEQ_TARGET_VELO  
            @fn016.r.title      := "velocity"
            if fn016.a.value * 127.0 = 0.0
                @fn016.r.text_data := "1"
            else
                @fn016.r.text_data := int(fn016.a.value * 127.0)
            end if

        case SEQ_TARGET_PITCH 
            @fn016.r.title      := "pitch"
            if UIID_MAIN.SEQ.xypads [ fn016.a.side ] -> key_shift = __ON
                @fn016.r.text_data := round((fn016.a.value * 24.0 - 12.0)*100.0)/100.0
            else
                @fn016.r.text_data := int(fn016.a.value * 24.0 - 12.0)
            end if

        case SEQ_TARGET_OCTAVE
            @fn016.r.title      := "octave"
            if UIID_MAIN.SEQ.xypads [ fn016.a.side ] -> key_shift = __ON
                @fn016.r.text_data := round((fn016.a.value * 4.0 - 2.0)*100.0)/100.0
            else
                @fn016.r.text_data := int(fn016.a.value * 4.0 - 2.0)
            end if

        case SEQ_TARGET_PAN
            @fn016.r.title      := "pan"
            if fn016.a.value < 0.49
                @fn016.r.text_data := int(100.0 - abs(fn016.a.value * 200.0)) & " L"
            else
                if fn016.a.value > 0.51
                    @fn016.r.text_data := int(abs((fn016.a.value-0.5) * 200.0)) & " R"
                else
                    @fn016.r.text_data := "Center"
                end if
            end if

        case SEQ_TARGET_FILTER
            if fn016.a.value < 0.49 { low  pass }
                set_engine_par(ENGINE_PAR_CUTOFF, int(fn016.a.value * 2000000.0), __NO_GROUP, __LP_FILTER_CA_SLOT, NI_BUS_OFFSET+15)
                @fn016.r.title     := "Low Pass"
                @fn016.r.text_data := get_engine_par_disp(ENGINE_PAR_CUTOFF, __NO_GROUP, __LP_FILTER_CA_SLOT, NI_BUS_OFFSET+15) & "hz"
            else                   { high pass }
                if fn016.a.value > 0.51
                    set_engine_par(ENGINE_PAR_CUTOFF, int((fn016.a.value-0.5) * 2000000.0), __NO_GROUP, __HP_FILTER_CA_SLOT, NI_BUS_OFFSET+15)
                    @fn016.r.title     := "High Pass"
                    @fn016.r.text_data := get_engine_par_disp(ENGINE_PAR_CUTOFF, __NO_GROUP, __HP_FILTER_CA_SLOT, NI_BUS_OFFSET+15) & "hz"
                else
                    @fn016.r.title     := "Filter Off"
                    @fn016.r.text_data := "Off"
                end if
            end if

    end select
end function

{ retrieves data from SEQ.data }
function fn017_get_seq_target_data
    if UIID_MAIN.seq.target_power [ fn017.a.side, SEQ_TARGET_VELO ] -> value = __ON
        fn017.l.seq_data := ...
                SEQ.data.i [                                            ...
                    fn017.a.side,                                       ...
                    SEQ_TARGET_VELO,                                    ...
                    fn017.a.step_counter + fn017.a.block_step_index * 8 ...
                ]
        if fn017.a.transform_value = __YES
            fn034.a.target_index := SEQ_TARGET_VELO
            fn034.a.value        := fn017.l.seq_data
            call fn034_transform_data_according_to_seq_target
            fn017.r.velocity := fn034.r.transf_value.i
        else
            fn017.r.velocity := fn017.l.seq_data
        end if
    else
        fn017.r.velocity := layers.note_velo [ fn017.a.side, fn017.a.key_note ]
    end if

    if UIID_MAIN.seq.target_power [ fn017.a.side, SEQ_TARGET_PITCH ] -> value = __ON
        fn017.l.seq_data := ...
                SEQ.data.i [                                            ...
                    fn017.a.side,                                       ...
                    SEQ_TARGET_PITCH,                                    ...
                    fn017.a.step_counter + fn017.a.block_step_index * 8 ...
                ]
        if fn017.a.transform_value = __YES
            fn034.a.target_index := SEQ_TARGET_PITCH
            fn034.a.value        := fn017.l.seq_data
            call fn034_transform_data_according_to_seq_target
            fn017.r.pitch := fn034.r.transf_value.i
        else
            fn017.r.pitch := fn017.l.seq_data
        end if
    else
        fn017.r.pitch := 0
    end if

    if UIID_MAIN.seq.target_power [ fn017.a.side, SEQ_TARGET_OCTAVE ] -> value = __ON
        fn017.l.seq_data := ...
                SEQ.data.i [                                            ...
                    fn017.a.side,                                       ...
                    SEQ_TARGET_OCTAVE,                                  ...
                    fn017.a.step_counter + fn017.a.block_step_index * 8 ...
                ]
        if fn017.a.transform_value = __YES
            fn034.a.target_index := SEQ_TARGET_OCTAVE
            fn034.a.value        := fn017.l.seq_data
            call fn034_transform_data_according_to_seq_target
            fn017.r.octave := fn034.r.transf_value.i
        else 
            fn017.r.octave := fn017.l.seq_data
        end if
    else
        fn017.r.octave := 0
    end if

    if UIID_MAIN.seq.target_power [ fn017.a.side, SEQ_TARGET_PAN ] -> value = __ON
        fn017.l.seq_data := ...
                SEQ.data.i [                                            ...
                    fn017.a.side,                                       ...
                    SEQ_TARGET_PAN,                                     ...
                    fn017.a.step_counter + fn017.a.block_step_index * 8 ...
                ]
        if fn017.a.transform_value = __YES
            fn034.a.target_index := SEQ_TARGET_PAN
            fn034.a.value        := fn017.l.seq_data
            call fn034_transform_data_according_to_seq_target
            fn017.r.pan := fn034.r.transf_value.i
        else
            fn017.r.pan := fn017.l.seq_data
        end if
    else
        fn017.r.pan := 0
    end if

    if UIID_MAIN.seq.target_power [ fn017.a.side, SEQ_TARGET_FILTER ] -> value = __ON
        fn017.r.filter_status := __ON
        fn017.l.seq_data := ...
                SEQ.data.i [                                            ...
                    fn017.a.side,                                       ...
                    SEQ_TARGET_FILTER,                                  ...
                    fn017.a.step_counter + fn017.a.block_step_index * 8 ...
                ]
        { not a transformation per se, just retrieveing the values 
         necessary for the lp/hp filters }
        fn034.a.target_index := SEQ_TARGET_FILTER
        fn034.a.value        := fn017.l.seq_data
        call fn034_transform_data_according_to_seq_target
        fn017.r.filter_value    := fn034.r.transf_value.i
        fn017.r.lp_filter_value := fn034.r.transf_value.i_lp
        fn017.r.hp_filter_value := fn034.r.transf_value.i_hp

    else
        fn017.r.filter_status := __OFF
        fn017.r.filter_value  := 500000
    end if
end function

function fn020_update_seq_target_off_label
    if fn020.a.seq_power_state = __ON
        if  fn020.a.target_power_uiid -> value = __OFF
            UIID_MAIN.seq.off_label [ fn020.a.side ] -> picture := "label_FX.off"
            UIID_MAIN.seq.off_label [ fn020.a.side ] -> UI_SHOW
            UIID_MAIN.seq.off_label [ fn020.a.side ] -> text := "TARGET " & SEQ.target_names [ fn020.a.target_index ] & " IS OFF"
        else
            UIID_MAIN.seq.off_label [ fn020.a.side ] -> UI_HIDE
        end if
    else
        UIID_MAIN.seq.off_label [ fn020.a.side ] -> UI_SHOW
        UIID_MAIN.seq.off_label [ fn020.a.side ] -> picture := "label_seq_steps_bg"
        UIID_MAIN.seq.off_label [ fn020.a.side ] -> text := "SEQUENCER IS OFF"
    end if
end function

function fn21_get_seq_target_active_activator
    for fn021.l.counter := 0 to 4 { 5 activator buttons per side }
        if  UIID_MAIN.seq.target_activators [ fn021.a.side, fn021.l.counter ] -> value = __ON
            fn021.r.active_index := fn021.l.counter
            exit
        end if
    end for
end function

{ this will be called when a block is about to start }
function fn022_get_flux_values
    if  UIID_MAIN.seq.flux_rand_btns  [ fn022.a.side, fn022.a.block_step_index ] -> value = __ON and ...
        UIID_MAIN.seq.flux_rand_power [ fn022.a.side ] -> value = __ON

        {{ FLUX RAND VELOCITY }}
        // if  fn017.a.step_counter = 0 { in case you want to do the randomization per block, not per step }
        { would still need the logic to populate all steps }

        if UIID_MAIN.seq.target_power [ fn022.a.side, SEQ_TARGET_VELO ] -> value = __ON
            { first get the seed based on the flux randomizer intensity amount }
            fn022.l.flux_velo_seed := int(1000000.0 * ...
                (float(SEQ.flux_rand_intensity [ fn022.a.side, SEQ_TARGET_VELO ] )/100.0) )
            { generate the actual flux offset value }
            fn022.l.flux_velo      := random( -1 * fn022.l.flux_velo_seed, fn022.l.flux_velo_seed)
            { add to the base value }
            fn022.r.step_velocity := fn022.a.step_velocity + fn022.l.flux_velo
            { clam if needed }
            if fn022.r.step_velocity > 1000000
                fn022.r.step_velocity := 1000000
            end if
            if fn022.r.step_velocity < 1
                fn022.r.step_velocity := 1
            end if

        end if

        {{ FLUX RAND PITCH }}
        if UIID_MAIN.seq.target_power [ fn022.a.side, SEQ_TARGET_PITCH ] -> value = __ON
            { flux rand intensity is 0:100, }
            fn022.l.flux_pitch_seed := int(1000000.0 * ...
                (float(SEQ.flux_rand_intensity [ fn022.a.side, SEQ_TARGET_PITCH ] ))/100.0)
            fn022.l.flux_pitch      := random( -1 * fn022.l.flux_pitch_seed, fn022.l.flux_pitch_seed)
            fn022.r.step_pitch := fn022.a.step_pitch + fn022.l.flux_pitch
            message(f'    fn022.l.flux_pitch_seed : <fn022.l.flux_pitch_seed>')
            message(f'    fn022.l.flux_pitch :      <fn022.l.flux_pitch>')
            message(f'    fn022.r.step_pitch :      <fn022.r.step_pitch>')
            if fn022.r.step_pitch > 1000000
                fn022.r.step_pitch := 1000000
            end if
            if fn022.r.step_pitch < 0
                fn022.r.step_pitch := 0
            end if
            message(f'    fn022.r.step_pitch :      <fn022.r.step_pitch>')
        end if

        {{ FLUX RAND OCTAVE }}
        if UIID_MAIN.seq.target_power [ fn022.a.side, SEQ_TARGET_OCTAVE ] -> value = __ON
            fn022.l.flux_octave_seed := int(1000000.0 * ...
                (float(SEQ.flux_rand_intensity [ fn022.a.side, SEQ_TARGET_OCTAVE ] )/100.0) )
            fn022.l.flux_octave      := random( -1 * fn022.l.flux_octave_seed, fn022.l.flux_octave_seed)
            fn022.r.step_octave := fn022.a.step_octave + fn022.l.flux_octave
            if fn022.r.step_octave > 1000000
                fn022.r.step_octave := 1000000
            end if
            if fn022.r.step_octave < 0
                fn022.r.step_octave := 0
            end if
        end if
        
        {{ FLUX RAND PAN }}
        if UIID_MAIN.seq.target_power [ fn022.a.side, SEQ_TARGET_PAN ] -> value = __ON
            fn022.l.flux_pan_seed := int(1000000.0 * ...
                (float(SEQ.flux_rand_intensity [ fn022.a.side, SEQ_TARGET_PAN ] )/100.0) )
            fn022.l.flux_pan      := random( -1 * fn022.l.flux_pan_seed, fn022.l.flux_pan_seed)
            fn022.r.step_pan := fn022.a.step_pan + fn022.l.flux_pan
            if fn022.r.step_pan > 1000000
                fn022.r.step_pan := 1000000
            end if
            if fn022.r.step_pan < 0
                fn022.r.step_pan := 0
            end if
        end if

        {{ FLUX RAND PAN }}
        if UIID_MAIN.seq.target_power [ fn022.a.side, SEQ_TARGET_FILTER ] -> value = __ON
            { not scaling by /100 because the extreme values of the filter just completely close the sound
            so scaling by 150 instead of 100 }
            fn022.l.flux_filter_seed := int(1000000.0 * ...
                (float(SEQ.flux_rand_intensity [ fn022.a.side, SEQ_TARGET_FILTER ] )/150.0) )
            fn022.l.flux_filter      := random( -1 * fn022.l.flux_filter_seed, fn022.l.flux_filter_seed)
            fn022.r.step_filter := fn022.a.step_filter + fn022.l.flux_filter
            if fn022.r.step_filter > 850000
                fn022.r.step_filter := 850000
            end if
            if fn022.r.step_filter < 150000
                fn022.r.step_filter := 150000
            end if
            if fn022.r.step_filter > 500000 { high pass }
                fn022.r.step_lp_filter := 1000000
                fn022.r.step_hp_filter := ( fn022.r.step_filter - 500000 ) * 2
            else                        { low pass }
                fn022.r.step_lp_filter := fn022.r.step_filter * 2
                fn022.r.step_hp_filter := 0
            end if
        end if

        { update the step picture we need scaled values 0:1 }
        if UIID_MAIN.seq.target_power [ fn022.a.side, SEQ.showing_target [ fn022.a.side ] ] -> value = __ON
            select(SEQ.showing_target [ fn022.a.side ])
                case SEQ_TARGET_VELO
                    fn018.a.value      := float(fn022.r.step_velocity)/127.0
                case SEQ_TARGET_PITCH
                    fn018.a.value      := float(fn022.r.step_pitch + 1200000)/2400000.0
                case SEQ_TARGET_OCTAVE
                    fn018.a.value      := float(fn022.r.step_octave + 2)/4.0
                case SEQ_TARGET_PAN
                    fn018.a.value      := float(fn022.r.step_pan + 1000)/2000.0
                case SEQ_TARGET_FILTER
                    fn018.a.value      := float(fn022.r.step_filter)/850000.0
            end select
            
            fn018.a.side       := fn022.a.side
            fn018.a.step_index := fn022.a.step_counter + fn022.a.block_step_index * 8
            call fn018_set_seq_step_picture_state
        end if

    end if
end function 

function fn029_clear_arp_mode_btns
    for fn029.l.counter := 0 to 5
        UIID_MAIN.seq.arp_menu_items [ fn029.a.side, fn029.l.counter ] -> value := __OFF
    end for
    UIID_MAIN.seq.arp_menu_items [ fn029.a.side, fn029.a.index ] -> value := __ON
end function

function fn033_transform_step_value_into_dynamic
    if fn033.a.dyn_value >= 0.5
        fn033.l.dyn_transf_value := abs(2.0 * fn033.a.dyn_value - 1.0 )
    else
        fn033.l.dyn_transf_value := 2.0 * fn033.a.dyn_value
    end if

    if fn033.a.dyn_value >= 0.5
        fn033.l.delta_max      := 1.0 - fn033.a.step_value
        fn033.r.transf_value.r := fn033.a.step_value + fn033.l.delta_max * fn033.l.dyn_transf_value
    else
        fn033.r.transf_value.r := fn033.a.step_value * fn033.l.dyn_transf_value
    end if
    fn033.r.transf_value.i := int( 1000000.0 * fn033.r.transf_value.r )
end function

function fn030_set_seq_step_dyn_value
    if switch_MAIN.SEQ.combine = __SEQ_DUAL
        fn030.l.mode_side := fn030.a.side
    else
        fn030.l.mode_side := __LEFT
    end if

    fn033.a.dyn_value := ...
        get_control_par_real_arr(                       ...
            UIID_MAIN.seq.dyn_slider [ fn030.a.side ], ...
            CONTROL_PAR_VALUE,                          ...
            1                                           ...
        )
    fn033.a.step_value := fn030.a.value
    call fn033_transform_step_value_into_dynamic

    SEQ.data.dyn.i [        ...
        fn030.a.side,       ...
        fn030.a.target,     ...
        fn030.a.step_index  ...
    ] := int( 1000000.0 * fn033.r.transf_value.r )

    SEQ.data.dyn.f [        ...
        fn030.a.side,       ...
        fn030.a.target,     ...
        fn030.a.step_index  ...
    ] := fn033.r.transf_value.r
end function

function fn031_set_dyn_sliders_picture
    { update the ui label for the dyn slider }
    if fn031.a.reset = __OFF
        if  UIID_MAIN.seq.dyn_slider [ fn031.a.side ] -> key_control = __OFF

            UIID_MAIN.seq.dyn_slider.label [ fn031.a.side ] -> picture_state := int ( ...
                get_control_par_real_arr(                       ...
                    UIID_MAIN.seq.dyn_slider [ fn031.a.side ],  ...
                    CONTROL_PAR_VALUE,                          ...
                    1                                           ...
                ) * 132.0 )

        else
            UIID_MAIN.seq.dyn_slider.label [ fn031.a.side ] -> picture_state := 66

            set_control_par_real_arr(                       ...
                UIID_MAIN.seq.dyn_slider [ fn031.a.side ],  ...
                CONTROL_PAR_VALUE,                          ...
                0.5,                                        ...
                1                                           ...
            )
        end if

    else
        UIID_MAIN.seq.dyn_slider.label [ fn031.a.side ] -> picture_state := 66

        set_control_par_real_arr(                       ...
            UIID_MAIN.seq.dyn_slider [ fn031.a.side ],  ...
            CONTROL_PAR_VALUE,                          ...
            0.5,                                        ...
            1                                           ...
        )
    end if

    {
        - a step has int and float values stored
        - when we press mouse down any subsequent update in the
        slider (y axis) will 
            - read from SEQ.data.f and update the sequencer steps pictures
            - the new step values will be stored in 
                SEQ.data.dyn.i
                SEQ.data.dyn.f

            but what does it mean? 
            means that when the flux rand runs, it will update its 
            arrays based on these dyn slider arrays rather than the original arrays

            update the SEQ.data.dyn.f with the new values calculated from
            the SEQ.data.i and the current slider value
            what's the calculation?
    }
end function

function fn032_set_seq_step_value_and_ui_via_dyn_slider
    { as of 3/2025 the syn slider will only act on the 
     velocity target. In case we want to expand this later
     to any target, we have to use SEQ.showing_target [ fn032.a.side ] 
     instead of the VELO constant on the target argument }

    fn002.a.table_to_update := __SEQ_DYN_TRANSF_TABLE

    for fn032.l.block_index := 0 to 3
        for fn032.l.step_index := 0 to 7
            fn002.a.step_index := fn032.l.block_index * 8 + fn032.l.step_index
            fn002.a.side       := fn032.a.side

            if  UIID_MAIN.seq.flux_rand_btns  [ ...
                    fn032.a.side,               ...
                    fn032.l.block_index         ...
                ] -> value = __ON and           ...
                UIID_MAIN.seq.flux_rand_power [ fn032.a.side ] -> value = __ON

                // Flux SEQ data 
                fn002.a.value      :=                                ...
                    SEQ.data.flux.f [                                ...
                        fn032.a.side,                                ...
                        SEQ_TARGET_VELO,                             ...
                        fn032.l.block_index * 8 + fn032.l.step_index ...
                    ]
            else
                // original SEQ data 
                fn002.a.value      :=                                ...
                    SEQ.data.f [                                     ...
                        fn032.a.side,                                ...
                        SEQ_TARGET_VELO,                             ...
                        fn032.l.block_index * 8 + fn032.l.step_index ...
                    ]

            end if

            fn002.a.side            := fn032.a.side
            fn002.a.target          := SEQ_TARGET_VELO
            fn002.a.table_to_update := __SEQ_DYN_TRANSF_TABLE
            fn002.a.step_index      := fn032.l.block_index * 8 + fn032.l.step_index
            call fn002_set_seq_step_value

            if SEQ.showing_target [ fn032.a.side ] = SEQ_TARGET_VELO
                fn018.a.side       := fn032.a.side
                fn018.a.step_index := fn032.l.block_index * 8 + fn032.l.step_index
                fn018.a.value      :=                        ...
                    SEQ.data.dyn.f [                         ...
                        fn032.a.side,                        ...
                        SEQ.showing_target [ fn032.a.side ], ... // because target is SEQ_TARGET_VELO here 
                        fn018.a.step_index                   ...
                    ]
                call fn018_set_seq_step_picture_state
            end if
        end for
    end for
end function

function fn034_transform_data_according_to_seq_target
    select (fn034.a.target_index)
        case SEQ_TARGET_VELO
            fn034.r.transf_value.i := ((126 * fn034.a.value) / 1000000) + 1

        case SEQ_TARGET_PITCH
            fn034.r.transf_value.i := ((24 * fn034.a.value) / 1000000) - 12

        case SEQ_TARGET_OCTAVE
            fn034.r.transf_value.i := ((4 * fn034.a.value) / 1000000) - 2

        case SEQ_TARGET_PAN
            if fn034.a.value < 500000
                fn034.r.transf_value.i := (-1) * (1000 - fn034.a.value / 500)
            else
                if fn034.a.value > 500000
                    fn034.r.transf_value.i := (fn034.a.value-500000) / 500
                else
                    fn034.r.transf_value.i := 0
                end if
            end if

        case SEQ_TARGET_FILTER
            fn034.r.transf_value.i := fn034.a.value
            
            if fn034.r.transf_value.i < 490000  { low pass }
                fn034.r.transf_value.i_lp := fn034.r.transf_value.i * 2
                fn034.r.transf_value.i_hp := 0
            else                             { high pass }
                if fn034.r.transf_value.i > 510000
                    fn034.r.transf_value.i_lp := 1000000
                    fn034.r.transf_value.i_hp := (fn034.r.transf_value.i - 500000) * 2
                else { center point, both filters off }
                    fn034.r.transf_value.i_lp := 1000000
                    fn034.r.transf_value.i_hp := 0
                end if 
            end if
            fn034.r.transf_value.r_lp := float(fn034.r.transf_value.i_lp)/1000000.0
            fn034.r.transf_value.r_hp := float(fn034.r.transf_value.i_hp)/1000000.0

    end select

    fn034.r.transf_value.r := float(fn034.a.value)/1000000.0
end function


{{ play engine ____________________________________________________________________ }}
function fn007_update_block_and_steps_ts
    if switch_MAIN.SEQ.combine = __SEQ_DUAL

        { update current block index, current block step duration and 
          each step's timestamp }
        if  seq.direction_status [ fn007.a.side ] = SEQ_DIRECTION_FORWARD
            inc(SEQ.DUAL.current_block [ fn007.a.side ])

            { block start, update the flux values and UI }
            if SEQ.DUAL.current_block [ fn007.a.side ] > 3
                { check the actual selected direction button }
                if  layers.seq_play_direction [ fn007.a.side ] = SEQ_DIRECTION_FWBW
                    SEQ.DUAL.current_block [ fn007.a.side ] := 3
                    seq.direction_status [ fn007.a.side ] := SEQ_DIRECTION_BACKWARD
                else { regular forward motion }
                    SEQ.DUAL.current_block [ fn007.a.side ] := 0
                end if
            end if

            { Update step duration }
            SEQ.DUAL.step_duration [ fn007.a.side ] := ...
                SEQ.rate [ fn007.a.side ] / ( SEQ.DUAL.step_count [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ] ] + 1 )

            { Generate timestamps for each step in the block }
            for s.i := 0 to SEQ.DUAL.step_count [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ] ]
                SEQ.DUAL.steps_timestamps [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ], s.i ] := ...
                    ENGINE_UPTIME + s.i * SEQ.DUAL.step_duration [ fn007.a.side ]
            end for

        else
            if  seq.direction_status [ fn007.a.side ] = SEQ_DIRECTION_BACKWARD 
                dec(SEQ.DUAL.current_block [ fn007.a.side ])
                if SEQ.DUAL.current_block [ fn007.a.side ] < 0
                    if layers.seq_play_direction [ fn007.a.side ] = SEQ_DIRECTION_FWBW
                        SEQ.DUAL.current_block [ fn007.a.side ] := 0
                        seq.direction_status [ fn007.a.side ] := SEQ_DIRECTION_FORWARD
                    else { regular backward motion }
                        SEQ.DUAL.current_block [ fn007.a.side ] := 3 
                    end if
                end if

                SEQ.DUAL.step_duration [ fn007.a.side ] := ...
                    SEQ.rate [ fn007.a.side ] / ( SEQ.DUAL.step_count [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ] ] + 1 )

                for s.i := 0 to SEQ.DUAL.step_count [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ] ]
                    SEQ.DUAL.steps_timestamps [ fn007.a.side, SEQ.DUAL.current_block [ fn007.a.side ], s.i ] := ...
                        ENGINE_UPTIME + s.i * SEQ.DUAL.step_duration [ fn007.a.side ]
                end for
            end if

        end if

        if UIID_MAIN.seq.flux_rand_power [ fn007.a.side ] -> value = __ON
            {{ UPDATES WHOLE BLOCK FLUX DATA and UI STEPS ACCORDING TO FLUX RANDOMIZER INFLUENCE }}
            fn025.a.side := fn007.a.side
            call fn025_update_flux_on_all_block_steps
        end if

    else { JOIN sequencer }

        inc(SEQ.JOIN.current_block )
        if SEQ.JOIN.current_block  > 7
            SEQ.JOIN.current_block  := 0
        end if

        SEQ.JOIN.step_duration := ...
            SEQ.rate [ __LEFT ] / ( SEQ.JOIN.step_count [ SEQ.JOIN.current_block ] + 1 )

        for s.i := 0 to SEQ.JOIN.step_count [ SEQ.JOIN.current_block ]
            SEQ.JOIN.steps_timestamps [ SEQ.JOIN.current_block, s.i ] := ...
                ENGINE_UPTIME + s.i * SEQ.JOIN.step_duration
        end for

    end if 
end function

{ not really being used }
function fn023_check_block_start
    fn023.r.check := 0
    if fn023.a.counter = 0
        fn023.r.check := fn023.r.check .or. __STEP_COUNTER_0 // 1
    end if
    if UIID_MAIN.seq.direction_btns [ fn023.a.side, 0 ] -> value = __ON
        fn023.r.check := fn023.r.check .or. __DIR_BTN_FORWARD //2
    end if
    if UIID_MAIN.seq.direction_btns [ fn023.a.side, 1 ] -> value = __ON
        fn023.r.check := fn023.r.check .or. __DIR_BTN_BACKWARD //4
    end if
    if UIID_MAIN.seq.direction_btns [ fn023.a.side, 2 ] -> value = __ON
        fn023.r.check := fn023.r.check .or. __DIR_BTN_FWBW //8
    end if
    if SEQ.ts_counter = SEQ.DUAL.step_count [ fn023.a.side, SEQ.DUAL.current_block [ fn023.a.side ] ]
        fn023.r.check := fn023.r.check .or. __STEP_COUNTER_LAST //16
    end if
    if seq.direction_status [ fn023.a.side ] = SEQ_DIRECTION_FORWARD
        fn023.r.check := fn023.r.check .or. __DIR_PLAY_FORWARD //32
    end if
    if seq.direction_status [ fn023.a.side ] = SEQ_DIRECTION_BACKWARD
        fn023.r.check := fn023.r.check .or. __DIR_PLAY_BACKWARD //64
    end if
end function

{ this function will update the SEQ.data.flux.i/f arrays and the steps height on th UI in the current block }
function fn024_update_flux_data_and_ui
    { at this moment (03/2025) the velocity is the only parameter
     being affected by the dynamic slider }
    {{ VELOCITY }}
    fn033.a.dyn_value := ...
        get_control_par_real_arr(                       ...
            UIID_MAIN.seq.dyn_slider [ fn024.a.side ], ...
            CONTROL_PAR_VALUE,                          ...
            1                                           ...
        )
    fn033.a.step_value := float(fn024.a.step_velocity)/1000000.0
    // message(f'input value: <fn033.a.step_value>')
    call fn033_transform_step_value_into_dynamic
    // message(f'output value: <fn033.r.transf_value.r>')
    SEQ.data.flux.i [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_VELO,                                    ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := fn033.r.transf_value.i

    SEQ.data.flux.f [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_VELO,                                    ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := fn033.r.transf_value.r

    fn024.l.step_velocity_flux := fn033.r.transf_value.r


    message(f'fn024: input PITCH value: <fn024.a.step_pitch>')
    {{ PITCH }}
    SEQ.data.flux.i [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_PITCH,                                   ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := fn024.a.step_pitch

    SEQ.data.flux.f [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_PITCH,                                   ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := float(fn024.a.step_pitch)/1000000.0
    fn024.l.step_pitch_flux := float(fn024.a.step_pitch)/1000000.0


    {{ OCTAVE }}
    SEQ.data.flux.i [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_OCTAVE,                                  ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := fn024.a.step_octave

    SEQ.data.flux.f [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_OCTAVE,                                  ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := float(fn024.a.step_octave)/1000000.0
    fn024.l.step_octave_flux := float(fn024.a.step_octave)/1000000.0


    {{ PAN }}
    SEQ.data.flux.i [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_PAN,                                     ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := fn024.a.step_pan

    SEQ.data.flux.f [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_PAN,                                     ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := float(fn024.a.step_pan)/1000000.0
    fn024.l.step_pan_flux := float(fn024.a.step_pan)/1000000.0


    {{ FILTER }}
    SEQ.data.flux.i [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_FILTER,                                  ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := fn024.a.step_filter

    SEQ.data.flux.f [                                       ...
        fn024.a.side,                                       ...
        SEQ_TARGET_FILTER,                                  ...
        fn024.a.step_counter + fn024.a.block_step_index * 8 ...
    ] := float(fn024.a.step_filter)/1000000.0
    fn024.l.step_filter_flux := float(fn024.a.step_filter)/1000000.0

    select(SEQ.showing_target [ fn024.a.side ])
        case SEQ_TARGET_VELO
            fn024.l.picture_state := fn024.l.step_velocity_flux
        case SEQ_TARGET_PITCH
            fn024.l.picture_state := fn024.l.step_pitch_flux
        case SEQ_TARGET_OCTAVE
            fn024.l.picture_state := fn024.l.step_octave_flux
        case SEQ_TARGET_PAN
            fn024.l.picture_state := fn024.l.step_pan_flux
        case SEQ_TARGET_FILTER
            fn024.l.picture_state := fn024.l.step_filter_flux
    end select

    { update ui step picture value }
    UIID_MAIN.seq.step [ fn024.a.side, fn024.a.step_counter + fn024.a.block_step_index * 8 ] -> picture_state := ...
        int(float(SEQ_XY_H-1) * fn024.l.picture_state)
end function

function fn025_update_flux_on_all_block_steps
    if  SEQ.DUAL.current_block [ fn025.a.side ] = 0 and seq.direction_status [ fn025.a.side ] = SEQ_DIRECTION_FORWARD or ...
        SEQ.DUAL.current_block [ fn025.a.side ] = 3  and seq.direction_status [ fn025.a.side ] = SEQ_DIRECTION_BACKWARD

        for fn025.l.counter2 := 0 to 3
            if  UIID_MAIN.seq.flux_rand_btns  [ fn025.a.side, fn025.l.counter2 ] -> value = __ON and ...
                UIID_MAIN.seq.flux_rand_power [ fn025.a.side ] -> value = __ON
                for fn025.l.counter := 0 to SEQ.DUAL.step_count [ fn025.a.side, fn025.l.counter2 ]

                    { retrieves data from the SEQ.data table }
                    fn017.a.transform_value  := __NO
                    fn017.a.side             := fn025.a.side
                    fn017.a.step_counter     := fn025.l.counter
                    fn017.a.block_step_index := fn025.l.counter2
                    call fn017_get_seq_target_data
                    { return values from fn017_get_seq_target_data() used below }

                    // message(f'<fn025.l.counter2> | <fn025.l.counter> | fn017.r.velocity : <fn017.r.velocity >')
                    message(f'<fn025.l.counter2> | <fn025.l.counter> | fn017.r.pitch : <fn017.r.pitch >')
                    fn022.a.side             := fn025.a.side
                    fn022.a.step_counter     := fn025.l.counter
                    fn022.a.block_step_index := fn025.l.counter2
                    fn022.a.step_velocity    := fn017.r.velocity     // value returned from fn017
                    fn022.a.step_pitch       := fn017.r.pitch        // value returned from fn017
                    fn022.a.step_octave      := fn017.r.octave       // value returned from fn017
                    fn022.a.step_pan         := fn017.r.pan          // value returned from fn017
                    fn022.a.step_filter      := fn017.r.filter_value // value returned from fn017
                    call fn022_get_flux_values

                    {{ LOG }}
                        // message(f'    <fn025.l.counter2> | <fn025.l.counter> | fn022.a.step_velocity : <fn022.a.step_velocity >')
                        message(f'<fn025.l.counter2> | <fn025.l.counter> | fn024.a.step_pitch    : <fn024.a.step_pitch    >')
                        // message(f'<fn025.l.counter2> | <fn025.l.counter> | fn024.a.step_octave   : <fn024.a.step_octave   >')
                        // message(f'<fn025.l.counter2> | <fn025.l.counter> | fn024.a.step_pan      : <fn024.a.step_pan      >')
                        // message(f'<fn025.l.counter2> | <fn025.l.counter> | fn024.a.step_filter   : <fn024.a.step_filter   >')
                        // message(f'<fn025.l.counter2> | <fn025.l.counter> | fn024.a.step_lp_filter: <fn024.a.step_lp_filter>')
                        // message(f'<fn025.l.counter2> | <fn025.l.counter> | fn024.a.step_hp_filter: <fn024.a.step_hp_filter>')

                    fn024.a.step_velocity    := fn022.r.step_velocity
                    fn024.a.step_pitch       := fn022.r.step_pitch
                    fn024.a.step_octave      := fn022.r.step_octave
                    fn024.a.step_pan         := fn022.r.step_pan
                    fn024.a.step_filter      := fn022.r.step_filter
                    fn024.a.step_lp_filter   := fn022.r.step_lp_filter
                    fn024.a.step_hp_filter   := fn022.r.step_hp_filter
                    fn024.a.side             := fn025.a.side
                    fn024.a.step_counter     := fn025.l.counter
                    fn024.a.block_step_index := fn025.l.counter2
                    call fn024_update_flux_data_and_ui

                    fn033.a.dyn_value := ...
                        get_control_par_real_arr(                       ...
                            UIID_MAIN.seq.dyn_slider [ fn025.a.side ], ...
                            CONTROL_PAR_VALUE,                          ...
                            1                                           ...
                        )
                    fn033.a.step_value := ...
                        SEQ.data.flux.f [                          ...
                            fn025.a.side,                          ...
                            SEQ_TARGET_VELO,                       ...
                            fn025.l.counter2 * 8 + fn025.l.counter ...
                        ]

                    call fn033_transform_step_value_into_dynamic

                    SEQ.data.dyn.i [                          ...
                        fn025.a.side,                          ...
                        SEQ_TARGET_VELO,                       ...
                        fn025.l.counter2 * 8 + fn025.l.counter ...
                    ] := fn033.r.transf_value.i

                    SEQ.data.dyn.f [                          ...
                        fn025.a.side,                          ...
                        SEQ_TARGET_VELO,                       ...
                        fn025.l.counter2 * 8 + fn025.l.counter ...
                    ] := fn033.r.transf_value.r

                    // message(f'    <fn025.l.counter2> | <fn025.l.counter> | fn024.a.step_velocity : <fn024.a.step_velocity >')
                    message(f'    <fn025.l.counter2> | <fn025.l.counter> | fn024.a.step_pitch : <fn024.a.step_pitch >')
                end for
            end if
        end for
    end if
end function

function fn026_get_seq_target_data
    if UIID_MAIN.seq.target_power [ fn026.a.side, SEQ_TARGET_VELO ] -> value = __ON
        if fn026.a.data_type = __FLUX_DATA
            fn026.r.velocity := (                                       ...
                SEQ.data.flux.i [                                       ...
                    fn026.a.side,                                       ...
                    SEQ_TARGET_VELO,                                    ...
                    fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                ] )
        else
            if fn026.a.data_type = __DYN_DATA
                fn026.r.velocity := ...
                    SEQ.data.dyn.i [                                        ...
                        fn026.a.side,                                       ...
                        SEQ_TARGET_VELO,                                    ...
                        fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                    ]
            end if
        end if

        fn034.a.target_index := SEQ_TARGET_VELO
        fn034.a.value        := fn026.r.velocity
        call fn034_transform_data_according_to_seq_target
        fn026.r.velocity     := fn034.r.transf_value.i

    else
        fn026.r.velocity := layers.note_velo [ fn026.a.side, fn026.a.key_note ]
    end if

    if UIID_MAIN.seq.target_power [ fn026.a.side, SEQ_TARGET_PITCH ] -> value = __ON
        if fn026.a.data_type = __FLUX_DATA
            fn026.r.pitch := (                                          ...
                SEQ.data.flux.i [                                       ...
                    fn026.a.side,                                       ...
                    SEQ_TARGET_PITCH,                                   ...
                    fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                ] )
        else
            { DYN is only for Velocity, here used to differentiate from FLUX }
            if fn026.a.data_type = __DYN_DATA 
                fn026.r.pitch := ...
                    SEQ.data.i [                                            ...
                        fn026.a.side,                                       ...
                        SEQ_TARGET_PITCH,                                   ...
                        fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                    ]
            end if
        end if

        fn034.a.target_index := SEQ_TARGET_PITCH
        fn034.a.value        := fn026.r.pitch
        call fn034_transform_data_according_to_seq_target
        fn026.r.pitch        := fn034.r.transf_value.i

    else
        fn026.r.pitch := 0
    end if

    if UIID_MAIN.seq.target_power [ fn026.a.side, SEQ_TARGET_OCTAVE ] -> value = __ON
        if fn026.a.data_type = __FLUX_DATA
            fn026.r.octave := (                                         ...
                SEQ.data.flux.i [                                       ...
                    fn026.a.side,                                       ...
                    SEQ_TARGET_OCTAVE,                                  ...
                    fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                ] )
        else
            { DYN is only for Velocity, here used to differentiate from FLUX }
            if fn026.a.data_type = __DYN_DATA
                fn026.r.octave := ...
                    SEQ.data.i [                                            ...
                        fn026.a.side,                                       ...
                        SEQ_TARGET_OCTAVE,                                  ...
                        fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                    ]
            end if
        end if

        fn034.a.target_index := SEQ_TARGET_OCTAVE
        fn034.a.value        := fn026.r.octave
        call fn034_transform_data_according_to_seq_target
        fn026.r.octave        := fn034.r.transf_value.i

    else
        fn026.r.octave := 0
    end if

    if UIID_MAIN.seq.target_power [ fn026.a.side, SEQ_TARGET_PAN ] -> value = __ON
        if fn026.a.data_type = __FLUX_DATA
            fn026.r.pan := (                                            ...
                SEQ.data.flux.i [                                       ...
                    fn026.a.side,                                       ...
                    SEQ_TARGET_PAN,                                     ...
                    fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                ] )
        else
            { DYN is only for Velocity, here used to differentiate from FLUX }
            if fn026.a.data_type = __DYN_DATA
                fn026.r.pan := ...
                    SEQ.data.i [                                            ...
                        fn026.a.side,                                       ...
                        SEQ_TARGET_PAN,                                     ...
                        fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                    ]
            end if
        end if

        fn034.a.target_index := SEQ_TARGET_PAN
        fn034.a.value        := fn026.r.pan
        call fn034_transform_data_according_to_seq_target
        fn026.r.pan          := fn034.r.transf_value.i

    else
        fn026.r.pan := 0
    end if

    if UIID_MAIN.seq.target_power [ fn026.a.side, SEQ_TARGET_FILTER ] -> value = __ON
        fn026.r.filter_status := __ON
        if fn026.a.data_type = __FLUX_DATA
            fn026.r.pan := (                                            ...
                SEQ.data.flux.i [                                       ...
                    fn026.a.side,                                       ...
                    SEQ_TARGET_FILTER,                                  ...
                    fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                ] )
        else
            { DYN is only for Velocity, here used to differentiate from FLUX }
            if fn026.a.data_type = __DYN_DATA
                fn026.r.filter_value := ...
                    SEQ.data.i [                                            ...
                        fn026.a.side,                                       ...
                        SEQ_TARGET_FILTER,                                  ...
                        fn026.a.step_counter + fn026.a.block_step_index * 8 ...
                    ]
                
            end if
        end if

        fn034.a.target_index := SEQ_TARGET_FILTER
        fn034.a.value        := fn026.r.filter_value
        call fn034_transform_data_according_to_seq_target
        fn026.r.filter_value    := fn034.r.transf_value.i
        fn026.r.lp_filter_value := fn034.r.transf_value.i_lp
        fn026.r.hp_filter_value := fn034.r.transf_value.i_hp

    else
        fn026.r.filter_status := __OFF
        fn026.r.filter_value  := 500000
    end if
end function

function fn028_update_arp_note_buffers
    if fn028.a.side = __LEFT
        ARP.i := 0
        while (ARP.i <= 127)
            if (ARP.i < ARP.cursor [ fn028.a.side ] )
                ARP.sorted_buffer_LEFT      [ ARP.i ] := ARP.note_buffer_LEFT [ ARP.i ]
                ARP.sorted_vel_buffer_LEFT  [ ARP.i ] := ARP.vel_buffer_LEFT  [ ARP.i ]
            else
                ARP.sorted_buffer_LEFT     [ ARP.i ] := 0
                ARP.sorted_vel_buffer_LEFT [ ARP.i ] := -1
                ARP.note_buffer_LEFT       [ ARP.i ] := 0
                ARP.vel_buffer_LEFT        [ ARP.i ] := -1
            end if

            inc(ARP.i)
        end while
        { using insertion sort here because the velocity buffer needs to follow the sorting of the note buffer }
        ARP.o := 1
        while ( ARP.o < num_elements(ARP.sorted_buffer_LEFT))
            ARP.temp1 := ARP.sorted_buffer_LEFT     [ ARP.o]
            ARP.temp2 := ARP.sorted_vel_buffer_LEFT [ ARP.o]

            ARP.p :=  ARP.o - 1
            while ( ARP.p >= 0 and ( ARP.sorted_buffer_LEFT [ ARP.p ] <  ARP.temp1 ) )
                ARP.sorted_buffer_LEFT     [ ARP.p + 1] := ARP.sorted_buffer_LEFT     [ ARP.p ]
                ARP.sorted_vel_buffer_LEFT [ ARP.p + 1] := ARP.sorted_vel_buffer_LEFT [ ARP.p ]
                dec( ARP.p )
            end while

            ARP.sorted_buffer_LEFT     [ ARP.p + 1 ] :=  ARP.temp1
            ARP.sorted_vel_buffer_LEFT [ ARP.p + 1 ] :=  ARP.temp2

            inc( ARP.o)
        end while

        { create play buffers }
        ARP.i := 0
        while ( ARP.i <  ARP.cursor [ fn028.a.side ] )
            ARP.play_buffer_LEFT          [ ARP.i ] := ARP.note_buffer_LEFT       [ ARP.i ]
            ARP.play_up_buffer_LEFT       [ ARP.i ] := ARP.sorted_buffer_LEFT     [ ARP.cursor [ fn028.a.side ] - 1 -  ARP.i ]
            ARP.play_down_buffer_LEFT     [ ARP.i ] := ARP.sorted_buffer_LEFT     [ ARP.i ]
            ARP.play_vel_buffer_LEFT      [ ARP.i ] := ARP.vel_buffer_LEFT        [ ARP.i ]
            ARP.play_up_vel_buffer_LEFT   [ ARP.i ] := ARP.sorted_vel_buffer_LEFT [ ARP.cursor [ fn028.a.side ] - 1 -  ARP.i ]
            ARP.play_down_vel_buffer_LEFT [ ARP.i ] := ARP.sorted_vel_buffer_LEFT [ ARP.i ]

            inc( ARP.i )
        end while

    else
        ARP.i := 0
        while (ARP.i <= 127)
            if (ARP.i < ARP.cursor [ fn028.a.side ])
                ARP.sorted_buffer_RIGHT      [ ARP.i ] := ARP.note_buffer_RIGHT [ ARP.i ]
                ARP.sorted_vel_buffer_RIGHT  [ ARP.i ] := ARP.vel_buffer_RIGHT  [ ARP.i ]
            else
                ARP.sorted_buffer_RIGHT     [ ARP.i ] := 0
                ARP.sorted_vel_buffer_RIGHT [ ARP.i ] := -1
                ARP.note_buffer_RIGHT       [ ARP.i ] := 0
                ARP.vel_buffer_RIGHT        [ ARP.i ] := -1
            end if

            inc(ARP.i)
        end while
        { using insertion sort here because the velocity buffer needs to follow the sorting of the note buffer }
        ARP.o := 1
        while ( ARP.o < num_elements(ARP.sorted_buffer_RIGHT))
            ARP.temp1 := ARP.sorted_buffer_RIGHT     [ ARP.o]
            ARP.temp2 := ARP.sorted_vel_buffer_RIGHT [ ARP.o]

            ARP.p :=  ARP.o - 1
            while ( ARP.p >= 0 and ( ARP.sorted_buffer_RIGHT [ ARP.p ] <  ARP.temp1 ) )
                ARP.sorted_buffer_RIGHT     [ ARP.p + 1] := ARP.sorted_buffer_RIGHT     [ ARP.p ]
                ARP.sorted_vel_buffer_RIGHT [ ARP.p + 1] := ARP.sorted_vel_buffer_RIGHT [ ARP.p ]
                dec( ARP.p )
            end while

            ARP.sorted_buffer_RIGHT     [ ARP.p + 1 ] :=  ARP.temp1
            ARP.sorted_vel_buffer_RIGHT [ ARP.p + 1 ] :=  ARP.temp2

            inc( ARP.o)
        end while

        { create play buffers }
        ARP.i := 0
        while ( ARP.i <  ARP.cursor [ fn028.a.side ] )
            ARP.play_buffer_RIGHT          [ ARP.i ] := ARP.note_buffer_RIGHT       [ ARP.i ]
            ARP.play_up_buffer_RIGHT       [ ARP.i ] := ARP.sorted_buffer_RIGHT     [ ARP.cursor [ fn028.a.side ] - 1 -  ARP.i ]
            ARP.play_down_buffer_RIGHT     [ ARP.i ] := ARP.sorted_buffer_RIGHT     [ ARP.i ]
            ARP.play_vel_buffer_RIGHT      [ ARP.i ] := ARP.vel_buffer_RIGHT        [ ARP.i ]
            ARP.play_up_vel_buffer_RIGHT   [ ARP.i ] := ARP.sorted_vel_buffer_RIGHT [ ARP.cursor [ fn028.a.side ] - 1 -  ARP.i ]
            ARP.play_down_vel_buffer_RIGHT [ ARP.i ] := ARP.sorted_vel_buffer_RIGHT [ ARP.i ]

            inc( ARP.i )
        end while
    end if
end function

function seq.arp.get_play_note_from_buffer
    select (arp_mode[ p_lcb.a.side ])
        case __ARP_MODE_AS_PLAYED
            if p_lcb.a.side = __LEFT
                ARP.played_note [ p_lcb.a.side ]     := ARP.play_buffer_LEFT [ ARP.play_counter [ p_lcb.a.side ] ]{ + ($ARP.oct_counter * 12)}
            else
                ARP.played_note [ p_lcb.a.side ]     := ARP.play_buffer_RIGHT [ ARP.play_counter [ p_lcb.a.side ] ]{ + ($ARP.oct_counter * 12)}
            end if

        case __ARP_MODE_UP
            if p_lcb.a.side = __LEFT
                ARP.played_note [ p_lcb.a.side ] := ARP.play_up_buffer_LEFT [ ARP.play_counter [ p_lcb.a.side ] ]
            else
                ARP.played_note [ p_lcb.a.side ] := ARP.play_up_buffer_RIGHT [ ARP.play_counter [ p_lcb.a.side ] ]
            end if

        case __ARP_MODE_DOWN
            if p_lcb.a.side = __LEFT
                ARP.played_note [ p_lcb.a.side ] := ARP.play_down_buffer_LEFT [ ARP.play_counter [ p_lcb.a.side ] ]
            else
                ARP.played_note [ p_lcb.a.side ] := ARP.play_down_buffer_RIGHT [ ARP.play_counter [ p_lcb.a.side ] ]
            end if

        case __ARP_MODE_UP_DOWN
            if p_lcb.a.side = __LEFT
                ARP.played_note [ p_lcb.a.side ] := ARP.play_up_buffer_LEFT [ ARP.up_down_counter [ p_lcb.a.side ] ]
            else
                ARP.played_note [ p_lcb.a.side ] := ARP.play_up_buffer_RIGHT [ ARP.up_down_counter [ p_lcb.a.side ] ]
            end if

        case __ARP_MODE_RANDOM
            if p_lcb.a.side = __LEFT
                ARP.temp3 := random(0, ARP.cursor [ p_lcb.a.side ] - 1)
                // while (ARP.last_random_note [ p_lcb.a.side ] = ARP.played_note [ p_lcb.a.side ])
                ARP.played_note [ p_lcb.a.side ] := ARP.play_buffer_LEFT [ ARP.temp3 ]
                // end while
            else
                ARP.temp4 := random(0, ARP.cursor [ p_lcb.a.side ] - 1)
                // while (ARP.last_random_note [ p_lcb.a.side ] = ARP.played_note [ p_lcb.a.side ])
                ARP.played_note [ p_lcb.a.side ] := ARP.play_buffer_RIGHT [ ARP.temp4 ]
                // end while
            end if

        case __ARP_MODE_CHORD { treated directly at the play level }
    end select
end function

function PLAY_NOTE_NCB
    layers.note_events [ pn_ncb.a.side,  pn_ncb.a.note ] := play_note(pn_ncb.a.note, pn_ncb.a.velo, -1, -1)
    set_event_par_arr(layers.note_events [ pn_ncb.a.side, pn_ncb.a.note ], EVENT_PAR_ALLOW_GROUP, __OFF, ALL_GROUPS)
    { PENDING: group as side here is just for testing}
    set_event_par_arr(layers.note_events [ pn_ncb.a.side, pn_ncb.a.note ], EVENT_PAR_ALLOW_GROUP, __ON,  pn_ncb.a.side)
end function

function fn027_play_lcb_core
    if SEQ.step_velocity > 1
        layers.note_events [ fn027.a.side, fn027.a.note ] := ...
            play_note(                      ...
                fn027.a.note,              ...
                SEQ.step_velocity,          ...
                -1,                         ...
                SEQ.DUAL.step_duration [ fn027.a.side ] * 500     ...
            )                               ...

        set_event_par_arr(layers.note_events [ fn027.a.side, fn027.a.note ], EVENT_PAR_ALLOW_GROUP, __OFF, ALL_GROUPS)
        { PENDING: group here is just for testing example -> side }
        set_event_par_arr(layers.note_events [ fn027.a.side, fn027.a.note ], EVENT_PAR_ALLOW_GROUP, __ON,  fn027.a.side)

        { adjust event according to seq modulations }
        change_tune( ...
            layers.note_events [ fn027.a.side, fn027.a.note ], ...
            SEQ.step_pitch * 100000 + SEQ.step_octave * 1200000, 0)

        change_pan( ...
            layers.note_events [ fn027.a.side, fn027.a.note ], ...
            SEQ.step_pan, 0 )

        { filter seq setting }
        if fn026.r.filter_status = __ON
            set_engine_par(ENGINE_PAR_CUTOFF, SEQ.step_lp_filter, __NO_GROUP, __LP_FILTER_SLOT, NI_BUS_OFFSET+fn027.a.side)
            set_engine_par(ENGINE_PAR_CUTOFF, SEQ.step_hp_filter, __NO_GROUP, __HP_FILTER_SLOT, NI_BUS_OFFSET+fn027.a.side)
        else
            set_engine_par(ENGINE_PAR_CUTOFF, 1000000, __NO_GROUP, __LP_FILTER_SLOT, NI_BUS_OFFSET+fn027.a.side)
            set_engine_par(ENGINE_PAR_CUTOFF,       0, __NO_GROUP, __HP_FILTER_SLOT, NI_BUS_OFFSET+fn027.a.side)
        end if

    end if
end function

function PLAY_LCB
    select(seq.direction_status [ p_lcb.a.side ])
        case SEQ_DIRECTION_FORWARD  
            p_lcb.l.ts_counter := SEQ.ts_counter

        case SEQ_DIRECTION_BACKWARD 
            if  switch_MAIN.SEQ.combine = __SEQ_DUAL
                { inverts the steps }
                p_lcb.l.ts_counter := ...
                    SEQ.DUAL.step_count [ p_lcb.a.side, SEQ.DUAL.current_block [ p_lcb.a.side ] ] - SEQ.ts_counter
            end if
    end select

    if  switch_MAIN.SEQ.combine = __SEQ_DUAL and ...
        SEQ.DUAL.steps_timestamps [ p_lcb.a.side, SEQ.DUAL.current_block [ p_lcb.a.side ], p_lcb.l.ts_counter ] = ENGINE_UPTIME
        // message(lcb_play_side & " | play LCB -----> step : " & SEQ.ts_counter & ...
        //                             " | block: " & SEQ.DUAL.current_block [ lcb_play_side ] & " play dir: " & layers.seq_play_direction [ lcb_play_side ])
        // message("    PLAY LCB: dir BACKW | step inv " & p_lcb.l.ts_counter)
        // message("    SEQ.DUAL.step_count: " & SEQ.DUAL.step_count [ p_lcb.a.side, SEQ.DUAL.current_block [ p_lcb.a.side ] ])
        // message("    step counter: " & SEQ.ts_counter)
        { update step leds - has to be here, at the timestamp of each step }
        for lcb_block_counter := 0 to 3
            if lcb_block_counter = SEQ.DUAL.current_block [ lcb_play_side ]
                UIID_MAIN.seq.step_leds [                    ...
                    lcb_play_side,                           ...
                    SEQ.DUAL.current_block [ lcb_play_side ] ...
                ] -> picture_state := SEQ.ts_counter + 1
            else
                UIID_MAIN.seq.step_leds [                    ...
                    lcb_play_side,                           ...
                    lcb_block_counter                        ...
                ] -> picture_state := 0
            end if
        end for

        { play }
        if UIID_MAIN.seq.arp_power [ p_lcb.a.side ] -> value = __OFF
            message("ARP OFF ____")
            for SEQ.key_count := 0 to 127
                if KEY_DOWN[ SEQ.key_count ] = 1
                    // message(SEQ.key_count & " <-- key pressed")
                    { first kill the note we are about to play (in case it is still there from NCB or something else )}
                    if layers.note_events [ p_lcb.a.side, SEQ.key_count ] > 0
                        fade_out( layers.note_events [ p_lcb.a.side, SEQ.key_count ], 2000, 1)
                    end if

                    if  UIID_MAIN.seq.flux_rand_btns  [             ...
                            p_lcb.a.side,                           ...
                            SEQ.DUAL.current_block [ p_lcb.a.side ] ...
                        ] -> value = __ON and                       ...
                        UIID_MAIN.seq.flux_rand_power [ p_lcb.a.side ] -> value = __ON
                        
                        fn026.a.data_type := __FLUX_DATA
                        // message(f'<SEQ.ts_counter> | fn26 is reading FLUX')
                    else
                        fn026.a.data_type := __DYN_DATA
                        // message(f'<SEQ.ts_counter> | fn26 is reading DYN')
                    end if
                    fn026.a.side             := p_lcb.a.side
                    fn026.a.key_note         := SEQ.key_count
                    fn026.a.step_counter     := SEQ.ts_counter
                    fn026.a.block_step_index := SEQ.DUAL.current_block [ fn026.a.side ]
                    call fn026_get_seq_target_data
                    { return values from fn026_get_seq_target_data() }

                    { LOG }
                        // message(f'PLAY_LCB, | fn026.r.velocity: <fn026.r.velocity> ')
                        // message(f'PLAY_LCB, | fn026.r.pitch:    <fn026.r.pitch>')
                        // message(f'PLAY_LCB, | fn026.r.octave: <fn026.r.octave> ')
                        // message(f'PLAY_LCB, | fn026.r.filter_value:    <fn026.r.filter_value>')
                        // message(f'PLAY_LCB, | fn026.r.lp_filter_value:    <fn026.r.lp_filter_value>')
                        // message(f'PLAY_LCB, | fn026.r.hp_filter_value:    <fn026.r.hp_filter_value>')

                    SEQ.step_velocity  := fn026.r.velocity
                    SEQ.step_pitch     := fn026.r.pitch
                    SEQ.step_octave    := fn026.r.octave
                    SEQ.step_pan       := fn026.r.pan
                    SEQ.step_filter    := fn026.r.filter_value
                    SEQ.step_lp_filter := fn026.r.lp_filter_value
                    SEQ.step_hp_filter := fn026.r.hp_filter_value

                    fn027.a.side         := p_lcb.a.side
                    fn027.a.note         := SEQ.key_count
                    fn027.a.step_counter := SEQ.ts_counter
                    call fn027_play_lcb_core
                end if
            end for

        else { Arpeggiated notes here }
            fn028.a.side := p_lcb.a.side
            call fn028_update_arp_note_buffers
            
            {{ get played note from buffer according to play mode }}
            call seq.arp.get_play_note_from_buffer

            {{ Actual note generation }}
            if arp_mode [ p_lcb.a.side ] # __ARP_MODE_CHORD
                ARP.played_duration [ p_lcb.a.side ] := SEQ.DUAL.step_duration [ p_lcb.a.side ] * 500
                ARP.played_velocity [ p_lcb.a.side ] := SEQ.step_velocity

                if  UIID_MAIN.seq.flux_rand_btns  [             ...
                        p_lcb.a.side,                           ...
                        SEQ.DUAL.current_block [ p_lcb.a.side ] ...
                    ] -> value = __ON and                       ...
                    UIID_MAIN.seq.flux_rand_power [ p_lcb.a.side ] -> value = __ON
                    
                    fn026.a.data_type := __FLUX_DATA
                else
                    fn026.a.data_type := __DYN_DATA
                end if

                fn026.a.side             := p_lcb.a.side
                fn026.a.key_note         := ARP.played_note [ p_lcb.a.side ]
                fn026.a.step_counter     := SEQ.ts_counter
                fn026.a.block_step_index := SEQ.DUAL.current_block [ p_lcb.a.side ]
                call fn026_get_seq_target_data
                { return values from fn026_get_seq_target_data() }

                SEQ.step_velocity  := fn026.r.velocity
                SEQ.step_pitch     := fn026.r.pitch
                SEQ.step_octave    := fn026.r.octave
                SEQ.step_pan       := fn026.r.pan
                SEQ.step_filter    := fn026.r.filter_value
                SEQ.step_lp_filter := fn026.r.lp_filter_value
                SEQ.step_hp_filter := fn026.r.hp_filter_value

                if layers.note_events [ p_lcb.a.side, ARP.played_note [ p_lcb.a.side ] ] > 0
                    fade_out( layers.note_events [ p_lcb.a.side, ARP.played_note [ p_lcb.a.side ] ], 2000, 1)
                end if

                if (in_range(ARP.played_note [ p_lcb.a.side ], 0, 127))
                    fn027.a.side         := p_lcb.a.side
                    fn027.a.note         := ARP.played_note [ p_lcb.a.side ]
                    fn027.a.step_counter := SEQ.ts_counter
                    call fn027_play_lcb_core
                end if

            else { CHORD MODE HERE }
                ARP.i := 0
                while (ARP.i < ARP.cursor [ p_lcb.a.side ] )
                    if p_lcb.a.side = __LEFT
                        ARP.played_note [ p_lcb.a.side ] := ARP.play_buffer_LEFT [ ARP.i ]
                    else
                        ARP.played_note [ p_lcb.a.side ] := ARP.play_buffer_RIGHT [ ARP.i ]
                    end if

                    ARP.played_duration [ p_lcb.a.side ] := SEQ.DUAL.step_duration [ p_lcb.a.side ] * 500
                    ARP.played_velocity [ p_lcb.a.side ] := SEQ.step_velocity

                    fn026.a.side             := p_lcb.a.side
                    fn026.a.key_note         := ARP.played_note [ p_lcb.a.side ]
                    fn026.a.step_counter     := SEQ.ts_counter
                    fn026.a.block_step_index := SEQ.DUAL.current_block [ p_lcb.a.side ]
                    call fn026_get_seq_target_data
                    { return values from fn026_get_seq_target_data() }

                    SEQ.step_velocity  := fn026.r.velocity
                    SEQ.step_pitch     := fn026.r.pitch
                    SEQ.step_octave    := fn026.r.octave
                    SEQ.step_pan       := fn026.r.pan
                    SEQ.step_filter    := fn026.r.filter_value
                    SEQ.step_lp_filter := fn026.r.lp_filter_value
                    SEQ.step_hp_filter := fn026.r.hp_filter_value

                    if layers.note_events [ p_lcb.a.side, ARP.played_note [ p_lcb.a.side ] ] > 0
                        fade_out( layers.note_events [ p_lcb.a.side, ARP.played_note [ p_lcb.a.side ] ], 2000, 1)
                    end if

                    if (in_range(ARP.played_note [ p_lcb.a.side ], 0, 127))
                        fn027.a.side         := p_lcb.a.side
                        fn027.a.note         := ARP.played_note [ p_lcb.a.side ]
                        fn027.a.step_counter := SEQ.ts_counter
                        call fn027_play_lcb_core
                    end if

                    inc(ARP.i)
                end while

            end if

            if arp_mode [ p_lcb.a.side ] = __ARP_MODE_UP_DOWN
                if (ARP.cursor  [ p_lcb.a.side ] = 2)
                    inc( ARP.up_down_counter [ p_lcb.a.side ] )
                    if ( ARP.up_down_counter [ p_lcb.a.side ] = 2)
                        ARP.up_down_counter [ p_lcb.a.side ] := 0
                    end if
                end if


                if (ARP.cursor  [ p_lcb.a.side ] > 2)
                    if (ARP.up_down_counter  [ p_lcb.a.side ] >= ARP.cursor  [ p_lcb.a.side ] - 1)
                        ARP.up_down_direction  [ p_lcb.a.side ] := 1  { go down }
                    end if

                    if (ARP.up_down_counter  [ p_lcb.a.side ] <= 0)
                        ARP.up_down_direction  [ p_lcb.a.side ] := 0  { go up }
                    end if

                    if ARP.up_down_direction  [ p_lcb.a.side ] = 1 
                        dec( ARP.up_down_counter [ p_lcb.a.side ] )
                    else
                        inc( ARP.up_down_counter [ p_lcb.a.side ] )
                    end if
                end if
            end if

            if arp_mode [ p_lcb.a.side ] = __ARP_MODE_RANDOM
                ARP.last_random_note [ p_lcb.a.side ] := ARP.played_note [ p_lcb.a.side ]
            end if

            { advance play counter }
            inc( ARP.play_counter [ p_lcb.a.side ] )
            if ( ARP.play_counter [ p_lcb.a.side ] >= ARP.cursor [ p_lcb.a.side ] )  { we have finished a cycle }
                 ARP.play_counter [ p_lcb.a.side ] := 0
            end if

        end if
    end if

    if  switch_MAIN.SEQ.combine = __SEQ_JOIN and ...
        SEQ.JOIN.steps_timestamps [ SEQ.JOIN.current_block, SEQ.ts_counter ] = ENGINE_UPTIME

        if switch_MAIN.FLUXX.LEFT.arp.power = __OFF
            for SEQ.key_count := 0 to 127
                if KEY_DOWN[ SEQ.key_count ] = 1
                    { first kill the note we are about to play (in case it is still there from NCB or something else )}
                    if layers.note_events [ p_lcb.a.side, SEQ.key_count ] > 0
                        fade_out( layers.note_events [ p_lcb.a.side, SEQ.key_count ], 2000, 1)
                    end if
                    if layers.note_events [ __RIGHT, SEQ.key_count ] > 0
                        fade_out( layers.note_events [ p_lcb.a.side, SEQ.key_count ], 2000, 1)
                    end if

                    { get the step velocity from either the left or right side, even if it is combined }
                    { here we are only reading the steps, so the distinction of Left and right still applies }
                    if SEQ.JOIN.current_block < 4 { left side }
                        SEQ.step_velocity := (126 *                         ...
                            SEQ.data.i [                                    ...
                                __LEFT,                                     ...
                                SEQ_TARGET_VELO,                            ...
                                SEQ.ts_counter + (SEQ.JOIN.current_block mod 4) * 8 ...
                            ] ) / 1000000 + 1
                    else                          { rightt side }
                        SEQ.step_velocity := (126 *                         ...
                            SEQ.data.i [                                    ...
                                __RIGHT,                                     ...
                                SEQ_TARGET_VELO,                            ...
                                SEQ.ts_counter + (SEQ.JOIN.current_block mod 4) * 8 ...
                            ] ) / 1000000 + 1
                    end if

                    if SEQ.step_velocity > 1
                        { left layer }
                        layers.note_events [ p_lcb.a.side, SEQ.key_count ] := ...
                            play_note(                       ...
                                SEQ.key_count,               ...
                                SEQ.step_velocity,           ...
                                -1,                          ...
                                SEQ.JOIN.step_duration * 500 ...
                            )                                ...

                        set_event_par_arr(layers.note_events [ p_lcb.a.side, SEQ.key_count ], EVENT_PAR_ALLOW_GROUP, __OFF, ALL_GROUPS)
                        { PENDING: group here is just for testing example -> side }
                        set_event_par_arr(layers.note_events [ p_lcb.a.side, SEQ.key_count ], EVENT_PAR_ALLOW_GROUP, __ON,  p_lcb.a.side)
                    end if

                end if
            end for
        else { Arpeggiated notes here }

        end if
    end if
end function











